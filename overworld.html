<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title AINotice="DON'T CHANGE THIS!">Minecraft</title>
    <style>
      /* --- CSS Styles --- */
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: #333;
        cursor: default;
        text-align: center;
      }
      canvas {
        display: block;
      }
      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        transform: translate(-50%, -50%);
        pointer-events: none;
        border: 1px solid rgba(0, 0, 0, 0.5);
        box-sizing: border-box;
        display: none;
      }
      #crosshair::before,
      #crosshair::after {
        content: "";
        position: absolute;
        background: rgba(255, 255, 255, 0.8);
        box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
      }
      #crosshair::before {
        width: 2px;
        height: 10px;
        left: 9px;
        top: 5px;
      }
      #crosshair::after {
        width: 10px;
        height: 2px;
        left: 5px;
        top: 9px;
      }
      #hud {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        /* height: 80px; */ /* Height can often be determined by content */
        padding: 10px; /* Keep padding */
        box-sizing: border-box;
        pointer-events: none;
        display: none; /* Controlled by JS */

        /* --- Flexbox Centering --- */
        display: flex; /* Make it a flex container */
        align-items: flex-end; /* Align items to the bottom */
        justify-content: center; /* Center the group horizontally */
        gap: 20px; /* Optional: Adds space BETWEEN flex items */
      }
      /* NOTE: Adjusted margin calculations based on 50px slot + 2*2px margin = 54px */
      /* --- Styles for the Health Progress Bar --- */

progress#health-bar {
  position: relative;
  bottom: -50px;
  border: 1px solid #333;
  border-radius: 5px;
  background-color: #616161;
  height: 30px;
  width: 250px; /* Keep width */
  display: block;
  margin-bottom: 4px;
  box-sizing: border-box;
}

/* --- Style the unfilled track (Webkit) --- */
progress#health-bar::-webkit-progress-bar {
  background-color: #616161;
  border-radius: 2px;
}

/* --- Style the FILLED value bar (Webkit) --- */
progress#health-bar::-webkit-progress-value {
  background-color: #F44336; /* Red for health */
  border-radius: 2px;
  background-image: none;
  box-shadow: none;
  transition: width 0.2s ease-in-out;
}

/* --- Style the FILLED value bar (Firefox) --- */
progress#health-bar::-moz-progress-bar {
  background-color: #F44336; /* Red for health */
  border-radius: 2px;
  background-image: none;
  box-shadow: none;
  transition: width 0.1s ease-in-out;
}

/* --- REMOVE ALL old .heart styles --- */
/* .hud-icon.heart { ... } */
/* .heart::before { ... } */
/* etc. */
      #inventory-ui {
        display: flex;
        background-color: rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(100, 100, 100, 0.7);
        padding: 5px;
        box-sizing: border-box;
      }
      #hunger-bar {
        position: relative;
        right: 6em;
        display: flex;
        flex-direction: row-reverse;
        margin-right: calc(
          50% - (9 * 54px / 2) - 91px
        ); /* Center relative to hotbar */
      }
      .hud-icon {
        width: 18px;
        height: 18px;
        margin: 0 1px;
        background-size: cover;
        image-rendering: pixelated;
        position: relative;
      }
      .heart::before {
        content: "";
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: grey;
      }
      .heart.full::before {
        background-color: red;
      }
      .heart.half::before {
        background-color: pink;
      }
      .heart.empty::before {
        background-color: dimgrey;
      }
      .hunger::before {
        content: "";
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: sienna;
        border: 1px solid saddlebrown;
        box-sizing: border-box;
      }
      .hunger.full::before {
        background-color: peru;
      }
      .hunger.empty::before {
        background-color: dimgrey;
        border-color: black;
      }
      .inventory-slot {
        width: 50px;
        height: 50px;
        border: 2px solid rgba(200, 200, 200, 0.5);
        margin: 2px;
        background-color: rgba(50, 50, 50, 0.5);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        color: white;
        position: relative;
        user-select: none;
        box-sizing: border-box;
      }
      .inventory-slot.selected {
        border-color: white;
        box-shadow: 0 0 5px white;
      }
      .slot-item-name {
        text-transform: capitalize;
        margin-bottom: 3px;
        pointer-events: none;
      }
      .slot-item-count {
        position: absolute;
        bottom: 2px;
        right: 4px;
        font-size: 12px;
        font-weight: bold;
        text-shadow: 1px 1px 1px black;
        pointer-events: none;
      }
      #full-inventory-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: calc(9 * 54px + 20px);
        background-color: rgba(10, 10, 10, 0.85);
        border: 3px solid #555;
        border-radius: 5px;
        padding: 10px;
        box-sizing: border-box;
        display: none;
        flex-direction: column;
        align-items: center;
        pointer-events: auto;
      }
      #inventory-top-row {
        display: flex;
        justify-content: space-between;
        width: 100%;
        margin-bottom: 15px;
        align-items: flex-start;
      }
      #armor-slots-container {
        display: flex;
      }
      #armor-slots-container .inventory-slot {
        background-color: rgba(80, 80, 80, 0.6);
      }
      #crafting-area {
        display: flex;
        align-items: center;
      }
      #crafting-grid {
        display: grid;
        grid-template-columns: repeat(2, 54px);
        grid-template-rows: repeat(2, 54px);
        gap: 1px;
      }
      #crafting-area::after {
        content: "â†’";
        font-size: 24px;
        color: #ccc;
        margin: 0 10px;
      }
      #crafting-output-slot .inventory-slot {
        background-color: rgba(70, 70, 100, 0.6);
      }
      #storage-inventory-container {
        display: grid;
        grid-template-columns: repeat(9, 54px);
        gap: 1px;
        margin-bottom: 10px;
      }
      #hotbar-inventory-container {
        position: absolute;
        left: 800px;
        display: grid;
        grid-template-columns: repeat(9, 54px);
        gap: 1px;
        margin-top: 5px;
        border-top: 1px solid #444;
        padding-top: 10px;
      }
      #item-on-cursor-display {
        position: absolute;
        width: 50px;
        height: 50px;
        background-color: rgba(100, 100, 100, 0.7);
        border: 2px solid white;
        border-radius: 3px;
        display: none;
        pointer-events: none;
        z-index: 1000;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        color: white;
        box-sizing: border-box;
      }
      #item-on-cursor-display .slot-item-name {
        position: static;
        text-shadow: 1px 1px 1px black;
      }
      #item-on-cursor-display .slot-item-count {
        position: absolute;
        bottom: 2px;
        right: 4px;
        text-shadow: 1px 1px 1px black;
      }
            /* --- Styles for Crafting Table Screen --- */
            #crafting-table-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        /* Width: 3 grid slots + padding + arrow + output + padding */
        width: calc(3 * 54px + 2 * 10px + 30px + 54px + 10px);
        background-color: rgba(10, 10, 10, 0.85);
        border: 3px solid #555;
        border-radius: 5px;
        padding: 10px;
        box-sizing: border-box;
        display: none; /* Initially hidden */
        flex-direction: column;
        align-items: center;
        pointer-events: auto;
      }

      #crafting-table-main-area {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
        width: 100%;
        justify-content: center; /* Center grid/arrow/output */
      }

      #crafting-table-label {
          position: absolute;
          top: 10px;
          left: 15px;
          color: #ccc;
          font-size: 14px;
      }


      #crafting-table-grid {
        display: grid;
        grid-template-columns: repeat(3, 54px);
        grid-template-rows: repeat(3, 54px);
        gap: 1px;
        margin-right: 10px; /* Space before arrow */
      }

      #crafting-table-arrow {
          font-size: 24px;
          color: #ccc;
          margin: 0 10px;
      }

      #crafting-table-output-slot .inventory-slot {
          background-color: rgba(70, 70, 100, 0.6);
      }

       /* Use specific IDs for storage/hotbar in CT screen */
      #storage-inventory-container-ct,
      #hotbar-inventory-container-ct {
        display: grid;
        grid-template-columns: repeat(9, 54px);
        gap: 1px;
      }
       #storage-inventory-container-ct {
           margin-bottom: 10px;
       }
       #hotbar-inventory-container-ct {
        margin-top: 5px;
        border-top: 1px solid #444;
        padding-top: 10px;
      }

       /* Rename old storage/hotbar container selectors */
       #storage-inventory-container-inv,
       #hotbar-inventory-container-inv {
        display: grid;
        grid-template-columns: repeat(9, 54px);
        gap: 1px;
       }
       #storage-inventory-container-inv {
            margin-bottom: 10px;
       }
       #hotbar-inventory-container-inv {
        margin-top: 5px;
        border-top: 1px solid #444;
        padding-top: 10px;
       }
       progress#airBubble{
        position: relative;
      bottom: -50px;
      border: 1px solid #333;
      border-radius: 5px;
      background-color: #616161;
      height: 30px;
      width: 250px;
      display: block;
      margin-bottom: 4px;
      box-sizing: border-box;
       }
       /* --- Styles for Furnace UI Screen --- */
#furnace-screen {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  /* Adjust width based on content.
     Approx: 3 slots wide + padding + progress indicators
     (54*3) + (2*2px margins per slot) + (some space for progress) + (2*padding) */
  width: calc(3 * 54px + 2 * 4px + 80px + 2 * 10px);
  background-color: rgba(10, 10, 10, 0.85); /* Dark background */
  border: 3px solid #555; /* Similar to other UIs */
  border-radius: 5px;
  padding: 10px;
  box-sizing: border-box;
  display: none; /* Initially hidden, controlled by JS */
  flex-direction: column;
  align-items: center;
  pointer-events: auto; /* Allow interaction */
  color: #ccc; /* Default text color */
}

#furnace-label {
  position: absolute;
  top: 10px;
  left: 15px;
  font-size: 14px;
  color: #ccc;
}

#furnace-main-area {
  display: flex;
  flex-direction: column; /* Stack input/fuel above progress/output */
  align-items: center;
  margin-bottom: 15px;
  width: 100%;
}

/* Styling for the row containing input/fuel and output */
.furnace-io-row {
    display: flex;
    justify-content: space-around; /* Or center, depending on layout */
    align-items: center;
    width: 100%; /* Or fit to content */
    margin-bottom: 8px;
}


/* Container for individual slots to help with layout if needed */
.inventory-slot-container {
  /* Uses .inventory-slot styles defined globally */
  margin: 5px; /* Spacing around slots */
}

#furnace-input-slot {
    margin-bottom: 20px; /* Space between input and fuel */
}
#furnace-fuel-slot {
    /* Styles for fuel slot if different */
    position: relative;
}

#furnace-output-slot.furnace-output-style .inventory-slot {
  /* Special styling for output slot if needed, similar to crafting output */
  background-color: rgba(70, 70, 100, 0.6);
  /* Larger size to stand out, maybe */
  /* width: 60px; height: 60px; */
}

/* Progress Indicators Styling */
#furnace-progress-indicators {
  display: flex;
  align-items: center;
  justify-content: center; /* Center the progress items */
  height: 54px; /* Match slot height */
  margin: 5px 0; /* Space around progress indicators */
}

.furnace-progress-icon-container {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px; /* Width of the flame icon/bar */
    height: 30px; /* Height of the flame icon/bar */
    margin: 0 10px; /* Space around fuel progress */
}

/* Fuel Burning Progress (flame) */
#furnace-fuel-progress {
  width: 16px;  /* Width of the flame image/bar */
  height: 16px; /* Height of the flame image/bar */
  background-image: url('path/to/your/empty_flame_icon.png'); /* Empty flame icon */
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center bottom; /* Fill from bottom up */
  position: relative; /* For the fill element */
}

#furnace-fuel-progress .furnace-progress-bar-fill.fuel-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 0%; /* Initially 0%, JS will change this to 0-100% */
  background-image: url('path/to/your/filled_flame_icon.png'); /* Filled flame icon */
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center bottom;
  transition: height 0.1s linear; /* Smooth fill */
}


/* Smelting Progress Arrow */
.furnace-arrow-container {
  width: 24px;  /* Width of the arrow */
  height: 18px; /* Height of the arrow */
  position: relative; /* For positioning the progress arrow on top */
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px; /* Size of the arrow character */
  margin: 0 10px; /* Space around arrow */
}

#furnace-smelting-arrow-background {
  color: #555; /* Dark grey for the background arrow */
  position: absolute;
}

#furnace-smelting-arrow-progress {
  color: #999; /* Lighter grey or white for the progress arrow */
  position: absolute;
  overflow: hidden; /* Important for the fill effect */
  width: 0%; /* Initially 0%, JS changes this to 0-100% */
  white-space: nowrap; /* Keep arrow on one line */
  transition: width 0.1s linear; /* Smooth fill */
}


/* Shared styles for mirrored inventory/hotbar containers in furnace UI */
#storage-inventory-container-furnace,
#hotbar-inventory-container-furnace {
  display: grid;
  grid-template-columns: repeat(9, 54px); /* Matches your main inventory */
  gap: 1px; /* Matches your main inventory */
}

#storage-inventory-container-furnace {
  margin-bottom: 10px;
}

#hotbar-inventory-container-furnace {
  margin-top: 5px;
  border-top: 1px solid #444;
  padding-top: 10px;
}
    </style>
  </head>
  <body>
    <div id="crosshair"></div>
    <div id="hud">
      <progress id="airBubble" value="10" max="10"></progress>
      <progress id="health-bar" value="20" max="20">test</progress>
      <div id="hunger-bar"></div>
      <div id="inventory-ui"></div>
    </div>
    <div id="full-inventory-screen">
      <div id="inventory-top-row">
        <div id="armor-slots-container"></div>
        <div id="crafting-area">
          <div id="crafting-grid"></div>
          <div id="crafting-output-slot"></div>
        </div>
      </div>
      <div id="storage-inventory-container-inv"></div>
      <div id="hotbar-inventory-container-inv"></div>
    </div>
    <div id="item-on-cursor-display"></div>
</div>
<div id="item-on-cursor-display"></div>
<div id="crafting-table-screen">
  <div id="crafting-table-main-area">
      <div id="crafting-table-label">Crafting</div>
      <div id="crafting-table-grid"></div>
      <div id="crafting-table-arrow">â†’</div>
      <div id="crafting-table-output-slot"></div>
  </div>
  <div id="storage-inventory-container-ct"></div> <!-- Separate container for CT screen -->
  <div id="hotbar-inventory-container-ct"></div> <!-- Separate container for CT screen -->
</div>
<div id="furnace-screen">
  <div id="furnace-label">Furnace</div>

  <div id="furnace-main-area">
      <!-- Input Slot -->
      <div id="furnace-input-slot" class="inventory-slot-container">
          <!-- The actual .inventory-slot will be dynamically generated by JS -->
      </div>

      <!-- Fuel Slot -->
      <div id="furnace-fuel-slot" class="inventory-slot-container">
          <!-- The actual .inventory-slot will be dynamically generated by JS -->
      </div>

      <!-- Progress Indicators -->
      <div id="furnace-progress-indicators">
          <div class="furnace-progress-icon-container">
              <!-- Fuel Burning Progress (e.g., a flame icon) -->
              <div id="furnace-fuel-progress" class="furnace-progress-bar">
                  <div class="furnace-progress-bar-fill fuel-fill"></div>
              </div>
          </div>

          <div class="furnace-arrow-container">
              <!-- Smelting Progress Arrow -->
              <span id="furnace-smelting-arrow-background">â†’</span> <!-- Background arrow (always visible) -->
              <span id="furnace-smelting-arrow-progress">â†’</span>  <!-- Foreground arrow (fills up) -->
          </div>
      </div>

      <!-- Output Slot -->
      <div id="furnace-output-slot" class="inventory-slot-container furnace-output-style">
          <!-- The actual .inventory-slot will be dynamically generated by JS -->
      </div>
  </div>

  <!-- Inventory and Hotbar (mirrored from main inventory) -->
  <div id="storage-inventory-container-furnace" class="inventory-grid-container">
      <!-- Populated by JS -->
  </div>
  <div id="hotbar-inventory-container-furnace" class="inventory-grid-container">
      <!-- Populated by JS -->
  </div>
</div>
<!-- END: New Crafting Table Screen -->
<script src="three.js"></script>
<script>
  const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
</script>
<script src="db.js"></script>
<script>
        setTimeout(() => {
        saveUnloadedBlocks(world)
      }, 3000)
</script>
<script src="GLTFLoader.js"></script>
<script src="holdItemAnimation.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js"></script>

<script>function hasSolidBlock(x, y, z) {

  const key = getBlockKey(x, y, z);
  return world[key]?.solid === true;
}</script>
<script src="mobs.js"></script>
<script>
  const textureLoader = new THREE.TextureLoader();
const textures = {
    grass: {
      side: textureLoader.load("/textures/grassblock_side.jpg"),
      top: textureLoader.load("/textures/grassblock.jpg"),
      bottom: textureLoader.load("/textures/dirt.jpg"),
    },
    leaves: { all: textureLoader.load("/textures/leaves.jpg") },
    log: {
      side: textureLoader.load("/textures/minecraft_log_side_textures_29.jpg"),
      top: textureLoader.load("/textures/oak_log_top.png"),
      bottom: textureLoader.load("/textures/oak_log_top.png"),
    },
    dirt: { all: textureLoader.load("/textures/dirt.jpg") },
    stone: { all: textureLoader.load("/textures/stone.jpg") },
    plank: { all: textureLoader.load("/textures/planks.jpg") }, // Assumes planks.jpg exists
    craftingtable: {
        side: textureLoader.load("/textures/craftingtable_side.jpg"),
        top: textureLoader.load("/textures/craftingtable_top.jpg"),
        bottom: textureLoader.load("/textures/planks.jpg"),
    },
    furnace: {
      front: textureLoader.load("/textures/furnace_front.png"),
      top: textureLoader.load("/textures/furnace_top.png"),
      bottom: textureLoader.load("/textures/cobblestone.jpg"),
      side: textureLoader.load("/textures/furnace_side.png"),
    },
    cobblestone: { all: textureLoader.load("/textures/cobblestone.jpg") },
    stick: { all: null }, // No texture needed for simple display name
    wooden_pickaxe: { all: textureLoader.load("/textures/wooden_pickaxe.png") },
    wooden_axe: { all: null },
    wooden_shovel: { all: null },
    wooden_sword: { all: null },
    coal_ore: { all: textureLoader.load("/textures/coal_ore.jpg") },
    oxidized_iron_ore: { all: textureLoader.load("/textures/iron_ore.png") },
    water: { all: textureLoader.load("/textures/water.jpg") },
    bedrock: { all: textureLoader.load("/textures/bedrock.png") },
    landmine: { all: textureLoader.load("/textures/moss_block.png") },
  };
  Object.values(textures).forEach((t) =>
    Object.values(t).forEach((tex) => {
      if (tex instanceof THREE.Texture) {
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
      }
    })
  );

  const materials = {
    grass: {
      side: new THREE.MeshLambertMaterial({ map: textures.grass.side }),
      top: new THREE.MeshLambertMaterial({ map: textures.grass.top }),
      bottom: new THREE.MeshLambertMaterial({ map: textures.grass.bottom }),
    },
    leaves: {
      all: new THREE.MeshLambertMaterial({
        map: textures.leaves.all,
        transparent: true,
        alphaTest: 0.1,
        side: THREE.DoubleSide,
      }),
    },
    log: {
      side: new THREE.MeshLambertMaterial({ map: textures.log.side }),
      top: new THREE.MeshLambertMaterial({ map: textures.log.top }),
      bottom: new THREE.MeshLambertMaterial({ map: textures.log.bottom }),
    },
    dirt: { 
      all: new THREE.MeshLambertMaterial({ map: textures.dirt.all }),
    },
    stone: {
      all: new THREE.MeshLambertMaterial({ map: textures.stone.all }),
    },
    bedrock: {
      all: new THREE.MeshLambertMaterial({ map: textures.bedrock.all }),
    },
    plank: {
      all: new THREE.MeshLambertMaterial({ map: textures.plank.all }),
    },
    craftingtable: {
        side: new THREE.MeshLambertMaterial({ map: textures.craftingtable.side }),
        top: new THREE.MeshLambertMaterial({ map: textures.craftingtable.top }),
        bottom: new THREE.MeshLambertMaterial({ map: textures.craftingtable.bottom }),
    },
    furnace: {
        front: new THREE.MeshLambertMaterial({ map: textures.furnace.front }),
        top: new THREE.MeshLambertMaterial({ map: textures.furnace.top }),
        bottom: new THREE.MeshLambertMaterial({ map: textures.furnace.bottom }),
        side: new THREE.MeshLambertMaterial({ map: textures.furnace.side }),
    },
    cobblestone: { all: new THREE.MeshLambertMaterial({ map: textures.cobblestone.all }) },
    coal_ore: { all: new THREE.MeshLambertMaterial({ map: textures.coal_ore.all }) },
    oxidized_iron_ore: { all: new THREE.MeshLambertMaterial({ map: textures.oxidized_iron_ore.all }) },
    water: { all: new THREE.MeshLambertMaterial({
       map: textures.water.all,
        transparent: true,
        opacity: 0.5,
      }) 
    },
    landmine: { all: new THREE.MeshLambertMaterial({ map: textures.landmine.all }) },
    wooden_pickaxe: { all: new THREE.MeshBasicMaterial({ map: textures.wooden_pickaxe.all }) },
    cave_air_all: { all: null }, // No texture needed for air
  };
  

</script>
<script src="breaking.js"></script>
    <script defer>
      let gravity = 0.0025;
      let verticalVelocity = 0;
      let isOnGround = false;
      let jumpHeight = 0.085;

      let droppedItems = [];
      const ITEM_LIFESPAN = 5 * 60 * 1000; //5 mins
      const ITEM_PICKUP_RADIUS = 1.5;
      const ITEM_GRAVITY = 0.002;
      const ITEM_BOUNCE_FACTOR = -0.4;

      const worker = new Worker('chunkWorker.js');
      const worker2 = new Worker('chunkWorkerNew.js');
      const workers = [worker];
      const newWorkers = [worker2]
      const socket = io()

const materialMap = new Map();
function addMaterialToMap(id, material) {
    // Helper to prevent errors if a material is accidentally undefined
    if (material && material instanceof THREE.Material) {
        materialMap.set(id, material);
    } else {
        // Don't warn for null materials like 'stick'
        if (material !== null) {
           console.warn(`MainThread: Attempted to map invalid material for ID: ${id}`);
        }
    }
}

// Populate the map (make sure identifiers match EXACTLY what the worker sends)
// Use the identifiers generated by the worker's getMaterialIdentifierForBlockFace
addMaterialToMap('grass_top', materials.grass.top);
addMaterialToMap('grass_bottom', materials.grass.bottom);
addMaterialToMap('grass_side', materials.grass.side);
addMaterialToMap('log_top', materials.log.top); // Assuming top/bottom use same texture/material ID
addMaterialToMap('log_side', materials.log.side);
addMaterialToMap('leaves_all', materials.leaves.all);
addMaterialToMap('dirt_all', materials.dirt.all);
addMaterialToMap('stone_all', materials.stone.all);
addMaterialToMap('plank_all', materials.plank.all);
addMaterialToMap('craftingtable_top', materials.craftingtable.top);
addMaterialToMap('craftingtable_bottom', materials.craftingtable.bottom);
addMaterialToMap('craftingtable_side', materials.craftingtable.side);
addMaterialToMap('cobblestone_all', materials.cobblestone.all);
addMaterialToMap('coal_ore_all', materials.coal_ore.all);
addMaterialToMap('oxidized_iron_ore_all', materials.oxidized_iron_ore.all);
addMaterialToMap('water_all', materials.water.all);
addMaterialToMap('bedrock_all', materials.bedrock.all);
addMaterialToMap('wooden_pickaxe_all', materials.wooden_pickaxe.all);
addMaterialToMap('furnace_front', materials.furnace.front);
addMaterialToMap('furnace_top', materials.furnace.top);
addMaterialToMap('furnace_bottom', materials.furnace.bottom);
addMaterialToMap('furnace_side', materials.furnace.side);
addMaterialToMap('cave_air_all', materials.cave_air_all.all);
addMaterialToMap('landmine_all', materials.landmine.all);
addMaterialToMap('landmine_all', materials.landmine.all);
// Add entries for ALL block types and faces worker generates identifiers for.

// --- Main Thread Disposal Function (ensure this exists and is correct) ---
// --- In overworld.html ---
const experimental = true;
let chunksMax = 25;
const indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
indexedDB.deleteDatabase("worldDB");
let worldDB = indexedDB.open("worldDB", 1);

worldDB.onupgradeneeded = function(event) {
  const db = event.target.result;
  db.createObjectStore("world", { keyPath: "id" });
};

worldDB.onsuccess = function(event) {
  const db = event.target.result;
  console.log("World DB opened successfully.");
};

function disposeChunkMeshes2(chunk) {
  // --- ADD THIS CALL ---
  // Before dealing with the meshes, remove the chunk's block data from the client's 'world' object.
  if (chunk) {
      removeChunkBlocksFromClientMemory(chunk);
  }

  let needsToRedo = false;
  let meshesRemoved = 0;
    if (chunk && chunk.meshes) { // Add a check for chunk existence
        chunk.meshes.forEach((mesh) => {
                 scene.remove(mesh);
                  if(!mesh.isInstancedMesh){
                    mesh = scene.getObjectByName(`chunk_${chunk.id}_mesh_${mesh.faceName}_${mesh.material}`);
                    scene.remove(mesh)
                  }
                 if(scene.children.includes(mesh)){
                    console.warn("Failed to remove mesh from scene:", mesh.name);
                 }
                 else{
                  meshesRemoved++;
                 }
        });
        //clear meshes from that specific chunk
        // Check if the chunk still exists on the client before trying to access its meshes property
        if (chunks.has(chunk.id)) {
            chunks.get(chunk.id).meshes.clear();
        }
  }
  else{
    // This warning is now less severe, as the chunk might already be gone.
    // console.warn(`Chunk ${chunk?.id} has no meshes to dispose.`);
  }
}

    // --- Handler for Receiving and Rendering Raw Mesh Data ---
    //START CHANGE
socket.on("chunkMeshData", data => {
    const { chunkId, meshDataArray } = data;
    const chunk = chunks.get(chunkId); // Get main thread's chunk object

    // Dispose of any old meshes for this chunk FIRST
    disposeChunkMeshes2(chunk);

    // Ensure the map for storing meshes exists on the main thread chunk object
    if (!chunk.meshes) {
        chunk.meshes = new Map();
    }

    console.time("chunk generation time:")
    meshDataArray.forEach(meshInfo => {
      // ... the rest of your mesh creation logic remains the same ...
//END CHANGE
      if(!meshInfo)console.warn("MeshInfo is null or undefined:", meshInfo);
        const material = materialMap.get(meshInfo.materialIdentifier);
        const geometry = faceGeometries[meshInfo.faceName]; // Geometry by name`

        // --- Error Checking ---
        if (!material && material !== "cave_air_all") { // Allow cave air to be null
            console.error(`MainThread: Material not found for identifier: "${meshInfo.materialIdentifier}" in chunk ${chunkId}.`);
            return; // Skip this mesh
        }
        if (!geometry) {
            console.error(`MainThread: Geometry not found for face name: "${meshInfo.faceName}" in chunk ${chunkId}.`);
            return; // Skip this mesh
        }
        if (!meshInfo.matrices || meshInfo.count <= 0) {
             // console.warn(`MainThread: No matrix data for ${meshInfo.materialIdentifier}/${meshInfo.faceName} in chunk ${chunkId}.`);
             return; // Skip if no instances
        }
        // Check buffer size consistency
         const expectedMatrixBufferSize = meshInfo.count * 16 * 4; // count * 16 floats/matrix * 4 bytes/float
         if (!meshInfo.matrices || meshInfo.matrices.byteLength !== expectedMatrixBufferSize) {
              console.error(`MainThread: Matrix ArrayBuffer size mismatch for ${meshInfo.materialIdentifier}/${meshInfo.faceName}. Expected ${expectedMatrixBufferSize}, got ${meshInfo.matrices?.byteLength}. Skipping mesh.`);
              return;
         }

        // --- Create the InstancedMesh ON MAIN THREAD ---
        const mesh = new THREE.InstancedMesh(
            geometry,
            material,
            meshInfo.count // Allocate buffer based on actual count
        );
        mesh.receiveShadow = true; // Enable shadows
        mesh.count = meshInfo.count; // Set instances to draw
        mesh.name = `chunk_${chunkId}_mesh_${meshInfo.faceName}_${meshInfo.materialIdentifier}`;

        // --- Apply Instance Data ---
        const matrices = new Float32Array(meshInfo.matrices); // Create view from buffer
        mesh.instanceMatrix.set(matrices);                   // Copy matrices
        mesh.instanceMatrix.needsUpdate = true;              // IMPORTANT!

        try{
          scene.add(mesh);
        }
        catch{
            console.error(`MainThread: Failed to add mesh ${mesh.name} to scene.`);
        }
        chunk.meshes.set(mesh.name, mesh); // Store on main thread chunk
    });
    console.timeEnd("chunk generation time:")
    chunk.state = ChunkState.Active; // Update main thread state
})
    socket.on("chunkMeshEmpty", data => {
        const { chunkId } = data;
        const chunk = chunks.get(chunkId);
        console.log(chunk)
        if (chunk) {
            // console.log(`MainThread: Chunk ${chunkId} is empty.`);
            disposeChunkMeshes2(chunk);    // Ensure old meshes are gone
            console.log("attempted to remove mesh")
            chunk.state = ChunkState.Active; // Mark as processed
        }
    })
    socket.on("chunkDataLoaded", data =>{ // Handle block data if you implement that pattern
        if (data.blocks) {
            Object.assign(world, data.blocks);
            const chunk = chunks.get(getChunkId(data.cx, data.cz));
            if (chunk && chunk.state === ChunkState.LoadingData) {
                chunk.state = ChunkState.DataLoaded;
                chunksNeedUpdate = true;
            }
        }
    })
    socket.on('chunkDataLoaded', data => {
        const { cx, cz, blocks } = data;
        const chunkId = getChunkId(cx, cz);
        const chunk = chunks.get(chunkId);

        // 1. Check if the chunk is still relevant and waiting for data
        if (!chunk) {
            chunks.set(chunkId, {
                id: chunkId,
                state: ChunkState.DataLoaded, // Mark as loaded to avoid future issues
                meshes: new Map(),
            });
            chunk = chunks.get(chunkId);
        }
        if (chunk.state !== ChunkState.LoadingData) {
             console.warn(`MainThread: Received block data for chunk ${chunkId} but its state is ${chunk.state}. Ignoring.`);
             return;
        }

        // 2. Merge the received block data into the main thread's world object
        if (blocks) {
            // console.log(`MainThread: Merging ${Object.keys(blocks).length} blocks for chunk ${chunkId} into main world.`);
            Object.assign(world, blocks);
            // console.log(`MainThread: World object size now: ${Object.keys(world).length}`);
        } else {
             console.warn(`MainThread: Received 'chunkDataLoaded' for ${chunkId} but 'blocks' data was missing.`);
        }

        // 3. Update the chunk's state on the main thread
        chunk.state = ChunkState.DataLoaded;

        // 4. Signal that the main update loop might need to run again
        //    (to potentially trigger the meshing request for this chunk)
        chunksNeedUpdate = true;

    })
    socket.on("disposeChunkMesh", data => {
      const chunk = chunks.get(data);
      disposeChunkMeshes2(chunk);
    })
    </script>
        <!-- === START: SIMPLEX NOISE Code === -->
        <script>
            /**
             * A Simplex Noise implementation in JavaScript.
             * Based on the work of Ken Perlin and Stefan Gustavson.
             * Provides 2D and 3D noise functions.
             * Includes a seeded pseudo-random number generator for permutation table shuffling.
             */
            class SimplexNoise {
                /**
                 * Creates a new SimplexNoise instance.
                 * @param {number|string} [seed] - Optional seed for the random number generator. If not provided, Math.random() is used.
                 */
                constructor(seed) {
                    // --- Internal Pseudo-Random Number Generator (PRNG) - Mulberry32 ---
                    this.random = (function (seedStr) {
                        let seed = 1; // Default seed
                        if (typeof seedStr === 'string') {
                            seed = 0;
                            for (let i = 0; i < seedStr.length; i++) {
                                seed = (seed * 31 + seedStr.charCodeAt(i)) | 0; // Use bitwise OR for 32-bit integer
                            }
                        } else if (typeof seedStr === 'number') {
                            seed = seedStr;
                        } else if (seed === undefined) {
                            seed = Math.floor(Math.random() * 0xFFFFFFFF);
                        }
                        seed = (seed === 0) ? 1 : seed | 0; // Ensure seed is a non-zero integer
      
                        return function () {
                            let t = seed += 0x6D2B79F5;
                            t = Math.imul(t ^ t >>> 15, t | 1);
                            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                            return ((t ^ t >>> 14) >>> 0) / 4294967296; // Convert to float [0, 1)
                        };
                    })(seed);
      
                    // --- Permutation Table Initialization ---
                    this.p = new Uint8Array(256);
                    for (let i = 0; i < 256; i++) { this.p[i] = i; }
                    for (let i = 255; i > 0; i--) {
                        const j = Math.floor(this.random() * (i + 1));
                        [this.p[i], this.p[j]] = [this.p[j], this.p[i]]; // Swap
                    }
                    this.perm = new Uint8Array(512);
                    this.permMod12 = new Uint8Array(512);
                    for (let i = 0; i < 512; i++) {
                        this.perm[i] = this.p[i & 255];
                        this.permMod12[i] = this.perm[i] % 12;
                    }
      
                    // --- Simplex Noise Constants ---
                    this.F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                    this.G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
                    this.F3 = 1.0 / 3.0;
                    this.G3 = 1.0 / 6.0;
                    this.grad3 = [
                        [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
                        [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
                        [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
                    ];
                    this.grad2 = [
                         [1, 0], [-1, 0], [0, 1], [0, -1],
                         [1, 1], [-1, 1], [1, -1], [-1, -1]
                    ];
                }
      
                dot(g, x, y) { return g[0] * x + g[1] * y; }
                dot3(g, x, y, z) { return g[0] * x + g[1] * y + g[2] * z; }
      
                noise2D(xin, yin) {
                    let n0, n1, n2;
                    const s = (xin + yin) * this.F2;
                    const i = Math.floor(xin + s);
                    const j = Math.floor(yin + s);
                    const t = (i + j) * this.G2;
                    const X0 = i - t;
                    const Y0 = j - t;
                    const x0 = xin - X0;
                    const y0 = yin - Y0;
                    let i1, j1;
                    if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
                    const x1 = x0 - i1 + this.G2;
                    const y1 = y0 - j1 + this.G2;
                    const x2 = x0 - 1.0 + 2.0 * this.G2;
                    const y2 = y0 - 1.0 + 2.0 * this.G2;
                    const ii = i & 255;
                    const jj = j & 255;
                    const gi0 = this.perm[ii + this.perm[jj]] % this.grad2.length;
                    const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % this.grad2.length;
                    const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % this.grad2.length;
                    let t0 = 0.5 - x0 * x0 - y0 * y0;
                    if (t0 < 0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * this.dot(this.grad2[gi0], x0, y0); }
                    let t1 = 0.5 - x1 * x1 - y1 * y1;
                    if (t1 < 0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * this.dot(this.grad2[gi1], x1, y1); }
                    let t2 = 0.5 - x2 * x2 - y2 * y2;
                    if (t2 < 0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * this.dot(this.grad2[gi2], x2, y2); }
                    return 70.0 * (n0 + n1 + n2); // Approx [-1, 1]
                }
      
                noise3D(xin, yin, zin) {
                    let n0, n1, n2, n3;
                    const s = (xin + yin + zin) * this.F3;
                    const i = Math.floor(xin + s);
                    const j = Math.floor(yin + s);
                    const k = Math.floor(zin + s);
                    const t = (i + j + k) * this.G3;
                    const X0 = i - t; const Y0 = j - t; const Z0 = k - t;
                    const x0 = xin - X0; const y0 = yin - Y0; const z0 = zin - Z0;
                    let i1, j1, k1; let i2, j2, k2;
                    if (x0 >= y0) {
                        if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                        else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                        else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
                    } else {
                        if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
                        else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
                        else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                    }
                    const x1 = x0 - i1 + this.G3; const y1 = y0 - j1 + this.G3; const z1 = z0 - k1 + this.G3;
                    const x2 = x0 - i2 + 2.0 * this.G3; const y2 = y0 - j2 + 2.0 * this.G3; const z2 = z0 - k2 + 2.0 * this.G3;
                    const x3 = x0 - 1.0 + 3.0 * this.G3; const y3 = y0 - 1.0 + 3.0 * this.G3; const z3 = z0 - 1.0 + 3.0 * this.G3;
                    const ii = i & 255; const jj = j & 255; const kk = k & 255;
                    const gi0 = this.permMod12[ii + this.perm[jj + this.perm[kk]]];
                    const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]];
                    const gi2 = this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]];
                    const gi3 = this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]];
                    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                    if (t0 < 0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0); }
                    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                    if (t1 < 0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1); }
                    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                    if (t2 < 0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2); }
                    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                    if (t3 < 0) n3 = 0.0; else { t3 *= t3; n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3); }
                    return 32.0 * (n0 + n1 + n2 + n3); // Approx [-1, 1]
                }
            }
      
            /**
             * Generates 2D Fractal Brownian Motion (fBm) noise using a SimplexNoise instance.
             */
            function generateFractalNoise2D(simplex, x, y, octaves, persistence, lacunarity, initialFrequency = 0.5, initialAmplitude = 0.5) {
                let total = 0;
                let frequency = initialFrequency;
                let amplitude = initialAmplitude;
                let maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    total += simplex.noise2D(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }
                if (maxValue === 0) return 0;
                return total / maxValue; // Normalized to approx [-1, 1]
            }
            function generateFractalNoise3D(simplex, x, y, z, octaves, persistence, lacunarity, initialFrequency = 0.5, initialAmplitude = 0.5) {
                let total = 0;
                let frequency = initialFrequency;
                let amplitude = initialAmplitude;
                let maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    total += simplex.noise3D(x * frequency, y * frequency, z * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }
                if (maxValue === 0) return 0;
                return total / maxValue; // Normalized to approx [-1, 1]
            }
          </script>
          <!-- === END: SIMPLEX NOISE Code === -->

    <script>
      // --- Core THREE.js Setup ---
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      scene.background = new THREE.Color("rgb(135, 206, 235)");
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      camera.position.y = 1000

      // --- Block Indicator Cube ---
      const indicatorGeometry = new THREE.BoxGeometry(1.01, 1.01, 1.01);
      const indicatorMaterial = new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 10,
      });
      const indicatorEdges = new THREE.EdgesGeometry(indicatorGeometry);
      const indicatorCube = new THREE.LineSegments(
        indicatorEdges,
        indicatorMaterial
      );
      indicatorCube.visible = false;
      scene.add(indicatorCube);
      const beaconLight = new THREE.PointLight(0xffffff, 1, 100);
      const beaconBeam = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1000, 1),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
      )
      beaconLight.position.set(Math.floor(Math.random() * (400 - 300) + 300), -30, Math.floor(Math.random() * (400 - 300) + 300)); //each value between 300 and 400
      beaconBeam.position.set(beaconLight.position.x, beaconLight.position.y, beaconLight.position.z);
      scene.add(beaconLight);
      scene.add(beaconBeam);


      // --- Player Definition ---
      // --- In overworld.html, near Player Definition ---

// Base Player Properties (when standing)
const PLAYER_STANDING_HEIGHT = 1.8;
const PLAYER_STANDING_EYE_LEVEL_OFFSET = 1.62; // From feet
const PLAYER_STANDING_COLLISION_HEIGHT = 1.78;
const PLAYER_WIDTH = 0.6; // Width usually doesn't change

// Shifting Player Properties
const PLAYER_SNEAKING_HEIGHT = 1.5; // How tall when sneaking
const PLAYER_SNEAKING_EYE_LEVEL_OFFSET = 1.35; // Eye level when sneaking (from feet)
const PLAYER_SNEAKING_COLLISION_HEIGHT = 1.48; // Collision height when sneaking

// Dynamic "Current" Player Properties (these will change)
let currentPlayerHeight = PLAYER_STANDING_HEIGHT;
let currentPlayerEyeLevelOffset = PLAYER_STANDING_EYE_LEVEL_OFFSET;
let currentPlayerCollisionHeight = PLAYER_STANDING_COLLISION_HEIGHT;

// Derived values that will be updated
let playerFeetOffset = -currentPlayerEyeLevelOffset; // Camera Y relative to feet = 0
let playerCollisionBottomOffset = -currentPlayerEyeLevelOffset; // Bottom of collision box relative to camera
let playerCollisionTopOffset = playerFeetOffset + currentPlayerCollisionHeight; // Top of collision box relative to camera

// Player's base Y position (feet level) - camera.position.y will be this + eye level
// We don't need a separate playerBaseY if camera.position.y represents the eye level.
// Instead, camera.position.y - currentPlayerEyeLevelOffset = feet position.
      camera.position.set(0, 60, 10);
      // --- Player Stats & State ---
      let playerHealth = 20;
      let playerMaxHealth = 20;
      let playerHunger = 20;
      let playerMaxHunger = 20;
      let isInventoryOpen = false;
      let fallDistance = 0;
      let wasOnGround = false; // To detect the transition to landing

      // --- Add near other player/game state variables ---
      const REGEN_HUNGER_THRESHOLD = 18; // Need >= 18 hunger (9 shanks) to regen
      const HEALTH_REGEN_INTERVAL = 4000; // Milliseconds (4 seconds)
      const saturation_regen_interval = 1000 / 4;
      const HUNGER_COST_PER_REGEN = 1; // Lose 1 hunger point (half shank) per heal
      let timeSinceLastRegen = 0;

      let world = {}

      // --- Chunk Constants & Management ---
      const CHUNK_SIZE = 16;
      const RENDER_DISTANCE = 2;
      const UNLOAD_DISTANCE = RENDER_DISTANCE + 1;
      let chunks = new Map();
      let lastPlayerChunkX = Infinity;
      let lastPlayerChunkZ = Infinity;
      let chunksNeedUpdate = true;

      // --- Instanced Mesh Setup ---
      const MAX_INSTANCES_PER_GEOMETRY_PER_CHUNK = 16 * 16 * 16;
      const faceGeometries = {};
      faceGeometries.right = new THREE.PlaneGeometry(1, 1)
        .rotateY(Math.PI / 2)
        .translate(0.5, 0, 0);
      faceGeometries.left = new THREE.PlaneGeometry(1, 1)
        .rotateY(-Math.PI / 2)
        .translate(-0.5, 0, 0);
      faceGeometries.top = new THREE.PlaneGeometry(1, 1)
        .rotateX(-Math.PI / 2)
        .translate(0, 0.5, 0);
      faceGeometries.bottom = new THREE.PlaneGeometry(1, 1)
        .rotateX(Math.PI / 2)
        .translate(0, -0.5, 0);
      faceGeometries.front = new THREE.PlaneGeometry(1, 1).translate(0, 0, 0.5);
      faceGeometries.back = new THREE.PlaneGeometry(1, 1)
        .rotateY(Math.PI)
        .translate(0, 0, -0.5);
      faceGeometries.right.name = "right";
      faceGeometries.left.name = "left";
      faceGeometries.top.name = "top";
      faceGeometries.bottom.name = "bottom";
      faceGeometries.front.name = "front";
      faceGeometries.back.name = "back";

      function worldToChunkCoords(worldX, worldZ) {
    const cx = Math.floor(worldX / CHUNK_SIZE);
    const cz = Math.floor(worldZ / CHUNK_SIZE);
    return { cx, cz };
  }
  const ChunkState = {
    Unknown: 0,
    LoadingData: 1,
    DataLoaded: 2,
    Meshing: 3,
    Active: 4,
    Inactive: 5,
    NeedsRemesh: 6,
  };
  function chunkToWorldCoords(chunkX, chunkZ) {
return { wx: chunkX * CHUNK_SIZE, wz: chunkZ * CHUNK_SIZE };
}
function getBlock(x, y, z) {
const key = getBlockKey(x, y, z);
const data = world[key];
// Return a copy including the key coordinates for convenience elsewhere
return data ? { ...data, id: key, x: Math.floor(x), y: Math.floor(y), z: Math.floor(z) } : undefined;
}
function getBlockKey(x, y, z) {
return `${Math.floor(x)}_${Math.floor(y)}_${Math.floor(z)}`;
}
  function hasBlock(x, y, z) {
    return world[getBlockKey(x, y, z)] !== undefined;
  }

      let lightLevel = 0;
      let time = 3000;
      let state = "increase"
      const LOD = new THREE.LOD();
      let SCENE2 = new Set();

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.15);
      directionalLight.castShadow = true
      directionalLight.position.set(1, 1, 1);
      let ambientLight = new THREE.AmbientLight()
      ambientLight.color = new THREE.Color(0xffffff)
      ambientLight.intensity = 0.2
      scene.add(ambientLight)
      scene.add(directionalLight);

      // --- Chunk-Specific Instanced Mesh Management ---
      const dummy = new THREE.Object3D();

      // --- Inventory System Data ---
      const DEFAULT_MAX_STACK_SIZE = 64;
      const HOTBAR_SIZE = 9;
      const STORAGE_SIZE = 27;
      const ARMOR_SIZE = 4;
      const CRAFTING_GRID_SIZE = 4; // 2x2
      const CRAFTING_TABLE_GRID_SIZE = 9; // 3x3 <-- New
      let hotbar = Array(HOTBAR_SIZE).fill(null);
      let storage = Array(STORAGE_SIZE).fill(null);
      let armor = Array(ARMOR_SIZE).fill(null);
      let craftingGrid = Array(CRAFTING_GRID_SIZE).fill(null);
      let craftingOutput = null;
      let craftingTableGrid = Array(CRAFTING_TABLE_GRID_SIZE).fill(null); // <-- New
      let craftingTableOutput = null; // <-- New
      let selectedHotbarSlot = 0;
      let itemOnCursor = null;
      const itemOnCursorDisplay = document.getElementById(
        "item-on-cursor-display"
      );
      let isCraftingTableOpen = false; // <-- New
      let isFurnaceOpen = false;

      // Variables for right-click dragging
      let isDragging = false; // <-- New
      let dragButton = -1
      let dragSlots = []; // <-- New (stores slot indices)
      let dragItemType = null; // <-- New (type being dragged)
      const ITEM_MAX_STACK_SIZES = {
          'stone': 64,
          'cobblestone': 64,
          'dirt': 64,
          'grass': 64,
          'log': 64,
          'plank': 64,
          'stick': 64,
          'craftingtable': 64,
          'leaves': 64, // If they dropped themselves
          // Tools are unstackable
          'wooden_pickaxe': 1,
          'wooden_sword': 1,
          'wooden_shovel': 1,
          'wooden_axe': 1,
          'coal_ore': 64,
          'oxidixed_iron_ore': 64,
      };

            // --- ADD THIS FUNCTION ---
            function getItemMaxStackSize(itemType) {
          // Return the specific size if found, otherwise the default
          return ITEM_MAX_STACK_SIZES[itemType] || DEFAULT_MAX_STACK_SIZE;
      }
      // --- END OF FUNCTION TO ADD ---

      // --- Inventory Logic ---
      function getBlockDisplayName(type) {
        return type || "";
      }
function createItemDrop(position, itemType) {
    // Don't drop items that have no visual representation
    if (itemType === 'air' || itemType === 'cave_air' || itemType === 'water') {
        return;
    }

    // Find the correct texture for the item
    let itemTexture = textures.stone.all; // Fallback texture
    if (textures[itemType] && textures[itemType].all) {
        itemTexture = textures[itemType].all;
    } else if (textures[itemType] && textures[itemType].side) {
        // For blocks with multiple textures, pick one (e.g., the side)
        itemTexture = textures[itemType].side;
    }

    // Create the visual for the dropped item (a flat, 2D plane)
    const geometry = new THREE.PlaneGeometry(0.4, 0.4);
    const material = new THREE.MeshBasicMaterial({
        map: itemTexture,
        side: THREE.DoubleSide,
        transparent: true
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(position);
    scene.add(mesh);

    // Create the data object for the item entity
    const itemEntity = {
        mesh: mesh,
        type: itemType,
        position: new THREE.Vector3(position.x, position.y, position.z),
        velocity: new THREE.Vector3((Math.random() - 0.5) * 0.1, 0.05, (Math.random() - 0.5) * 0.1), // Give it a small initial "pop"
        creationTime: performance.now(),
        pickupCooldown: 200,
        onGround: false
    };

    droppedItems.push(itemEntity);
}

function triggerExplosion(x, y, z) {
    const blastRadius = 4; // Standard TNT blast radius
    const detonationQueue = new Set([getBlockKey(x, y, z)]);
    const processedForExplosion = new Set();
    const blocksToRemove = [];
    const affectedBlocks = []; // This will now store objects with coordinates
    const affectedChunkIds = new Set();

    while (detonationQueue.size > 0) {
        const blockKey = detonationQueue.values().next().value;
        detonationQueue.delete(blockKey);
        
        if (processedForExplosion.has(blockKey)) continue;
        processedForExplosion.add(blockKey);

        const pos = blockKey.split('_').map(Number);
        const ex = pos[0], ey = pos[1], ez = pos[2];
        
        if (world[blockKey]) {
            // No need to drop the landmine itself, so we don't add it to affectedBlocks
            delete world[blockKey];
            blocksToRemove.push({ x: ex, y: ey, z: ez });
            affectedChunkIds.add(getChunkId(Math.floor(ex / CHUNK_SIZE), Math.floor(ez / CHUNK_SIZE)));
        }
        
        for (let dx = -blastRadius; dx <= blastRadius; dx++) {
            for (let dy = -blastRadius; dy <= blastRadius; dy++) {
                for (let dz = -blastRadius; dz <= blastRadius; dz++) {
                    if (dx*dx + dy*dy + dz*dz > blastRadius * blastRadius) continue;

                    const blockX = ex + dx;
                    const blockY = ey + dy;
                    const blockZ = ez + dz;
                    const key = getBlockKey(blockX, blockY, blockZ);
                    const block = world[key];

                    if (!block) continue;

                    if (block.type === 'landmine' && !processedForExplosion.has(key)) {
                        detonationQueue.add(key);
                    } 
                    else if (block.type !== 'bedrock') {
                        // **** START CHANGE ****
                        // Store the block's position AND its type
                        affectedBlocks.push({ x: blockX, y: blockY, z: blockZ, type: block.type });
                        // **** END CHANGE ****

                        delete world[key];
                        blocksToRemove.push({ x: blockX, y: blockY, z: blockZ });
                        affectedChunkIds.add(getChunkId(Math.floor(blockX / CHUNK_SIZE), Math.floor(blockZ / CHUNK_SIZE)));
                    }
                }
            }
        }
    }

    // --- Send Batched Updates to Worker ---
    blocksToRemove.forEach(pos => {
        socket.emit('removeBlockWorker', pos);
    });
    
    // --- Create Item Drops with a 30% Chance ---
    // **** START CHANGE: This whole loop is revised ****
    affectedBlocks.forEach(blockInfo => {
        let dropType = blockInfo.type;

        // Handle special drop cases (stone -> cobblestone, etc.)
        if (dropType === 'stone') dropType = 'cobblestone';
        if (dropType === 'grass') dropType = 'dirt';
        if (dropType === 'leaves' && Math.random() < 0.1) dropType = 'apple';

        // Don't drop useless items
        if (dropType !== 'air' && dropType !== 'cave_air' && dropType !== 'water' && dropType !== 'bedrock') {
            createItemDrop({ x: blockInfo.x + 0.5, y: blockInfo.y + 0.5, z: blockInfo.z + 0.5 }, dropType);
        }
    });
    // **** END CHANGE ****
    
    // Remesh all affected chunks at once
    if (affectedChunkIds.size > 0) {
        socket.emit('remeshChunks', Array.from(affectedChunkIds));
    }
    // --- Player Damage Calculation ---
    const playerFeetY = camera.position.y - currentPlayerEyeLevelOffset;
    const playerPos = new THREE.Vector3(camera.position.x, playerFeetY, camera.position.z);
    const explosionCenter = new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5);
    const distanceToPlayer = playerPos.distanceTo(explosionCenter);

    const maxDamage = 15; 
    const damageFalloff = distanceToPlayer / (blastRadius * 2);

    if (damageFalloff < 1.0) {
        const damage = Math.floor(maxDamage * (1.0 - damageFalloff));
        if (damage > 0) {
            applyDamage(damage, "explosion");
        }
    }
}
      function addToInventory(itemType, count = 1) {
        if (!itemType || count <= 0) return false;
        let remainingCount = count;
        const maxStack = getItemMaxStackSize(itemType); // Get max stack size for this item

        const tryAddToSlots = (slots) => {
          // First pass: Add to existing compatible stacks
          for (let i = 0; i < slots.length; i++) {
            if (
              slots[i] &&
              slots[i].type === itemType &&
              slots[i].count < maxStack // Use specific maxStack
            ) {
              const canAdd = maxStack - slots[i].count;
              const amountToAdd = Math.min(remainingCount, canAdd);
              slots[i].count += amountToAdd;
              remainingCount -= amountToAdd;
              if (remainingCount <= 0) return true; // Fully added
            }
          }
          // Second pass: Add to empty slots
          for (let i = 0; i < slots.length; i++) {
            if (slots[i] === null) {
              const amountToAdd = Math.min(remainingCount, maxStack); // Use specific maxStack
              slots[i] = { type: itemType, count: amountToAdd };
              remainingCount -= amountToAdd;
              if (remainingCount <= 0) return true; // Fully added
            }
          }
          return false; // Not fully added to this set of slots
        };

        // Try adding to hotbar first, then storage
        if (tryAddToSlots(hotbar)) {
          updateInventoryUI(); // Update UI if changes were made
          return true;
        }
        if (tryAddToSlots(storage)) {
          updateInventoryUI(); // Update UI if changes were made
          return true;
        }

        // Check if *any* were added, even if not all
        if (remainingCount < count) {
          console.log(
            `Partially added ${count - remainingCount} of ${itemType}. Inventory might be full.`
          );
          updateInventoryUI(); // Update UI for partial add
          return true; // Indicate *some* success
        } else {
          return false; // Indicate failure
        }
      }
      // --- UI Update Functions ---
      function renderSlot(item, index, isSelected = false) {
        const slot = document.createElement("div");
        slot.classList.add("inventory-slot");
        slot.dataset.slotIndex = index;
        if (isSelected) {
          slot.classList.add("selected");
        }
        if (item) {
          const nameSpan = document.createElement("span");
          nameSpan.classList.add("slot-item-name");
          nameSpan.textContent = getBlockDisplayName(item.type);
          slot.appendChild(nameSpan);
          if (item.count > 1) {
            const countSpan = document.createElement("span");
            countSpan.classList.add("slot-item-count");
            countSpan.textContent = item.count;
            slot.appendChild(countSpan);
          } /* Add texture background here */
        } else {
          slot.style.backgroundColor = "rgba(40, 40, 40, 0.4)";
        }
        return slot;
      }
      function updateInventoryUI() {
        // Standard Hotbar (always potentially visible if HUD is)
        const hotbarContainer = document.getElementById("inventory-ui");
        if (hotbarContainer) hotbarContainer.innerHTML = "";
        else console.error("#inventory-ui not found");

        // Full Inventory Screen Elements
        const storageContainerInv = document.getElementById("storage-inventory-container-inv");
        const armorContainer = document.getElementById("armor-slots-container");
        const hotbarMirrorContainerInv = document.getElementById("hotbar-inventory-container-inv");
        const craftingGridContainer = document.getElementById("crafting-grid");
        const craftingOutputContainer = document.getElementById("crafting-output-slot");

        // Crafting Table Screen Elements
        const storageContainerCt = document.getElementById("storage-inventory-container-ct");
        const hotbarMirrorContainerCt = document.getElementById("hotbar-inventory-container-ct");
        const craftingTableGridContainer = document.getElementById("crafting-table-grid");
        const craftingTableOutputContainer = document.getElementById("crafting-table-output-slot");

        // Clear containers conditionally based on which screen *might* be visible
        if (isInventoryOpen) {
            if (storageContainerInv) storageContainerInv.innerHTML = "";
            else console.error("#storage-inventory-container-inv not found");
            if (armorContainer) armorContainer.innerHTML = "";
            else console.error("#armor-slots-container not found");
            if (hotbarMirrorContainerInv) hotbarMirrorContainerInv.innerHTML = "";
            else console.error("#hotbar-inventory-container-inv not found");
            if (craftingGridContainer) craftingGridContainer.innerHTML = "";
            else console.error("#crafting-grid not found");
            if (craftingOutputContainer) craftingOutputContainer.innerHTML = "";
            else console.error("#crafting-output-slot not found");
        }
         if (isCraftingTableOpen) {
            if (storageContainerCt) storageContainerCt.innerHTML = "";
             else console.error("#storage-inventory-container-ct not found");
            if (hotbarMirrorContainerCt) hotbarMirrorContainerCt.innerHTML = "";
            else console.error("#hotbar-inventory-container-ct not found");
            if (craftingTableGridContainer) craftingTableGridContainer.innerHTML = "";
            else console.error("#crafting-table-grid not found");
            if (craftingTableOutputContainer) craftingTableOutputContainer.innerHTML = "";
            else console.error("#crafting-table-output-slot not found");
        }

        // Render Hotbar (HUD)
        if (hotbarContainer) {
          for (let i = 0; i < HOTBAR_SIZE; i++) {
            hotbarContainer.appendChild(
              renderSlot(hotbar[i], `hotbar-${i}`, i === selectedHotbarSlot)
            );
          }
        }

        // Render Full Inventory Screen (if open)
        if (isInventoryOpen) {
          if (armorContainer) {
            for (let i = 0; i < ARMOR_SIZE; i++) {
              armorContainer.appendChild(renderSlot(armor[i], `armor-${i}`));
            }
          }
          if (craftingGridContainer) {
            for (let i = 0; i < CRAFTING_GRID_SIZE; i++) {
              craftingGridContainer.appendChild(
                renderSlot(craftingGrid[i], `crafting-${i}`)
              );
            }
          }
          if (craftingOutputContainer) {
            checkCraftingRecipe(); // Check 2x2 recipe
            craftingOutputContainer.appendChild(
              renderSlot(craftingOutput, "crafting-output")
            );
          }
          if (storageContainerInv) {
            for (let i = 0; i < STORAGE_SIZE; i++) {
              storageContainerInv.appendChild(
                renderSlot(storage[i], `storage-${i}`)
              );
            }
          }
          if (hotbarMirrorContainerInv) {
            for (let i = 0; i < HOTBAR_SIZE; i++) {
              hotbarMirrorContainerInv.appendChild(
                renderSlot(hotbar[i], `hotbar-${i}`) // Reference main hotbar data
              );
            }
          }
        }

         // Render Crafting Table Screen (if open)
        if (isCraftingTableOpen) {
            if (craftingTableGridContainer) {
                for(let i = 0; i < CRAFTING_TABLE_GRID_SIZE; i++) {
                    craftingTableGridContainer.appendChild(
                        renderSlot(craftingTableGrid[i], `craftingtable-${i}`)
                    );
                }
            }
            if (craftingTableOutputContainer) {
                craftingTableOutputContainer.appendChild(
                    renderSlot(craftingTableOutput, "craftingtable-output")
                );
            }
            if (storageContainerCt) {
                for (let i = 0; i < STORAGE_SIZE; i++) {
                    storageContainerCt.appendChild(
                        renderSlot(storage[i], `storage-${i}`) // Reference main storage data
                    );
                }
            }
            if (hotbarMirrorContainerCt) {
                for (let i = 0; i < HOTBAR_SIZE; i++) {
                    hotbarMirrorContainerCt.appendChild(
                        renderSlot(hotbar[i], `hotbar-${i}`) // Reference main hotbar data
                    );
                }
            }
        }

        updateCursorDisplay();
      }
      function updateCursorDisplay() {
        if (!itemOnCursorDisplay) return;
        if (itemOnCursor) {
          itemOnCursorDisplay.style.display = "flex";
          itemOnCursorDisplay.innerHTML = "";
          const nameSpan = document.createElement("span");
          nameSpan.classList.add("slot-item-name");
          nameSpan.textContent = getBlockDisplayName(itemOnCursor.type);
          itemOnCursorDisplay.appendChild(nameSpan);
          if (itemOnCursor.count > 1) {
            const countSpan = document.createElement("span");
            countSpan.classList.add("slot-item-count");
            countSpan.textContent = itemOnCursor.count;
            itemOnCursorDisplay.appendChild(countSpan);
          }
        } else {
          itemOnCursorDisplay.style.display = "none";
        }
      }
      function updateHealthUI() {
    const healthBar = document.getElementById("health-bar");
    if (!healthBar) {
        console.error("#health-bar progress element not found");
        return;
    }
    // Set the max attribute (usually only needs to be set once, but safe to do here)
    healthBar.max = playerMaxHealth;
    // Set the current value
    healthBar.value = playerHealth;

    // Optional: Change color based on health percentage if desired using classes or direct style
    // const healthPercent = (playerHealth / playerMaxHealth) * 100;
    // if (healthPercent < 25) {
    //     healthBar.classList.add('low-health'); // Add CSS for .low-health
    // } else {
    //     healthBar.classList.remove('low-health');
    // }
}
function updateBubblesUI() {
    const bubblesProgressBar = document.getElementById("airBubble");
    if (!bubblesProgressBar) {
        console.error("#airBubble progress element not found");
        return;
    }
}
      function updateHungerUI() {
        const hungerContainer = document.getElementById("hunger-bar");
        if (!hungerContainer) return;
        hungerContainer.innerHTML = "";
        const fullShanks = Math.floor(playerHunger / 2);
        for (let i = 0; i < playerMaxHunger / 2; i++) {
          const shank = document.createElement("div");
          shank.classList.add("hud-icon", "hunger");
          if (i < fullShanks) {
            shank.classList.add("full");
          } else {
            shank.classList.add("empty");
          }
          hungerContainer.appendChild(shank);
        }
      }
      // --- Add these near your other UI update functions ---

// Call this when the furnace UI needs to be shown or refreshed
let activeFurnace = null;
// --- In overworld.html (global scope or accessible game constants) ---

const SMELTING_RECIPES = {
    'oxidized_iron_ore': { result: 'raw_iron', experience: 0.7 }, // Resulting item type and XP (optional)
    'raw_iron': { result: 'iron_ingot', experience: 0.7 },
    'sand': { result: 'glass', experience: 0.1 },
    'cobblestone': { result: 'stone', experience: 0.1 },
    // Add more: raw_gold -> gold_ingot, clay_ball -> brick, logs -> charcoal (if smelting wood directly for fuel)
    // For food:
    'raw_porkchop': { result: 'cooked_porkchop', experience: 0.35 },
    'raw_beef': { result: 'cooked_beef', experience: 0.35 },
    'potato': { result: 'baked_potato', experience: 0.35 },
    // etc.
};

const TICKS_PER_ITEM_SMELT = 200; // 10 seconds at 20 TPS

const FUEL_VALUES = { // Value in ticks (how long one piece burns)
    'coal': 1600,        // Smelts 8 items (8 * 200 ticks)
    'charcoal': 1600,    // Same as coal
    'log': 300,          // Smelts 1.5 items (1.5 * 200 ticks) - applies to any log type
    'plank': 300,        // Smelts 1.5 items - applies to any plank type
    'wooden_pickaxe': 200, // Smelts 1 item
    'wooden_axe': 200,
    'wooden_shovel': 200,
    'wooden_sword': 200,
    'stick': 100,        // Smelts 0.5 items
    'lava_bucket': 20000 // Smelts 100 items (very long) - Bucket would be consumed/returned
    // Add more fuel types: blaze_rod, sapling, etc.
};

// Helper to get a smelting result
function getSmeltingResult(inputType) {
    return SMELTING_RECIPES[inputType] ? SMELTING_RECIPES[inputType].result : null;
}

// Helper to get fuel burn time
function getFuelBurnTime(fuelType) {
    // Special handling for logs/planks if you have variants like 'oak_log', 'spruce_log'
    if (fuelType && fuelType.includes('log')) return FUEL_VALUES['log'];
    if (fuelType && fuelType.includes('plank')) return FUEL_VALUES['plank'];
    return FUEL_VALUES[fuelType] || 0; // Return 0 if not a valid fuel
}
function updateFurnaceUI() {
    const furnaceScreen = document.getElementById('furnace-screen');
    if (!furnaceScreen || furnaceScreen.style.display === 'none') {
        return; // Don't update if not visible
    }

    // --- Get references to the slot containers ---
    const inputSlotContainer = document.getElementById('furnace-input-slot');
    const fuelSlotContainer = document.getElementById('furnace-fuel-slot');
    const outputSlotContainer = document.getElementById('furnace-output-slot');

    // --- Get references to inventory containers within furnace UI ---
    const storageContainerFurnace = document.getElementById('storage-inventory-container-furnace');
    const hotbarContainerFurnace = document.getElementById('hotbar-inventory-container-furnace');

    // Clear previous slots
    if (inputSlotContainer) inputSlotContainer.innerHTML = '';
    if (fuelSlotContainer) fuelSlotContainer.innerHTML = '';
    if (outputSlotContainer) outputSlotContainer.innerHTML = '';
    if (storageContainerFurnace) storageContainerFurnace.innerHTML = '';
    if (hotbarContainerFurnace) hotbarContainerFurnace.innerHTML = '';

    // Check if we have an active furnace and its data
    if (activeFurnace) {
        // Render Furnace Slots
        if (inputSlotContainer) {
            // Slot ID needs to be unique and identifiable
            inputSlotContainer.appendChild(renderSlot(activeFurnace.inputItem, 'furnace-input-0'));
        }
        if (fuelSlotContainer) {
            fuelSlotContainer.appendChild(renderSlot(activeFurnace.fuelItem, 'furnace-fuel-0'));
        }
        if (outputSlotContainer) {
            outputSlotContainer.appendChild(renderSlot(activeFurnace.outputItem, 'furnace-output-0'));
        }

        // Update Progress Indicators
        updateFurnaceProgressIndicators();

    } else {
        // No active furnace, render empty slots for the furnace part
        if (inputSlotContainer) inputSlotContainer.appendChild(renderSlot(null, 'furnace-input-0'));
        if (fuelSlotContainer) fuelSlotContainer.appendChild(renderSlot(null, 'furnace-fuel-0'));
        if (outputSlotContainer) outputSlotContainer.appendChild(renderSlot(null, 'furnace-output-0'));
        // Reset progress indicators if no active furnace
        updateFurnaceProgressIndicators(true); // Pass true to force reset
    }


    // --- Render Player's Inventory and Hotbar (mirrored) ---
    // Storage
    if (storageContainerFurnace) {
        for (let i = 0; i < STORAGE_SIZE; i++) {
            // Use a prefix for these mirrored slots to distinguish from main inventory if needed for click handling
            storageContainerFurnace.appendChild(renderSlot(storage[i], `storage-furnace-${i}`));
        }
    }
    // Hotbar
    if (hotbarContainerFurnace) {
        for (let i = 0; i < HOTBAR_SIZE; i++) {
            hotbarContainerFurnace.appendChild(renderSlot(hotbar[i], `hotbar-furnace-${i}`));
        }
    }
    // Also update the main cursor display as it's part of general UI
    updateCursorDisplay();
}

// --- In overworld.html ---

function updateFurnaceProgressIndicators(forceReset = false) {
    const fuelFillElement = document.querySelector('#furnace-fuel-progress .fuel-fill');
    const arrowProgressElement = document.getElementById('furnace-smelting-arrow-progress');

    if (!fuelFillElement || !arrowProgressElement) {
        // console.error("Furnace progress elements not found!"); // Already logged
        return;
    }

    if (forceReset || !activeFurnace ) {
        fuelFillElement.style.height = '0%';
        arrowProgressElement.style.width = '0%';
        return;
    }

    // Fuel Progress: Percentage of current fuel piece's burn time that has elapsed
    // The visual should show how much "fire" is left
    let fuelPercentage = 0;
    if (activeFurnace.currentMaxFuelBurnTime > 0) { // Max burn time for the current piece
        fuelPercentage = (activeFurnace.fuelBurnTimeRemaining / activeFurnace.currentMaxFuelBurnTime) * 100;
    }
    fuelFillElement.style.height = `${Math.max(0, Math.min(100, fuelPercentage))}%`;

    // Smelting Progress
    let smeltingPercentage = 0;
    if (activeFurnace.inputItem && TICKS_PER_ITEM_SMELT > 0) {
        smeltingPercentage = (activeFurnace.smeltProgress / TICKS_PER_ITEM_SMELT) * 100;
    }
    arrowProgressElement.style.width = `${Math.max(0, Math.min(100, smeltingPercentage))}%`;
}


// --- Function to open the Furnace UI ---
// This would be called when the player interacts with a furnace block in the world.
// You'll need to get the specific furnace's data from your world.
// --- In overworld.html ---

function openFurnaceUI(furnaceBlockWorldData) { // This is the block data from your 'world' object
    // console.log("MainThread: openFurnaceUI called. Block Data:", furnaceBlockWorldData);

    if (!furnaceBlockWorldData) {
        console.error("MainThread: openFurnaceUI - ABORTING: No furnace block data provided.");
        activeFurnace = null;
        return;
    }

    // Ensure the furnace has its specific data structure.
    // This assumes world[furnaceKey] might just be { type: 'furnace', solid: true } initially.
    const furnaceKey = getBlockKey(furnaceBlockWorldData.x, furnaceBlockWorldData.y, furnaceBlockWorldData.z);
    if (!world[furnaceKey].furnaceData) { // If no specific furnace inventory/state yet
        // console.log(`MainThread: Initializing furnaceData for ${furnaceKey}`);
        world[furnaceKey].furnaceData = {
            inputItem: null,
            fuelItem: null,
            outputItem: null,
            fuelBurnTimeRemaining: 0,
            currentMaxFuelBurnTime: 0,
            smeltProgress: 0,
            smeltTimeTotalForItem: TICKS_PER_ITEM_SMELT, // Store the constant here
            id: furnaceKey
        };
    }

    activeFurnace = world[furnaceKey].furnaceData; // Point to the specific furnace's data

    // Close other UIs
    isCraftingTableOpen = false;
    isInventoryOpen = true;
    isFurnaceOpen = true; // Set furnace flag
    if(document.getElementById("full-inventory-screen")) document.getElementById("full-inventory-screen").style.display = "none";
    if(document.getElementById("crafting-table-screen")) document.getElementById("crafting-table-screen").style.display = "none";

    const furnaceScreen = document.getElementById('furnace-screen');
    if (furnaceScreen) {
        furnaceScreen.style.display = 'flex';
        furnaceScreen.style.pointerEvents = 'auto';
        updateFurnaceUI(); // Populate it
        document.body.style.cursor = 'default';
        if (document.pointerLockElement) {
            document.exitPointerLock();
        }
    } else {
        console.error("MainThread: openFurnaceUI - #furnace-screen element NOT FOUND!");
        activeFurnace = null;
        isFurnaceOpen = false;
    }
}

// --- Function to close the Furnace UI (similar to other UI close functions) ---
// This function should be part of your general `closeInv` logic in the keydown listener
function closeFurnaceUI() { // Called by your main inventory close logic
    const furnaceScreen = document.getElementById('furnace-screen');
    console.log("Closing furnace UI");
    if (furnaceScreen) {
        furnaceScreen.style.display = 'none';
    }
    activeFurnace = null; // Clear the active furnace reference
    // The main `closeInv` function should handle returning cursor items and re-locking pointer
}

      // --- Block Adding/Removing Logic ---
      function internalAddBlock(
        worldX,
        worldY,
        worldZ,
        blockType,
        overwrite = false
      ) {
        const blockKey = getBlockKey(worldX, worldY, worldZ);
        if (!overwrite && world[blockKey]) return;
        const isSolid = ["grass", "log", "dirt", "stone", "plank", "craftingtable", "leaves", "cobblestone", "coal_ore", "oxidized_iron_ore", "bedrock", "landmine"].includes(
          blockType
        );
        world[blockKey] = { type: blockType, solid: isSolid };
        if(blockType === "leaves" || blockType === "water") {
            console.log(world[blockKey])
        }
      }
      function addBlock(x, y, z, blockType) {
    internalAddBlock(x, y, z, blockType, true); // Update main thread world FIRSt
    // 1. Send ONLY the specific block change to the worker
    socket.emit('addBlockWorker', { x, y, z, type: blockType }); // <<< SEND DELTA

    // 2. Determine affected chunk IDs (Keep this logic)
    const cx = Math.floor(x / CHUNK_SIZE);
    const cz = Math.floor(z / CHUNK_SIZE);
    const affectedChunkIds = new Set([getChunkId(cx, cz)]);
    
    const borderXMin = x % CHUNK_SIZE === 0;
    const borderXMax = (x + 1) % CHUNK_SIZE === 0; // Or however you calculate the max border
    const borderZMin = z % CHUNK_SIZE === 0;
    const borderZMax = (z + 1) % CHUNK_SIZE === 0;

    if (borderXMin) affectedChunkIds.add(getChunkId(cx - 1, cz));
    if (borderXMax) affectedChunkIds.add(getChunkId(cx + 1, cz));
    if (borderZMin) affectedChunkIds.add(getChunkId(cx, cz - 1));
    if (borderZMax) affectedChunkIds.add(getChunkId(cx, cz + 1));
    // Optional Diagonals
    if (borderXMin && borderZMin) affectedChunkIds.add(getChunkId(cx - 1, cz - 1));
    if (borderXMin && borderZMax) affectedChunkIds.add(getChunkId(cx - 1, cz + 1));
    if (borderXMax && borderZMin) affectedChunkIds.add(getChunkId(cx + 1, cz - 1));
    if (borderXMax && borderZMax) affectedChunkIds.add(getChunkId(cx + 1, cz + 1));


    // 3. Tell the worker which chunks to remesh (Keep this)
    socket.emit('remeshChunks', Array.from(affectedChunkIds));

    // REMOVE: worker.postMessage(['updateWorld', world]); // <<< REMOVE THIS
}
      function getChunk(x, y, z) {
        const cx = Math.floor(x / CHUNK_SIZE);
        const cz = Math.floor(z / CHUNK_SIZE);
        return chunks.get(`${cx}_${cz}`);
      }

      function removeBlockAt(x, y, z) {
    const blockKey = getBlockKey(x, y, z);
    const blockData = getBlock(x, y, z); // Use the getter function
    
    if (!blockData) return false;

    // This special check now correctly belongs ONLY in collisionTick, not here.
    // Breaking a landmine should drop it as an item.
    // if (blockData.type === 'landmine') { ... }

    const blockType = blockData.type;
    let dropType = blockType;
    if (blockType === 'stone') {
        dropType = 'cobblestone';
    } else if (blockType === 'grass') {
        dropType = 'dirt';
    }
    else if(blockType === 'leaves') {
      if(Math.random() < 0.1) {
        dropType = 'apple'; // 10% chance to drop an apple from leaves
      } else {
        dropType = null;
      }
    }

    let canHarvest = false;
    const breakProps = breakInfo[blockType];
    const requiredToolCategory = breakProps ? breakProps.tool : 'any';

    if (!requiredToolCategory || requiredToolCategory === 'any') {
        canHarvest = true;
    } else {
        const selectedItem = hotbar[selectedHotbarSlot];
        const heldItemType = selectedItem ? selectedItem.type : null;
        const heldToolCategory = toolTypes[heldItemType];
        if (heldToolCategory === requiredToolCategory) {
            canHarvest = true;
        }
    }

    if (canHarvest && dropType) {
        createItemDrop({ x: x + 0.5, y: y + 0.5, z: z + 0.5 }, dropType);
    }
    
    // --- The Correct Synchronization Sequence ---

    // 1. Update the main thread's world state first.
    delete world[blockKey];

    // 2. Tell the worker to delete the same block from ITS world state.
    socket.emit('removeBlockWorker', { x, y, z });

    // 3. Determine all chunks that need a visual update.
    const cx = Math.floor(x / CHUNK_SIZE);
    const cz = Math.floor(z / CHUNK_SIZE);
    const affectedChunkIds = new Set([getChunkId(cx, cz)]);
    const borderXMin = x % CHUNK_SIZE === 0;
    const borderXMax = (x + 1) % CHUNK_SIZE === 0;
    const borderZMin = z % CHUNK_SIZE === 0;
    const borderZMax = (z + 1) % CHUNK_SIZE === 0;
    if (borderXMin) affectedChunkIds.add(getChunkId(cx - 1, cz));
    if (borderXMax) affectedChunkIds.add(getChunkId(cx + 1, cz));
    if (borderZMin) affectedChunkIds.add(getChunkId(cx, cz - 1));
    if (borderZMax) affectedChunkIds.add(getChunkId(cx, cz + 1));
    if (borderXMin && borderZMin) affectedChunkIds.add(getChunkId(cx - 1, cz - 1));
    if (borderXMin && borderZMax) affectedChunkIds.add(getChunkId(cx - 1, cz + 1));
    if (borderXMax && borderZMin) affectedChunkIds.add(getChunkId(cx + 1, cz - 1));
    if (borderXMax && borderZMax) affectedChunkIds.add(getChunkId(cx + 1, cz + 1));

    // 4. NOW, tell the worker to remesh the chunks using its updated data.
    socket.emit('remeshChunks', Array.from(affectedChunkIds));

    return true;
}
document.addEventListener('keydown', function (event) {
  if (event.ctrlKey && event.key === 'w') {
    event.preventDefault();
  }
});

      // --- BIOME DEFS, Biome Determination, Terrain Gen --- (Unchanged)
            // +++ START NOISE/TERRAIN GENERATION CHANGES +++

      // --- Instantiate Simplex Noise ---
      const WORLD_SEED = "012345!"; // Use a consistent seed!
      const simplex = new SimplexNoise(WORLD_SEED);

      // --- Default Fractal Noise Parameters ---
      // Can be overridden by biome settings if needed
      const FRACTAL_OCTAVES = 6;
      const FRACTAL_PERSISTENCE = 0.5;
      const FRACTAL_LACUNARITY = 2.0;

      // --- BIOME DEFS (Update parameters as needed, e.g., higher mountain base/amplitude) ---
      const BiomeType = { Plains: 0, Forest: 1, Mountain: 2, River: 3 };
      const biomeParameters = {
        [BiomeType.Plains]: {
        name: "Plains",
        baseHeight: 1,
        // Parameters for the base, smooth terrain of the plains
        terrainAmplitude: 3,     // Lower amplitude for smoother base
        terrainScale: 0.06,      // Larger scale for very gentle base variations
        terrainOctaves: 3,         // Fewer octaves for smoother base
        terrainPersistence: 0.45,  // Lower persistence for smoother base

        // Parameters for the large, rolling hills on top
        hillAmplitude: 15,       // How tall the big hills can be (added to baseHeight + base terrain)
        hillScale: 0.008,        // Much smaller scale for very large, broad hills
        hillOctaves: 4,          // A few octaves for some shape to the large hills
        hillPersistence: 0.5,

        // Other plains parameters (trees, surface blocks, etc.)
        treeDensity: 0.005, treeHeightMin: 3, treeHeightMax: 5, // Adjust as needed
        surfaceBlock: "grass", underSurfaceBlock: "dirt", dirtDepth: 3,
        stoneLevelModifier: -10, plainsForestPatchChance: 0.03, plainsForestPatchDensity: 0.05,
    },
        [BiomeType.Forest]: {
          name: "Forest", baseHeight: 3, terrainAmplitude: 4, terrainScale: 0.03,
          treeDensity: 0.04, treeHeightMin: 4, treeHeightMax: 7,
          surfaceBlock: "grass", underSurfaceBlock: "dirt", dirtDepth: 4,
          stoneLevelModifier: -8,
          terrainOctaves: 1
        },
        [BiomeType.Mountain]: {
          name: "Mountain", baseHeight: 3, // Higher base for mountains
          terrainAmplitude: 30, // Increased amplitude for mountains
          terrainScale: 0.02, // Slightly larger features for mountains
          treeDensity: 0.005, treeHeightMin: 3, treeHeightMax: 5,
          surfaceBlock: "grass", // Mountains often start with stone
          underSurfaceBlock: "stone", dirtDepth: 3, stoneLevelModifier: 0,
          snowLevel: 55, // Snow line
          terrainOctaves: 2, // More detail for mountains
          terrainPersistence: 0.55, // More ruggedness
          terrainLacunarity: 2.1, // Slightly faster detail increase
          roughnessAmplitude: 1, // More roughness for mountains
        },
        [BiomeType.River]: {
          name: "River", baseHeight: 1, terrainAmplitude: 3, terrainScale: 0.04,
          treeDensity: 0.003, treeHeightMin: 3, treeHeightMax: 5,
          surfaceBlock: "water", underSurfaceBlock: "dirt", dirtDepth: 3,
          stoneLevelModifier: -10, plainsForestPatchChance: 0.03, plainsForestPatchDensity: 0.05,
          // Optional: Override fractal params for this biome's heightmap if desired
          terrainOctaves: 0.2, terrainPersistence: 0.45,
        },
      };

      // --- Biome Determination (UPDATED) ---
      const biomeNoiseScale = 0.0025;
      const biomeOctaves = 4; // Fewer octaves for broad biome map
      const biomePersistence = 0.5;
      const biomeLacunarity = 2.0;
      const forestThreshold = 0.4; // Thresholds remain in [0, 1] range
      const mountainThreshold = 0.5; // Thresholds remain in [0, 1] range

            // --- START: ADD Cave/River Noise Parameters ---
            const CAVE_SEED_OFFSET = 10000; // Use different offsets for different noise types
      const RIVER_SEED_OFFSET = 20000;

      // Cave Settings
      const caveNoiseScale = 0.06;   // Controls the size/frequency of cave systems
      const caveThreshold = 0.65;  // Noise value > threshold = air. Higher = smaller/rarer caves (Range 0-1)
      const minCaveY = -60;        // Deepest caves can start
      const maxCaveY = 40;         // Caves generally don't go much above this Y level

      function getBiome(worldX, worldZ) {
          const noiseValue = generateFractalNoise2D( // Use fractal noise for biomes
              simplex, // Use the simplex instance
              worldX * biomeNoiseScale,
              worldZ * biomeNoiseScale,
              biomeOctaves,
              biomePersistence,
              biomeLacunarity
          ); // Output: approx [-1, 1]

          // Normalize noise to [0, 1] range for comparison with original thresholds
          const normalizedNoise = (noiseValue + 1) / 2.0;

          if (normalizedNoise < forestThreshold) return BiomeType.Plains;
          else if (normalizedNoise > mountainThreshold) return BiomeType.Mountain;
          else return BiomeType.Forest;
      }

      function getCave(worldX, worldZ, worldY) {
         const noiseValue = generateFractalNoise3dD(
            simplex,
            worldX * biomeNoiseScale,
            worldY * biomeNoiseScale,
            worldZ * biomeNoiseScale,
            biomeOctaves,
            biomePersistence,
            biomeLacunarity
         )
        const normalizedNoise = (noiseValue + 1) / 2.0;

        if (normalizedNoise > 0.5) return true;
        else return false;
      }

            // --- START: FULL REVISED calculateTerrainInfo FUNCTION ---
            function calculateTerrainInfo(worldX, worldZ) {
        const biomeType = getBiome(worldX, worldZ);
        const params = biomeParameters[biomeType];

        // --- Base Terrain Height Calculation (Unchanged) ---
        const terrainOctaves = params.terrainOctaves || FRACTAL_OCTAVES;
        const terrainPersistence = params.terrainPersistence || FRACTAL_PERSISTENCE;
        const terrainLacunarity = params.terrainLacunarity || FRACTAL_LACUNARITY;
        const heightNoise = generateFractalNoise2D(
            simplex,
            worldX * params.terrainScale,
            worldZ * params.terrainScale,
            terrainOctaves,
            terrainPersistence,
            terrainLacunarity
        );
        const normalizedHeightNoise = (heightNoise + 1) / 2.0;
        const baseHeightValue = params.baseHeight + normalizedHeightNoise * params.terrainAmplitude;
        const roughnessAmplitude = params.roughnessAmplitude || (biomeType === BiomeType.Mountain ? 3 : 1);
        const roughnessScale = 0.1;
        const roughnessNoise = simplex.noise2D(worldX * roughnessScale, worldZ * roughnessScale);
        const terrainHeight = Math.floor(baseHeightValue + roughnessNoise * roughnessAmplitude);
        // --- End Base Terrain Height ---

        // Return all info
        return {
            height: terrainHeight, // Original calculated height
            biome: biomeType,
            params: params,
        };
      }
      // --- END: FULL REVISED calculateTerrainInfo FUNCTION ---
                  // --- START: FULL REVISED generateChunkData FUNCTION ---
      function generateChunkData(chunk) {
        const { wx: chunkStartX, wz: chunkStartZ } = chunkToWorldCoords(chunk.cx, chunk.cz);

        for (let x = 0; x < CHUNK_SIZE; x++) {
          for (let z = 0; z < CHUNK_SIZE; z++) {
            const worldX = chunkStartX + x;
            const worldZ = chunkStartZ + z;

            // 1. Get Terrain and River Info
            const terrainInfo = calculateTerrainInfo(worldX, worldZ);
            const originalSurfaceY = terrainInfo.height; // Height before river carving
            const actualSurfaceY = originalSurfaceY
            const biomeParams = terrainInfo.params;
            const biomeType = terrainInfo.biome;

                        // --- V V V ADD THIS MISSING BLOCK V V V ---
            // Ore Generation Settings (Define INSIDE generateChunkData)
            const oreNoiseScale = 0.08;   // Controls the size/frequency of ore veins
            const oreNoiseSeedOffset = 1000; // Use different noise space than terrain/caves

            // Coal Settings
            const coalThreshold = 0.85;  // Noise value > threshold = ore. Higher = rarer. (Range 0-1)
            const coalMinY = 0;
            const coalMaxY = 128;         // Coal spawns up high

            // Iron Settings
            const ironThreshold = 0.95;   // Iron is a bit rarer (higher threshold)
            const ironMinY = -60;        // Starts appearing in deepslate range
            const ironMaxY = 70;         // Can appear just above sea level
            const ironPeakY = 16;        // Most common around Y=16
            const ironSpread = 40;       // How far from the peak it remains relatively common
            // --- ^ ^ ^ ADD THIS MISSING BLOCK ^ ^ ^ ---

            // 3. Ore Generation (AFTER main terrain/caves, BEFORE trees)
            // ... (rest of the ore generation loop follows) ...

            // Calculate stone level based on the *original* surface height
            const stoneStartY = originalSurfaceY - biomeParams.dirtDepth + biomeParams.stoneLevelModifier;

            // 2. Vertical Block Placement Loop (Bottom-up)
            const minYGen = -64; // Define a hard minimum generation depth
            for (let y = minYGen; y <= actualSurfaceY; y++) {
                // Skip if a block somehow already exists
                if (hasBlock(worldX, y, worldZ)) continue;

                // --- CAVE CHECK ---
                let isCaveAir = false;
                // Only check for caves within the potential solid ground range
                if (y >= minCaveY && y < actualSurfaceY && y <= maxCaveY) {
                    // Use a different noise space for caves
                    const caveNoiseValue = simplex.noise3D(
                        (worldX + CAVE_SEED_OFFSET) * caveNoiseScale,
                        (y + CAVE_SEED_OFFSET) * caveNoiseScale,
                        (worldZ + CAVE_SEED_OFFSET) * caveNoiseScale
                    );
                    const normalizedCaveNoise = (caveNoiseValue + 1) / 2.0;

                    if (normalizedCaveNoise > caveThreshold) {
                        isCaveAir = true; // Carve out this block
                    }
                }
                // If it's cave air, skip placing any solid block
                if (isCaveAir) {
                    continue; // Go to next Y level
                }
                // --- END CAVE CHECK ---


                // --- Determine Block Type (if not cave air) ---
                let blockType = 'stone'; // Default to stone

              // Check if it's the surface layer
              if (y === actualSurfaceY) {
                  // Determine standard surface block (including snow check)
                  blockType = (biomeType === BiomeType.Mountain && y >= biomeParams.snowLevel)
                      ? 'stone' // Snow level overrides surface (replace with 'snow' later?)
                      : biomeParams.surfaceBlock; // Standard surface (e.g., grass)
              }
              // Check if above the main stone layer (but not surface)
              else if (y > stoneStartY) { // Keep this part
                  blockType = biomeParams.underSurfaceBlock; // E.g., dirt
              }
              else if(y === 11 && !hasBlock(worldX, 12, worldZ)){
                blockType = 'water'
              } 
              // Otherwise, it remains 'stone' // Keep this part

                // Place the determined block
                internalAddBlock(worldX, y, worldZ, blockType);

            } // --- End Y loop ---


            // 3. Ore Generation (AFTER main terrain/caves, BEFORE trees)
            // Needs to iterate again and check the *actually placed* blocks
            const oreCheckMinY = Math.min(minCaveY, -64);
            const oreCheckMaxY = actualSurfaceY; // Check up to the actual placed surface

            // Separate orePlaced flag for this column to allow both ore types if lucky
            let coalOrePlacedInColumn = false;
            let ironOrePlacedInColumn = false;

            for (let y = oreCheckMinY; y <= oreCheckMaxY; y++) {
              const blockKey = getBlockKey(worldX, y, worldZ);
              const currentBlock = world[blockKey]; // Get the block placed in step 2

              // Only replace stone blocks
              if (currentBlock && currentBlock.type === 'stone') {

                  // Try Placing Coal
                  if (!coalOrePlacedInColumn && y >= coalMinY && y <= coalMaxY) {
                      const coalNoiseVal = simplex.noise3D(
                          (worldX + oreNoiseSeedOffset) * oreNoiseScale,
                          (y + oreNoiseSeedOffset) * oreNoiseScale,
                          (worldZ + oreNoiseSeedOffset) * oreNoiseScale
                      );
                      const normalizedCoalNoise = (coalNoiseVal + 1) / 2.0;

                      if (normalizedCoalNoise > coalThreshold) {
                          let isExposed = false;
                          const neighbors = [ { dx: 1, dy: 0, dz: 0 }, { dx: -1, dy: 0, dz: 0 }, { dx: 0, dy: 1, dz: 0 }, { dx: 0, dy: -1, dz: 0 }, { dx: 0, dy: 0, dz: 1 }, { dx: 0, dy: 0, dz: -1 }];
                          for (const n of neighbors) { if (!hasBlock(worldX + n.dx, y + n.dy, worldZ + n.dz)) { isExposed = true; break; } }

                          let placeThisOre = true;
                          if (isExposed && Math.random() >= 0.5) { placeThisOre = false; }

                          if (placeThisOre) {
                              internalAddBlock(worldX, y, worldZ, 'coal_ore', true);
                              coalOrePlacedInColumn = true; // Mark coal as placed in this block
                               continue; // Skip checking for iron in the same block where coal was just placed
                          }
                      }
                  }

                 // Try Placing Iron (only if coal wasn't placed in this exact block)
                 if (!ironOrePlacedInColumn && y >= ironMinY && y <= ironMaxY) {
                     const distFromPeak = Math.abs(y - ironPeakY);
                     const normalizedDist = Math.min(1.0, distFromPeak / ironSpread);
                     const currentIronThreshold = ironThreshold + normalizedDist * (1.0 - ironThreshold);

                     const ironNoiseVal = simplex.noise3D(
                         (worldX - oreNoiseSeedOffset) * oreNoiseScale * 1.1,
                         (y - oreNoiseSeedOffset) * oreNoiseScale * 1.1,
                         (worldZ - oreNoiseSeedOffset) * oreNoiseScale * 1.1
                     );
                     const normalizedIronNoise = (ironNoiseVal + 1) / 2.0;

                     if (normalizedIronNoise > currentIronThreshold) {
                         let isExposed = false;
                         const neighbors = [ { dx: 1, dy: 0, dz: 0 }, { dx: -1, dy: 0, dz: 0 }, { dx: 0, dy: 1, dz: 0 }, { dx: 0, dy: -1, dz: 0 }, { dx: 0, dy: 0, dz: 1 }, { dx: 0, dy: 0, dz: -1 }];
                         for (const n of neighbors) { if (!hasBlock(worldX + n.dx, y + n.dy, worldZ + n.dz)) { isExposed = true; break; } }

                         let placeThisOre = true;
                         if (isExposed && Math.random() >= 0.5) { placeThisOre = false; }

                         if (placeThisOre) {
                             internalAddBlock(worldX, y, worldZ, 'oxidized_iron_ore', true);
                             ironOrePlacedInColumn = true; // Mark iron as placed in this block
                         }
                     }
                 } // End Iron Check

              } // End if block is stone
            } // --- End Ore Check Y loop ---


            // 4. Tree Generation
            const surfaceBlockData = getBlock(worldX, actualSurfaceY, worldZ);
            const surfaceBlockType = surfaceBlockData ? surfaceBlockData.type : null;

            // Check conditions: Not in a river, surface block is suitable, below snow line
            console.log(surfaceBlockType)
            if (
                (surfaceBlockType === biomeParams.surfaceBlock || surfaceBlockType === 'dirt' || surfaceBlockType === 'grass_block' ) && // Allow on dirt too?
                actualSurfaceY < (biomeParams.snowLevel ?? Infinity))
            {
                 // Determine tree chance based on biome
                 let treeDensity = 0;
                 let treeHeightMin = 4; // Default values
                 let treeHeightMax = 6;

                 if (biomeType === BiomeType.Forest) {
                     treeDensity = biomeParams.treeDensity;
                     treeHeightMin = biomeParams.treeHeightMin;
                     treeHeightMax = biomeParams.treeHeightMax;
                 } else if (biomeType === BiomeType.Plains) {
                    // Plains specific logic (e.g., patches or lower density)
                    if (Math.random() < biomeParams.plainsForestPatchChance) {
                       treeDensity = biomeParams.plainsForestPatchDensity || biomeParameters[BiomeType.Forest].treeDensity; // Patch density or fallback
                       treeHeightMin = biomeParameters[BiomeType.Forest].treeHeightMin;
                       treeHeightMax = biomeParameters[BiomeType.Forest].treeHeightMax;
                    } else {
                       treeDensity = biomeParams.treeDensity; // Base plains density
                       treeHeightMin = biomeParams.treeHeightMin;
                       treeHeightMax = biomeParams.treeHeightMax;
                    }
                 } else if (biomeType === BiomeType.Mountain) {
                     treeDensity = biomeParams.treeDensity;
                     treeHeightMin = biomeParams.treeHeightMin;
                     treeHeightMax = biomeParams.treeHeightMax;
                 }

                 // Roll the dice for tree placement
                 if (Math.random() < treeDensity) {
                    // Check slope using original terrain height for stability
                    const heightNorth = calculateTerrainInfo(worldX, worldZ + 1).height;
                    const heightSouth = calculateTerrainInfo(worldX, worldZ - 1).height;
                    const heightEast = calculateTerrainInfo(worldX + 1, worldZ).height;
                    const heightWest = calculateTerrainInfo(worldX - 1, worldZ).height;
                    const maxSlope = Math.max(
                        Math.abs(originalSurfaceY - heightNorth), Math.abs(originalSurfaceY - heightSouth),
                        Math.abs(originalSurfaceY - heightEast), Math.abs(originalSurfaceY - heightWest)
                    );
                    // Place tree if slope is gentle enough (adjust slope limit as needed)
                        const treeHeight = Math.floor(Math.random() * (treeHeightMax - treeHeightMin + 1)) + treeHeightMin;
                        try{
                        generateTreeStructure(worldX, actualSurfaceY + 1, worldZ, treeHeight);
                        console.log("Tree placed at", worldX, actualSurfaceY + 1, worldZ);
                        }
                        catch(e){
                            console.error("Error placing tree:", e);
                        }
                 }
                 console.log("triggered?")
            } // --- End Tree Check ---

          } // End Z loop
        } // End X loop
        console.log("world updated!")
        chunk.state = ChunkState.DataLoaded;
        console.log("triggered")
      }
      // --- END: FULL REVISED generateChunkData FUNCTION ---
      function generateTreeStructure(rX, rY, rZ, h) {
        for (let i = 0; i < h; i++) {
          internalAddBlock(rX, rY + i, rZ, "log");
        }
        const lR = 2;
        const tTY = rY + h - 1;
        for (let ly = tTY - 1; ly <= tTY + 1; ly++) {
          for (let lx = -lR; lx <= lR; lx++) {
            for (let lz = -lR; lz <= lR; lz++) {
              const bX = rX + lx;
              const bY = ly;
              const bZ = rZ + lz;
              const dSq =
                lx * lx + (bY - (tTY + 0.5)) * (bY - (tTY + 0.5)) + lz * lz;
              if (dSq > (lR + 0.5) * (lR + 0.5)) continue;
              if (bX === rX && bZ === rZ && bY <= tTY) continue;
              if (!hasSolidBlock(bX, bY, bZ)) {
                internalAddBlock(bX, bY, bZ, "leaves");
              }
            }
          }
        }
        if (!hasSolidBlock(rX, tTY + 2, rZ)) {
          internalAddBlock(rX, tTY + 2, rZ, "leaves");
        }
      }

      // !!! THIS FUNCTION IS N-O-T HUMAN-WRITTEN!
      // It was refined by me because Gemini made the variable names too hard to read! E.g ("mD")
      function markChunkForRemesh(cx, cz, checkNeighbors = false) {
        const cId = getChunkId(cx, cz);
        const ch = chunks.get(cId);
        if (
          ch &&
          (ch.state === ChunkState.Active || ch.state === ChunkState.Inactive)
        ) {
          ch.state = ChunkState.NeedsRemesh;
          chunksNeedUpdate = true;
          socket.emit("chunksNeedUpdate", chunksNeedUpdate);
        }
        if (checkNeighbors) {
          markChunkForRemesh(cx + 1, cz);
          markChunkForRemesh(cx - 1, cz);
          markChunkForRemesh(cx, cz + 1);
          markChunkForRemesh(cx, cz - 1);
        }
      }
      function getChunkId(chunkX, chunkZ) {
    return `${chunkX}_${chunkZ}`;
  }

  function removeChunkBlocksFromClientMemory(chunk) {
    if (!chunk) return;
    const { wx: chunkStartX, wz: chunkStartZ } = chunkToWorldCoords(chunk.cx, chunk.cz);
    const minYGen = -64;
    const maxYGen = 128;

    for (let x = 0; x < CHUNK_SIZE; x++) {
        for (let z = 0; z < CHUNK_SIZE; z++) {
            for (let y = minYGen; y <= maxYGen; y++) {
                const blockKey = getBlockKey(chunkStartX + x, y, chunkStartZ + z);
                if (world[blockKey]) {
                    delete world[blockKey];
                }
            }
        }
    }
}
      function updateChunks() {
        if (!chunksNeedUpdate) return;
        chunksNeedUpdate = false;
        const { cx: pCX, cz: pCZ } = worldToChunkCoords(
          camera.position.x,
          camera.position.z
        );
        const desired = new Set();
        for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
          for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
            const tCX = pCX + dx;
            const tCZ = pCZ + dz;
            const cId = getChunkId(tCX, tCZ);
            desired.add(cId);
            let ch = chunks.get(cId);
            if (!ch) {
              ch = {
                id: cId,
                cx: tCX,
                cz: tCZ,
                state: ChunkState.Unknown,
              };
              chunks.set(cId, ch);
            }
            if (ch.state === ChunkState.Unknown) {
              ch.state = ChunkState.LoadingData;
              setTimeout(() => {
                //generateChunkData(ch);
                if(cId % 2 == 0){
                worker.postMessage(["generateChunkData", ch]);
                }
                chunksNeedUpdate = true;
              }, 0);
            } else if (
              ch.state === ChunkState.DataLoaded ||
              ch.state === ChunkState.NeedsRemesh
            ) {
              try {
                if(cId % 2 == 0){
                worker.postMessage({type:"meshChunk", chunk:ch})
                }
                console.log(`Meshing chunk ${cId}...`);
              }
              catch (e) {
                console.error(`Error meshing chunk ${cId}:`, e);
                ch.state = ChunkState.DataLoaded; // Reset state to avoid infinite loop
              }
            } else if (ch.state === ChunkState.Inactive) {
              ch.state = ChunkState.NeedsRemesh;
              chunksNeedUpdate = true;
            }
          }
        }
        console.log(`Chunks updated`);
        chunks.forEach((ch, cId) => {
          if (!desired.has(cId) && ch.state === ChunkState.Active) {
            console.log(`Unloading chunk ${cId}`);
            disposeChunkMeshes(ch);
            ch.state = ChunkState.Inactive;
          }
        });
      }
      function addBlockInstanceFace(chunk, x, y, z, blockType, faceName) {
const geo = faceGeometries[faceName];
const material = getMaterialForBlockFace(blockType, faceName);
if (!material || !geo) return;
const meshData = getChunkInstancedMesh(chunk, material, geo, faceName);
if (!meshData) return;
if (meshData.count < MAX_INSTANCES_PER_GEOMETRY_PER_CHUNK) {
  dummy.position.set(x + 0.5, y + 0.5, z + 0.5);
  dummy.updateMatrix();
  meshData.mesh.setMatrixAt(meshData.count, dummy.matrix);
  meshData.count++;
} else {
  console.warn(`Max instances reached for ${meshData.mesh.name}`);
}
}
function getChunkInstancedMesh(chunk, material, faceGeometry, faceName) {
if (!chunk || !material || !faceGeometry || !faceName) {
  console.error("Missing parameters for getChunkInstancedMesh");
  return null;
}
if (!chunk.meshes) {
  chunk.meshes = new Map();
}
const key = `${faceName}_${material.uuid}`;
let meshData = chunk.meshes.get(key);
if (!meshData) {
  const mesh = new THREE.InstancedMesh(
    faceGeometry,
    material,
    MAX_INSTANCES_PER_GEOMETRY_PER_CHUNK
  );
  mesh.count = 0;
  mesh.name = `chunk_${chunk.id}_mesh_${key}`;
  meshData = { mesh: mesh, count: 0 };
  chunk.meshes.set(key, meshData);
}
return meshData;
}
function getMaterialForBlockFace(blockType, faceName) {
const m = materials[blockType];
if (!m) {
  console.warn(
    `No material found for block type: ${blockType}, using dirt.`
  );
  return materials.dirt.all;
}
if (m.all) return m.all;
switch (faceName) {
  case "top":
    return m.top || m.side || m.all;
  case "bottom":
    return m.bottom || m.side || m.all;
  default:
    return m.side || m.top || m.all;
}
}
function disposeChunkMeshes(chunk) {
if (chunk.meshes) {
  chunk.meshes.forEach((mD) => {
    scene.remove(
      mD.mesh
    );
  });
  chunk.meshes.clear();
}
}
      function meshChunk(chunk) {
    chunk.state = ChunkState.Meshing;
    disposeChunkMeshes(chunk);
    chunk.meshes = new Map();
    const { wx: sX, wz: sZ } = chunkToWorldCoords(chunk.cx, chunk.cz);
    let facesAdded = 0;
    const faces = [
      { face: "right",  dx: 1,  dy: 0,  dz: 0 },
      { face: "left",   dx: -1, dy: 0,  dz: 0 },
      { face: "top",    dx: 0,  dy: 1,  dz: 0 },
      { face: "bottom", dx: 0,  dy: -1, dz: 0 },
      { face: "front",  dx: 0,  dy: 0,  dz: 1 },
      { face: "back",   dx: 0,  dy: 0,  dz: -1 },
    ];
    const minBY = -38;
    const maxBY = 60;
    for (let x = 0; x < CHUNK_SIZE; x++) {
      for (let z = 0; z < CHUNK_SIZE; z++) {
        for (let y = minBY; y < maxBY; y++) {
          const blockCoordX = sX + x;
          const blockCoordY = y;
          const blockCoordZ = sZ + z;
          const bedrockLayer = minBY - 1;
          const bD = getBlock(blockCoordX, blockCoordY, blockCoordZ);
          if (bD) {
            faces.forEach((faceDirection) => {
              const nX = blockCoordX + faceDirection.dx;
              const nY = blockCoordY + faceDirection.dy;
              const nZ = blockCoordZ + faceDirection.dz;
              const nB = getBlock(nX, nY, nZ);
              const nIsT = !nB
              if (nIsT) {
                addBlockInstanceFace(chunk, blockCoordX, blockCoordY, blockCoordZ, bD.type, faceDirection.face);
                facesAdded++;
              }
              if (y === bedrockLayer) {
                addBlockInstanceFace(chunk, blockCoordX, blockCoordY, blockCoordZ, "bedrock", faceDirection.face);
                facesAdded++;
              }
            });
          }
        }
      }
    }
    const group = new THREE.Group();
    group.name = `chunk_${chunk.id}_group`;
    chunk.meshes.forEach((mD) => {
      if (mD.count > 0) {
        mD.mesh.count = mD.count;
        mD.mesh.instanceMatrix.needsUpdate = true;
        scene.add(mD.mesh);
    }
    })
    chunk.state = ChunkState.Active;
  }
  // --- Add this new function in overworld.html ---
function updatePlayerStance() {
    const isSneaking = keys.shift; // Check if shift key is pressed

    if (isSneaking) {
        currentPlayerHeight = PLAYER_SNEAKING_HEIGHT;
        currentPlayerEyeLevelOffset = PLAYER_SNEAKING_EYE_LEVEL_OFFSET;
        currentPlayerCollisionHeight = PLAYER_SNEAKING_COLLISION_HEIGHT;
    } else {
        currentPlayerHeight = PLAYER_STANDING_HEIGHT;
        currentPlayerEyeLevelOffset = PLAYER_STANDING_EYE_LEVEL_OFFSET;
        currentPlayerCollisionHeight = PLAYER_STANDING_COLLISION_HEIGHT;
    }

    // Recalculate derived collision offsets based on current eye level and collision height
    // The camera's Y position is the eye level. The "feet" are below it.
    playerFeetOffset = -currentPlayerEyeLevelOffset; // This is not directly used if camera.y *is* eye level
                                                    // More conceptual: if camera.y was base and we added eye level.
                                                    // For now, let's assume camera.position.y IS the eye level.

    // Collision hitbox is defined relative to the *feet* of the player.
    // If camera.position.y is the eye level, then:
    // Feet Y = camera.position.y - currentPlayerEyeLevelOffset
    // Collision Bottom Y (relative to feet) = 0
    // Collision Top Y (relative to feet) = currentPlayerCollisionHeight

    // For collisionTick, we need offsets relative to the current camera.position.y (eye level)
    playerCollisionBottomOffset = -currentPlayerEyeLevelOffset; // Distance from eye level down to feet
    playerCollisionTopOffset = currentPlayerCollisionHeight - currentPlayerEyeLevelOffset; // Distance from eye level up to top of collision box
                                                                                        // (or feet_y + coll_height) - eye_level_y

    // Adjust camera position if transitioning between standing and sneaking
    // This needs to be handled carefully to avoid clipping into floor/ceiling.
    // Let's handle this in the main loop (animate) when the stance *changes*.
}
  // --- In overworld.html ---

function collisionTick() {
    const originalPlayerCameraY = camera.position.y; // Store initial Y for comparison if needed

    // --- Apply Gravity and Track Fall Distance ---
    let verticalMovementAppliedThisFrame = verticalVelocity; // How much we *intend* to move vertically this frame

    // If player was not on ground and is currently moving downwards (or just started moving downwards)
    if (!wasOnGround && verticalVelocity <= 0) {
        // fallDistance is accumulated based on how much the player *actually* falls each frame due to gravity
        // after collision resolution. A simpler way is to accumulate raw vertical velocity,
        // but it can be slightly off. Let's use a flag and reset on ground.
        // A more direct accumulation happens based on velocity before collision.
        fallDistance += Math.abs(verticalMovementAppliedThisFrame); // Accumulate potential fall
    }

    verticalVelocity -= gravity; // Apply gravity to velocity for next frame
    camera.position.y += verticalVelocity; // Apply new velocity to camera for this frame's checks

    let newIsOnGroundThisFrame = false; // Will be set true if collision with ground is detected

    // --- Player's Current Position and Collision Box ---
    let currentCamX = camera.position.x;
    let currentCamY = camera.position.y; // This is the current eye level after gravity
    let currentCamZ = camera.position.z;

    // Calculate player's collision box boundaries in world space using dynamic stance properties
    // Feet Y position in world = current eye level - current eye level offset from feet
    const playerFeetWorldY = currentCamY - currentPlayerEyeLevelOffset;
    const playerCollisionBoxMinY_world = playerFeetWorldY; // Bottom of collision box is at feet
    const playerCollisionBoxMaxY_world = playerFeetWorldY + currentPlayerCollisionHeight; // Top of collision box

    const playerCollisionBoxMinX_world = currentCamX - PLAYER_WIDTH / 2;
    const playerCollisionBoxMaxX_world = currentCamX + PLAYER_WIDTH / 2;
    const playerCollisionBoxMinZ_world = currentCamZ - PLAYER_WIDTH / 2;
    const playerCollisionBoxMaxZ_world = currentCamZ + PLAYER_WIDTH / 2;

    // --- Define Search Area for Collidable Blocks ---
    const collisionCheckRadius = 1.5; // How far around the player to check
    const minBlockXToCheck = Math.floor(playerCollisionBoxMinX_world - collisionCheckRadius);
    const maxBlockXToCheck = Math.ceil(playerCollisionBoxMaxX_world + collisionCheckRadius);
    const minBlockYToCheck = Math.floor(playerCollisionBoxMinY_world - collisionCheckRadius);
    const maxBlockYToCheck = Math.ceil(playerCollisionBoxMaxY_world + collisionCheckRadius);
    const minBlockZToCheck = Math.floor(playerCollisionBoxMinZ_world - collisionCheckRadius);
    const maxBlockZToCheck = Math.ceil(playerCollisionBoxMaxZ_world + collisionCheckRadius);

    // --- Iterate Through Nearby Blocks for Collision ---
    for (let bX = minBlockXToCheck; bX <= maxBlockXToCheck; bX++) {
        for (let bY = minBlockYToCheck; bY <= maxBlockYToCheck; bY++) {
            for (let bZ = minBlockZToCheck; bZ <= maxBlockZToCheck; bZ++) {
                if (!hasSolidBlock(bX, bY, bZ)) { // Query your world data
                    continue;
                }

                // Block boundaries in world space
                const blockMinX = bX;
                const blockMaxX = bX + 1;
                const blockMinY = bY;
                const blockMaxY = bY + 1;
                const blockMinZ = bZ;
                const blockMaxZ = bZ + 1;

                // AABB Collision Check: Player's collision box vs. current block's box
                if (
                    playerCollisionBoxMaxX_world > blockMinX && playerCollisionBoxMinX_world < blockMaxX &&
                    playerCollisionBoxMaxY_world > blockMinY && playerCollisionBoxMinY_world < blockMaxY &&
                    playerCollisionBoxMaxZ_world > blockMinZ && playerCollisionBoxMinZ_world < blockMaxZ
                ) {

                const block = getBlock(bX, bY, bZ);
                if (block && block.type === 'landmine') {
                    triggerExplosion(bX, bY, bZ);
                    return;
                }


                    // --- Collision Detected - Calculate Response ---
                    // Center of player's collision box
                    const playerCollisionCenterX = currentCamX;
                    const playerCollisionCenterY = playerFeetWorldY + (currentPlayerCollisionHeight / 2);
                    const playerCollisionCenterZ = currentCamZ;

                    // Center of the block
                    const blockCenterX = bX + 0.5;
                    const blockCenterY = bY + 0.5;
                    const blockCenterZ = bZ + 0.5;

                    // Calculate penetration depths on each axis
                    const deltaX = playerCollisionCenterX - blockCenterX;
                    const deltaY = playerCollisionCenterY - blockCenterY;
                    const deltaZ = playerCollisionCenterZ - blockCenterZ;

                    const overlapX = (PLAYER_WIDTH / 2 + 0.5) - Math.abs(deltaX);
                    const overlapY = (currentPlayerCollisionHeight / 2 + 0.5) - Math.abs(deltaY);
                    const overlapZ = (PLAYER_WIDTH / 2 + 0.5) - Math.abs(deltaZ);

                    // Resolve collision by pushing player out along the axis of smallest overlap
                    if (overlapY < overlapX && overlapY < overlapZ) { // Vertical collision resolution
                        if (deltaY > 0 && verticalVelocity <= 0) { // Player landed on top of the block
                            // Check if was falling (not just standing on ground already)
                            if (!wasOnGround && world[getBlockKey(bX, bY + 1, bZ)]?.type !== "water") {
                                if (fallDistance > 3.0) {
                                    const damage = Math.floor(fallDistance - 3.0);
                                    if (damage > 0) {
                                        // console.log(`Landed. Fall distance: ${fallDistance.toFixed(2)}, Damage: ${damage}`);
                                        applyDamage(damage, "fall");
                                    }
                                }
                            }
                            else if(world[getBlockKey(bX, bY + 1, bZ)]?.type === "water"){
                                fallDistance = 0;
                            }
                            fallDistance = 0; // Reset fall distance on any landing
                            newIsOnGroundThisFrame = true; // Player is now on ground
                            verticalVelocity = 0; // Stop vertical movement

                            // Adjust camera Y so player's FEET are exactly on top of the block's surface (blockMaxY)
                            // Camera Y (eye level) = feet Y + current eye level offset
                            camera.position.y = blockMaxY + currentPlayerEyeLevelOffset;

                        } else if (deltaY <= 0) { // Player hit their head on the underside of a block
                            if (verticalVelocity > 0) { // Only if moving upwards
                                verticalVelocity = 0; // Stop upward movement
                            }
                            // Adjust camera Y so player's COLLISION TOP is at the bottom of the block (blockMinY)
                            // Camera Y (eye level) = (feet Y + collision height) - eye level offset from feet
                            // Feet Y = blockMinY - collision height
                            // Camera Y = (blockMinY - collision height) + eye level offset
                            camera.position.y = (blockMinY - currentPlayerCollisionHeight) + currentPlayerEyeLevelOffset;
                            // fallDistance = 0; // Optional: Reset fall distance if head bonk
                        }
                        currentCamY = camera.position.y; // Update currentCamY for next potential collision in this tick
                        // Recalculate Y bounds based on new camera position for this tick
                        // playerFeetWorldY = currentCamY - currentPlayerEyeLevelOffset;
                        // playerCollisionBoxMinY_world = playerFeetWorldY;
                        // playerCollisionBoxMaxY_world = playerFeetWorldY + currentPlayerCollisionHeight;

                    } else if (overlapX < overlapZ) { // Horizontal X-axis collision resolution
                        camera.position.x += (deltaX > 0 ? overlapX : -overlapX);
                        currentCamX = camera.position.x;
                        playerVelocity.x = 0;
                        // If player was moving into the wall, stop their X velocity
                        if ((playerVelocity.x > 0 && deltaX < 0) || (playerVelocity.x < 0 && deltaX > 0)) {
                            playerVelocity.x = 0;
                        }
                    } else { // Horizontal Z-axis collision resolution
                        camera.position.z += (deltaZ > 0 ? overlapZ : -overlapZ);
                        currentCamZ = camera.position.z;
                        playerVelocity.z = 0;
                        // If player was moving into the wall, stop their Z velocity
                        if ((playerVelocity.z > 0 && deltaZ < 0) || (playerVelocity.z < 0 && deltaZ > 0)) {
                            playerVelocity.z = 0;
                        }
                    }
                } // End if AABB collision detected
            } // End bZ loop
        } // End bY loop
    } // End bX loop

    isOnGround = newIsOnGroundThisFrame; // Set the global isOnGround status

    // After all collision checks, if player is NOT on the ground and WAS on the ground last frame (just started falling)
    if (!isOnGround && wasOnGround) {
        // This catches walking off ledges. Jumping resets fallDistance in updateCameraPosition.
        if (verticalVelocity <=0) { // Ensure actually falling, not in upward arc of a jump from an edge
            fallDistance = 0; // Reset fall distance when starting a new fall (not from jump)
        }
    }
    wasOnGround = isOnGround; // Update wasOnGround for the next frame's logic

    // Void death check
    if (camera.position.y < -65) { // Adjusted Y threshold for void
        // console.log("Player fell into the void.");
    }
    //entities
    for(let mob in mobs){

    }
}

// --- Add Helper Function for Applying Damage ---
let immune = true;
let justLogOn = true;
//get when pointer lock is called
document.addEventListener("pointerlockchange", () => {
  if(justLogOn){
    justLogOn = false;
    setTimeout(() => {
      immune = false;
    }, 3000)
  }
});
const fallDamageSound = new Audio("minecraft-fall-damage.mp3");
function applyDamage(amount, source = "unknown") {
    if(immune)return;
    console.log(immune)
    playerHealth -= amount;
    if(source === "fall") fallDamageSound.play();
    console.log(`Damage taken: ${amount} from ${source}. Health remaining: ${playerHealth}`); // Debug
    updateHealthUI(); // Update visuals
    //shake camera when damaged
    camera.rotation.x += 0.1;
    setTimeout(() => {
        camera.rotation.x -= 0.1;
    }, 100);
    // Check for death
    if (playerHealth <= 0) {
        handlePlayerDeath(source);
    }
}

// --- Add Helper Function for Death ---
function handlePlayerDeath(reason = "unknown") {
    console.log(`Player died! Reason: ${reason}. Reloading page.`);
    // Optional: Add a small delay, show a message, etc.
    // setTimeout(() => {
        window.location.reload(); // Reload the page
    // }, 1000); // 1 second delay example
}
      let tickInterval = setInterval(tick, 50); // 50ms = 20 tps
      let tps = 0;
      let triggeredTpsMeasure = false;
      let lastTickTime = performance.now();
      let timeOutInRain = 0;
      let rainFreezeDamageInterval = 20000;
      let timeStayedInRain = 0;
      let underABlock = false;
      let rainTimeOut = Math.random() * (12000 - 6000) + 6000;
      let rainTimeWait = 0;
      let weather = "clear"
      let timeAfterRainClear = Math.random() * (24000 - 12000) + 12000;
      let beaconReached = false;
      let starveInterval = 3000;

      const walkingOnGrassSound = new Audio("walking_on_grass.mp3");

      function tick() {
    const now = performance.now();
    const tickDeltaTime = now - lastTickTime; // Time since last tick in ms
    lastTickTime = now;

    // --- Day/Night Cycle ---
    time++
        if(time % 24000 === 0) {
          time = 0;
        }
        let colour = scene.background;
        colour = `${colour.r}, ${colour.g}, ${colour.b}`.split(", ").map(Number).map(c => c * 255).map(c => Math.floor(c));
        if(state === "increase") {
        directionalLight.intensity += (1 / 4000);
        ambientLight.intensity += (1 / 5000);
        if(directionalLight.intensity >= 0.7 || ambientLight.intensity >= 0.5){
          directionalLight.intensity = 0.7;
          ambientLight.intensity = 0.5;
        }
        if(time >= 6000 && time <= 18000){
          state = "decrease"
        }
        }
        else if(state === "decrease") {
        directionalLight.intensity -= (1 / 6000);
        ambientLight.intensity -= (1 / 6000);
        if(directionalLight.intensity <= 0 || ambientLight.intensity <= 0.2){
          directionalLight.intensity = 0;
          ambientLight.intensity = 0.2;
        }
        if(time >= 18000){
          state = "increase"
        }
        }


    // --- Health/Hunger Regeneration ---
    timeSinceLastRegen += tickDeltaTime; // Accumulate time since last regen check

    if (timeSinceLastRegen >= HEALTH_REGEN_INTERVAL && playerHealth < playerMaxHealth && playerHunger >= REGEN_HUNGER_THRESHOLD) {
        timeSinceLastRegen = 0; // Reset timer

        // Check conditions for regeneration
          playerHealth += 1; // Heal 1 point (half heart)
          playerHunger -= HUNGER_COST_PER_REGEN; // Decrease hunger

          // Clamp values
          playerHealth = Math.min(playerHealth, playerMaxHealth);
          playerHunger = Math.max(0, playerHunger); // Hunger shouldn't go below 0

          console.log(`Regenerated health. Health: ${playerHealth}, Hunger: ${playerHunger}`); // Debug

          // Update UI
          updateHealthUI();
          updateHungerUI();
    }
    else if(timeSinceLastRegen >= saturation_regen_interval && playerHealth < playerMaxHealth && playerHunger >= 20){
        timeSinceLastRegen = 0;
        playerHunger -= 0.25;
        playerHealth += 1;
        updateHungerUI();
        updateHealthUI();
    }

    // --- TPS Measurer (Keep your existing logic) ---
    tps++;
    if (!triggeredTpsMeasure) {
        triggeredTpsMeasure = true;
        setTimeout(() => {
            // Adjust for potential minor overshoot due to setTimeout inaccuracy
            const measuredTPS = Math.min(tps, 20); // Cap at 20
            console.log(`TPS: ${measuredTPS}`);
            tps = 0;
            triggeredTpsMeasure = false;
        }, 1000);
    }
    //sound effect (HUMAN HERE)
    if(world[getBlockKey(camera.position.x, camera.position.y - 1, camera.position.z)] && world[getBlockKey(camera.position.x, camera.position.y - 1, camera.position.z)].type === "grass_block") {
    walkingOnGrassSound.play()
    }
    if (activeFurnace && activeFurnace.inputItem && activeFurnace.fuelItem) {
        let madeProgress = false;
        // Simulate fuel burning
        if (activeFurnace.fuelBurnTime > 0) {
            activeFurnace.fuelBurnTime -= 1; // Decrease by 1 per tick, or scale by deltaTime
            madeProgress = true;
            if (activeFurnace.fuelBurnTime <= 0) {
                // Consume fuel item, find new fuel, etc.
                activeFurnace.fuelItem.count--;
                if(activeFurnace.fuelItem.count <= 0) activeFurnace.fuelItem = null;
                // TODO: Check for more fuel, reset maxFuelBurnTime
                madeProgress = true; // Ensure UI updates
            }
        } else if (activeFurnace.fuelItem) { // Try to start burning new fuel
             // activeFurnace.fuelBurnTime = getFuelValue(activeFurnace.fuelItem.type);
             // activeFurnace.maxFuelBurnTime = activeFurnace.fuelBurnTime;
             // madeProgress = true;
        }


        // Simulate smelting if fuel is burning
        if (activeFurnace.fuelBurnTime > 0 && activeFurnace.inputItem) {
            activeFurnace.smeltProgress += 1; // Increment by 1 per tick, or scale
            madeProgress = true;
            if (activeFurnace.smeltProgress >= activeFurnace.smeltTimeTotal) {
                // Smelting complete!
                // const smeltedItemType = getSmeltingResult(activeFurnace.inputItem.type);
                // activeFurnace.inputItem.count--;
                // if (activeFurnace.inputItem.count <= 0) activeFurnace.inputItem = null;
                // Add to output slot (handle stacking)
                // if (!activeFurnace.outputItem) activeFurnace.outputItem = { type: smeltedItemType, count: 0 };
                // activeFurnace.outputItem.count++;
                // activeFurnace.smeltProgress = 0; // Reset progress
                // madeProgress = true;
            }
        } else {
            // No fuel, or no input, gradually decrease smelt progress if not 0
            if (activeFurnace.smeltProgress > 0) {
                activeFurnace.smeltProgress = Math.max(0, activeFurnace.smeltProgress - 2);
                madeProgress = true;
            }
        }

        if (madeProgress) {
             updateFurnaceProgressIndicators(); // Update only progress bars
             // Or if slot items changed:
             // updateFurnaceUI(); // Redraws everything in furnace UI
        }
    }
    if (activeFurnace && isFurnaceOpen) { // Only process if a furnace is open and active
        let furnaceNeedsUIUpdate = false;

        const canSmelt = activeFurnace.inputItem && getSmeltingResult(activeFurnace.inputItem.type);
        const hasFuel = activeFurnace.fuelBurnTimeRemaining > 0;

        // 1. Consume Fuel / Start Burning New Fuel
        if (!hasFuel && canSmelt && activeFurnace.fuelItem) {
            const burnTime = getFuelBurnTime(activeFurnace.fuelItem.type);
            if (burnTime > 0) {
                activeFurnace.fuelBurnTimeRemaining = burnTime;
                activeFurnace.currentMaxFuelBurnTime = burnTime; // Store for progress bar
                activeFurnace.fuelItem.count--;
                if (activeFurnace.fuelItem.count <= 0) {
                    activeFurnace.fuelItem = null;
                }
                // console.log("Furnace: Started burning", activeFurnace.fuelItem?.type || "consumed fuel");
                furnaceNeedsUIUpdate = true;
            }
        }

        // 2. Process Smelting
        if (canSmelt && activeFurnace.fuelBurnTimeRemaining > 0) {
            activeFurnace.smeltProgress++; // Increment progress each tick
            activeFurnace.fuelBurnTimeRemaining--; // Consume fuel each tick it's smelting

            if (activeFurnace.fuelBurnTimeRemaining <= 0 && activeFurnace.fuelItem) {
                 // Just ran out of current fuel piece mid-smelt, try to consume next
                const nextBurnTime = getFuelBurnTime(activeFurnace.fuelItem.type);
                if (nextBurnTime > 0) {
                    activeFurnace.fuelBurnTimeRemaining = nextBurnTime;
                    activeFurnace.currentMaxFuelBurnTime = nextBurnTime;
                    activeFurnace.fuelItem.count--;
                    if (activeFurnace.fuelItem.count <= 0) activeFurnace.fuelItem = null;
                    // console.log("Furnace: Switched to new fuel piece while smelting");
                } else {
                     // No more fuel, stop smelting. Progress will remain.
                     activeFurnace.currentMaxFuelBurnTime = 0; // For progress bar
                }
            }
            furnaceNeedsUIUpdate = true;


            if (activeFurnace.smeltProgress >= TICKS_PER_ITEM_SMELT) {
                const resultType = getSmeltingResult(activeFurnace.inputItem.type);
                if (resultType) {
                    // Attempt to add to output slot
                    if (!activeFurnace.outputItem) {
                        activeFurnace.outputItem = { type: resultType, count: 1 };
                    } else if (activeFurnace.outputItem.type === resultType && activeFurnace.outputItem.count < getItemMaxStackSize(resultType)) {
                        activeFurnace.outputItem.count++;
                    } else {
                        // Output slot is full or has a different item, stop smelting
                        // Smelt progress will remain, waiting for output to be cleared
                        activeFurnace.smeltProgress = TICKS_PER_ITEM_SMELT -1; // Hold at nearly complete
                         // Don't consume input if output is blocked
                        // console.log("Furnace: Output slot full or incompatible for", resultType);
                        // To prevent fuel waste, you could also pause fuel consumption here
                        // activeFurnace.fuelBurnTimeRemaining++; // "Refund" this tick's fuel
                        // This is a design choice. Minecraft typically continues burning fuel.
                    }

                    // If output was successful (or partially successful)
                    if (activeFurnace.outputItem && activeFurnace.outputItem.type === resultType) {
                         activeFurnace.inputItem.count--;
                         if (activeFurnace.inputItem.count <= 0) {
                             activeFurnace.inputItem = null;
                         }
                         activeFurnace.smeltProgress = 0; // Reset for next item
                         // console.log("Furnace: Smelted 1", resultType);
                    }
                }
                furnaceNeedsUIUpdate = true;
            }
        } else {
            // Not smelting (no input, no valid recipe, or no fuel)
            // Gradually decrease progress if not actively smelting and there's no fuel
            if (activeFurnace.smeltProgress > 0 && activeFurnace.fuelBurnTimeRemaining <= 0) {
                activeFurnace.smeltProgress = Math.max(0, activeFurnace.smeltProgress - 2); // Decrease faster if interrupted
                furnaceNeedsUIUpdate = true;
            }
        }

        if (furnaceNeedsUIUpdate) {
            updateFurnaceUI(); // Redraw relevant parts or all of furnace UI
        }
    } // End if(activeFurnace)
  if(rainTimeWait >= rainTimeOut){
    rain()
    rainTimeWait = 0
    rainTimeOut = Math.random() * (12000 - 6000) + 6000
    setTimeout(() => {
      weather = "clear"
      scene.background = new THREE.Color("rgb(135, 206, 235)");
      timeAfterRainClear = Math.random() * (24000 - 12000) + 12000
    }, timeAfterRainClear);
  }
    if(timeOutInRain >= rainFreezeDamageInterval && weather === "rain" && !underABlock){
      timeOutInRain -= 3000;
      if(!immune)playerHealth -= 1
      console.log("rain damage")
      updateHealthUI()
    }
    //check if there is a block anywhere above the player's head
    for(let y = 0; y < 315 - camera.position.y; y++){
      if(hasSolidBlock(camera.position.x, camera.position.y + y, camera.position.z)){
        timeOutInRain -= 75 / 315;
        underABlock = true;
      }
      else{
        timeOutInRain += 75 / 315
        underABlock = false;
      }
  }
  rainTimeWait += 1
  if(Math.floor(camera.position.x) === beaconBeam.position.x && Math.floor(camera.position.z) === beaconBeam.position.z && !beaconReached){
    beaconBeam.visible = false;
    beaconReached = true
    alert("You have reached Level 1 Goal!")
    alert("You have gained a new Ability! Your speed is now 1.5x faster!")
    maxSpeed *= 1.5
    beaconLight.position.set(Math.floor(Math.random() * 300 - 300), -30, Math.floor(Math.random() * 300 - 300));
    beaconBeam.position.set(beaconLight.position.x, beaconLight.position.y, beaconLight.position.z);
    beaconBeam.visible = true
  }

  //check if starved.
  if(playerHunger <= 0 && starveInterval <= 0) {
    starveInterval = 3000;
    playerHealth -= 1;
    console.log("Player is starving! Health reduced by 1.");
    updateHealthUI();
    if(playerHealth <= 0) {
      handlePlayerDeath("starvation");
    }
  }
  else{
    starveInterval -= tickDeltaTime;
  }
  //reduce hunger over time
  if(playerHunger > 0) {
    playerHunger -= 0.005; // Reduce hunger slightly each tick
    updateHungerUI();
  }
  else{
    playerHunger = 0; // Clamp to 0
  }
}
  const furnaceScreenElement = document.getElementById('furnace-screen');
if (furnaceScreenElement) {
    // console.log("Attaching contextmenu listener to #furnace-screen");
    furnaceScreenElement.addEventListener('contextmenu', e => {
        // console.log("Furnace screen contextmenu event triggered, preventing default.");
        e.preventDefault(); // This is the key line
    });
    // Also ensure the 'click' listener for handleInventoryClick is attached here:
    furnaceScreenElement.addEventListener('click', handleInventoryClick);
} else {
    console.error("#furnace-screen element not found for event listeners!");
}

function rain(){
  weather = "rain"
  scene.background = new THREE.Color("rgb(55, 126, 155)")
}
      // --- Block Placement ---
      const solidBlocks = ['grass', 'dirt', 'stone', 'cobblestone', 'iron_ore', 'gold_ore', 'diamond_ore', 'log', 'leaves', 'craftingtable', 'coal_ore', 'oxidized_iron_ore', 'bedrock', 'plank', 'furnace', "landmine"];
      function handleBlockPlace() {
        // Check if any inventory screen is open or pointer isn't locked
        if (isInventoryOpen || isCraftingTableOpen || document.pointerLockElement !== renderer.domElement) {
            return;
        }

        // Perform raycast
        mouse.x = 0;
        mouse.y = 0;
        raycaster.setFromCamera(mouse, camera);
        const inter = findBlockIntersection(raycaster.ray);

        if (inter) {
          const targetBlockPos = inter.blockPos;
          const targetBlockData = getBlock(targetBlockPos.x, targetBlockPos.y, targetBlockPos.z);

          // --- Check for Crafting Table Interaction ---
          if (targetBlockData && targetBlockData.type === 'craftingtable') {
              console.log("Opening crafting table UI");
              isCraftingTableOpen = true;
              isInventoryOpen = false; // Ensure regular inventory is closed
              document.getElementById("crafting-table-screen").style.display = "flex";
              document.getElementById("full-inventory-screen").style.display = "none";
              document.body.style.cursor = "default";
              checkCraftingTableRecipe(); // Check recipe when opening
              updateInventoryUI();
              document.exitPointerLock();
              return; // Don't place a block
          }
          else if(targetBlockData && targetBlockData.type === 'furnace') {
              console.log("Opening furnace UI");
              isFurnaceOpen = true;
              isInventoryOpen = false; // Ensure regular inventory is closed
              document.getElementById("furnace-screen").style.display = "flex";
              document.getElementById("full-inventory-screen").style.display = "none";
              document.body.style.cursor = "default";
              openFurnaceUI(targetBlockPos);
              document.getElementById("hud").style.display = "none";
              updateInventoryUI();
              document.exitPointerLock();
              return; // Don't place a block
          }

          // --- Regular Block Placement ---
          const selectedItem = hotbar[selectedHotbarSlot];
          if (!selectedItem) return; // Nothing selected to place and if block is not solid
          if (solidBlocks.includes(selectedItem.type)) {
          const placePos = {
            x: inter.blockPos.x + inter.normal.x,
            y: inter.blockPos.y + inter.normal.y,
            z: inter.blockPos.z + inter.normal.z,
          };

          // --- Player Collision Check - START ---
          const plMX = camera.position.x - PLAYER_WIDTH / 2;          // Player Min X
          const plPX = camera.position.x + PLAYER_WIDTH / 2;          // Player Pos X
          const plMY = camera.position.y + playerCollisionBottomOffset; // Player Min Y (Bottom)
          const plPY = camera.position.y + playerCollisionTopOffset;   // Player Pos Y (Top)
          const plMZ = camera.position.z - PLAYER_WIDTH / 2;          // Player Min Z
          const plPZ = camera.position.z + PLAYER_WIDTH / 2;          // Player Pos Z

          // Block bounds calculation
          const bMX = placePos.x;          // Block Min X
          const bPX = placePos.x + 1;      // Block Pos X
          const bMY = placePos.y;          // Block Min Y
          const bPY = placePos.y + 1;      // Block Pos Y
          const bMZ = placePos.z;          // Block Min Z
          const bPZ = placePos.z + 1;      // Block Pos Z

          // Intersection checks using the defined variables
          const iX = plPX > bMX && plMX < bPX; // Check X overlap
          const iY = plPY > bMY && plMY < bPY; // Check Y overlap
          const iZ = plPZ > bMZ && plMZ < bPZ; // Check Z overlap

          // If player intersects the block placement position
          if (iX && iY && iZ) {
            console.log("Placement stopped: Intersects player.");
            return; // Don't place the block
          }
          // --- Player Collision Check - END ---


          // Check if space is already occupied by another solid block
          if (hasSolidBlock(placePos.x, placePos.y, placePos.z)) {
            console.log("Placement stopped: Space occupied.");
            return; // Don't place the block
          }

          // --- Place the block ---
          addBlock(placePos.x, placePos.y, placePos.z, selectedItem.type); // Add the block to the world
          selectedItem.count--; // Decrease item count in hand
          if (selectedItem.count <= 0) {
            hotbar[selectedHotbarSlot] = null; // Clear slot if count is zero
          }
          updateInventoryUI(); // Update the hotbar display
        }
        else{
          useItem(selectedItem);
        }
      }
      }

      function useItem(item) {
        switch(item.type){
          case "apple":
            if(playerHunger >= 20) return;
            playerHunger += 5;
            clearInterval(starveInterval);
            if(hotbar[selectedHotbarSlot].count <= 1){
              hotbar[selectedHotbarSlot] = null;
              updateInventoryUI()
              updateHungerUI();
              return;
            }
            hotbar[selectedHotbarSlot].count--;
            updateHungerUI();
            updateInventoryUI();
            break;
        }
      }
      // --- Find Block Intersection ---
      function findBlockIntersection(ray) {
        /* ... unchanged ... */ const step = 0.05;
        const max = 4.5;
        let dist = 0;
        const cur = new THREE.Vector3();
        const prev = new THREE.Vector3();
        prev.copy(ray.origin);
        while (dist < max) {
          cur.copy(ray.origin).add(ray.direction.clone().multiplyScalar(dist));
          const bX = Math.floor(cur.x);
          const bY = Math.floor(cur.y);
          const bZ = Math.floor(cur.z);
          if (hasBlock(bX, bY, bZ) && world[getBlockKey(bX, bY, bZ)] && world[getBlockKey(bX, bY, bZ)].solid) {
            const dx = prev.x - (bX + 0.5);
            const dy = prev.y - (bY + 0.5);
            const dz = prev.z - (bZ + 0.5);
            const aX = Math.abs(dx);
            const aY = Math.abs(dy);
            const aZ = Math.abs(dz);
            const norm = new THREE.Vector3();
            let face = "";
            if (aX > aY && aX > aZ) {
              norm.setX(Math.sign(dx));
              face = dx > 0 ? "right" : "left";
            } else if (aY > aZ) {
              norm.setY(Math.sign(dy));
              face = dy > 0 ? "top" : "bottom";
            } else {
              norm.setZ(Math.sign(dz));
              face = dz > 0 ? "front" : "back";
            }
            return {
              blockPos: { x: bX, y: bY, z: bZ },
              face: face,
              point: cur,
              normal: norm,
            };
          }
          prev.copy(cur);
          dist += step;
        }
        return null;
      }

      // --- Movement Controls ---
      const moveSpeed = 5;
      const airControlFactor = 0.8;
      const airAccelerationFactor = 0.5; // Player accelerates at 50% of ground rate in air
      let friction = 0.05;
      let velocityX = 0;
      let velocityZ = 0;
      const keys = {
        w: false,
        a: false,
        s: false,
        d: false,
        space: false,
        shift: false,
        ctrl: false,
        x: false,
        l: false,
      };
      let yaw = -Math.PI / 2;
      let pitch = 0;
      const mouseSensitivity = 0.001;
      const playerVelocity = new THREE.Vector3(0, 0, 0); // Stores current horizontal velocity
      let maxSpeed = 5.0 * 1.2; // Maximum horizontal speed (units per second)
      const acceleration = 60.0; // How quickly the player speeds up (units per second^2)
      const dampingFactor = 0.83; // Multiplier applied each frame to slow down (closer to 1 = slower stop)
      const stopThreshold = 0.05; // Velocity magnitude below which player stops instantly
      // --- In overworld.html ---

// --- In overworld.html ---

// Choose ONE of these air control philosophies:
const AIR_ACCELERATION_SAME_AS_GROUND = true; // Option A: Full air control
const AIR_ACCELERATION_FACTOR = 0.2; // Option B: e.g., 50% of ground accel in air (used if AIR_ACCELERATION_SAME_AS_GROUND is false)

const SPRINT_SPEED_MULTIPLIER = 1.5; // How much faster sprinting is
const SNEAK_SPEED_MULTIPLIER = 0.3;  // How much slower sneaking is

// In overworld.html, inside the main <script> tag, near collisionTick()

// In overworld.html, inside the main <script> tag

// **** START CHANGE: ADD THIS ENTIRE NEW FUNCTION ****
function handleDropItem() {
    // 1. Get the currently selected item from the hotbar
    const selectedItem = hotbar[selectedHotbarSlot];

    // 2. If the slot is empty, do nothing
    if (!selectedItem) {
        return;
    }

    // 3. Remove one item from the stack
    selectedItem.count--;

    // 4. Get the type of the item to be dropped
    const itemTypeToDrop = selectedItem.type;

    // 5. If the stack is now empty, clear the hotbar slot
    if (selectedItem.count <= 0) {
        hotbar[selectedHotbarSlot] = null;
    }

    // 6. Update the inventory UI to show the change
    updateInventoryUI();

    // 7. Calculate the spawn position and throw velocity
    const spawnPosition = camera.position.clone();
    const throwDirection = new THREE.Vector3();
    camera.getWorldDirection(throwDirection); // Gets the direction the camera is facing

    // Position the item slightly in front of the player so they don't get stuck on it
    spawnPosition.add(throwDirection.clone().multiplyScalar(1.0));

    // Give the item a forward "throw" velocity, plus a little upward arc
    const throwVelocity = throwDirection.multiplyScalar(0.3);
    throwVelocity.y += 0.1;

    // 8. Create the item drop with the calculated position and velocity
    createItemDrop(spawnPosition, itemTypeToDrop, throwVelocity);
}
// **** END CHANGE ****

// **** START CHANGE: ADD THIS ENTIRE NEW FUNCTION ****
function updateDroppedItems(deltaTime) {
    if (droppedItems.length === 0) return;

    // Loop backwards because we might remove items from the array
    for (let i = droppedItems.length - 1; i >= 0; i--) {
        const item = droppedItems[i];

        // --- 1. Despawn Logic ---
        if (performance.now() - item.creationTime > ITEM_LIFESPAN) {
            scene.remove(item.mesh);
            item.mesh.geometry.dispose();
            item.mesh.material.dispose();
            droppedItems.splice(i, 1);
            continue; // Skip to the next item
        }
        if (item.pickupCooldown > 0) {
            item.pickupCooldown -= deltaTime * 1000; // deltaTime is in seconds
        }

        // --- 2. Pickup Logic ---
        const playerPos = new THREE.Vector3(camera.position.x, camera.position.y - (currentPlayerHeight/2), camera.position.z);
        
        // **** START CHANGE: ADD THE COOLDOWN CHECK ****
        // Only check for pickup if the cooldown has expired AND the player is close enough.
        if (item.pickupCooldown <= 0 && item.position.distanceTo(playerPos) < ITEM_PICKUP_RADIUS) {
            if (addToInventory(item.type, 1)) {
                scene.remove(item.mesh);
                item.mesh.geometry.dispose();
                item.mesh.material.dispose();
                droppedItems.splice(i, 1);
                continue;
            }
        }

        // --- 3. Physics and Collision ---
        if (!item.onGround) {
            item.velocity.y -= ITEM_GRAVITY;
            item.position.add(item.velocity);
            
            // Simple ground collision check
            const blockBelow = getBlock(item.position.x, item.position.y - 0.2, item.position.z);
            if (blockBelow && blockBelow.solid) {
                item.onGround = true;
                item.velocity.y = 0; // Stop vertical movement
                item.position.y = Math.floor(item.position.y) + 0.25; // Sit on top of the block
            }
        }
        
        // --- 4. Visuals (Bobbing and Spinning) ---
        item.mesh.position.y = item.position.y + Math.sin(performance.now() * 0.002 + item.creationTime) * 0.1;
        item.mesh.position.x = item.position.x;
        item.mesh.position.z = item.position.z;
        item.mesh.rotation.y += 0.01; // Spin
    }
}
// **** END CHANGE ****
function updateCameraPosition(deltaTime) {
    // --- 1. Calculate Input Direction (based on camera yaw) ---
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

    const right = new THREE.Vector3(1, 0, 0);
    right.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

    const inputDirection = new THREE.Vector3(); // Combined XZ input
    if (keys.w) inputDirection.add(forward);
    if (keys.s) inputDirection.sub(forward);
    if (keys.a) inputDirection.sub(right);
    if (keys.d) inputDirection.add(right);

    if (inputDirection.lengthSq() > 0) { // Avoid normalizing zero vector -> NaN issues
        inputDirection.normalize();
    }

    // --- 2. Determine Current Movement Modifiers (Sneak, Sprint) ---
    const isSneaking = keys.shift;
    // Can only sprint if on ground, moving forward (optional), and not sneaking
    const canSprint = keys.ctrl && isOnGround && !isSneaking && (keys.w || inputDirection.z < -0.1); // Check if moving forward-ish

    let speedMultiplier = 1.0;
    if (isSneaking) {
        speedMultiplier = SNEAK_SPEED_MULTIPLIER;
    } else if (canSprint) {
        speedMultiplier = SPRINT_SPEED_MULTIPLIER;
    }

    const currentApplicableMaxSpeed = maxSpeed * speedMultiplier;
    // Acceleration might also be affected by sneaking/sprinting, or keep it constant
    const currentApplicableAcceleration = acceleration; // Or: acceleration * speedMultiplier;

    // --- 3. Calculate Effective Acceleration Rate (Ground vs. Air) ---
    let effectiveAccelerationRate;
    if (AIR_ACCELERATION_SAME_AS_GROUND) {
        effectiveAccelerationRate = currentApplicableAcceleration;
    } else {
        effectiveAccelerationRate = isOnGround ? currentApplicableAcceleration : currentApplicableAcceleration * AIR_ACCELERATION_FACTOR;
    }

    // --- 4. Apply Acceleration to Player's Horizontal Velocity ---
    const accelerationToApply = inputDirection.multiplyScalar(effectiveAccelerationRate * deltaTime);
    playerVelocity.x += accelerationToApply.x;
    playerVelocity.z += accelerationToApply.z;

    // --- 5. Apply Damping (Friction) to Horizontal Velocity ---
    let currentDamping = dampingFactor; // Ground damping
    if (!isOnGround) {
        currentDamping = 0.985; // Air damping (less friction, value closer to 1.0)
    }
    // Frame-rate adjusted damping:
    playerVelocity.x *= Math.pow(currentDamping, deltaTime * 60);
    playerVelocity.z *= Math.pow(currentDamping, deltaTime * 60);
    // Simpler (if deltaTime is very stable):
    // playerVelocity.x *= currentDamping;
    // playerVelocity.z *= currentDamping;


    // --- 6. Clamp Horizontal Speed to Current Max Speed ---
    const horizontalSpeedSq = playerVelocity.x * playerVelocity.x + playerVelocity.z * playerVelocity.z;
    if (horizontalSpeedSq > currentApplicableMaxSpeed * currentApplicableMaxSpeed) {
        const horizontalSpeed = Math.sqrt(horizontalSpeedSq);
        playerVelocity.x = (playerVelocity.x / horizontalSpeed) * currentApplicableMaxSpeed;
        playerVelocity.z = (playerVelocity.z / horizontalSpeed) * currentApplicableMaxSpeed;
    }

    // --- 7. Stop Threshold (if no input and velocity is very low) ---
    if (!(keys.w || keys.a || keys.s || keys.d) && playerVelocity.lengthSq() < stopThreshold * stopThreshold) {
        playerVelocity.x = 0;
        playerVelocity.z = 0;
    }

    // --- 8. Apply Horizontal Velocity to Camera Position ---
    // Vertical movement (gravity, jump resolution) is handled in collisionTick()
    camera.position.x += playerVelocity.x * deltaTime;
    camera.position.z += playerVelocity.z * deltaTime;

    // --- 9. Handle Jump Initiation ---
    if (keys.space && isOnGround) {
        verticalVelocity = jumpHeight; // Apply upward impulse for next collisionTick
        isOnGround = false;       // Player leaves the ground
        wasOnGround = true;       // For landing detection in collisionTick
        fallDistance = 0;         // Reset fall distance when a jump starts
    }

    // --- 10. Update Camera Rotation (Pitch and Yaw from mouse input) ---
    // This assumes 'pitch' and 'yaw' are updated by your mousemove event listener
    camera.rotation.set(pitch, yaw, 0, "YXZ"); // Standard FPS Euler order

    // --- 11. Update Player Chunk Position for World Loading/Unloading ---
    const { cx: currentChunkCoordX, cz: currentChunkCoordZ } = worldToChunkCoords(
        camera.position.x,
        camera.position.z
    );
    if (currentChunkCoordX !== lastPlayerChunkX || currentChunkCoordZ !== lastPlayerChunkZ) {
        lastPlayerChunkX = currentChunkCoordX;
        lastPlayerChunkZ = currentChunkCoordZ;
        chunksNeedUpdate = true; // Signal main thread's updateChunks to run
        // console.log(`MainThread: Player moved to new chunk ${currentChunkCoordX},${currentChunkCoordZ}.`);
    }
}
      // --- Breaking State & Logic ---
      let isBreaking = false;
      let currentBreakingTarget = null;
      let breakStartTime = 0;
      let breakProgress = 0;
      // --- START: FULL UPDATED updateBreaking FUNCTION ---
// --- START: FULL UPDATED updateBreaking FUNCTION (with Material Speeds) ---
// In overworld.html, inside the main <script> tag

// **** REPLACE the old updateBreaking function with this new one ****
function updateBreaking(deltaTime) {
    // 1. Guard Clauses (Remain the same)
    if (!isBreaking || isInventoryOpen || isCraftingTableOpen || document.pointerLockElement !== renderer.domElement) {
        if (isBreaking) {
            isBreaking = false;
            currentBreakingTarget = null;
        }
        return;
    }

    // 2. Raycast and Handle Target Changes (Remain the same)
    mouse.x = 0;
    mouse.y = 0;
    raycaster.setFromCamera(mouse, camera);
    const inter = findBlockIntersection(raycaster.ray);
    const targetPosition = inter ? inter.blockPos : null;

    if (!targetPosition || !currentBreakingTarget || targetPosition.x !== currentBreakingTarget.x || targetPosition.y !== currentBreakingTarget.y || targetPosition.z !== currentBreakingTarget.z) {
        currentBreakingTarget = targetPosition;
        breakProgress = 0;
        breakStartTime = performance.now();
        if (!currentBreakingTarget) return;
    }

    // 3. Get Block Info and Check if Breakable (Remain the same)
    const blockKey = getBlockKey(currentBreakingTarget.x, currentBreakingTarget.y, currentBreakingTarget.z);
    const blockData = world[blockKey];
    if (!blockData) { isBreaking = false; return; }

    const blockType = blockData.type;
    const breakProps = breakInfo[blockType];
    if (!breakProps || breakProps.hardness <= 0) {
        breakProgress = 0;
        return;
    }

    // --- 4. NEW & IMPROVED Breaking Speed Calculation ---
    const selectedItem = hotbar[selectedHotbarSlot];
    const heldItemType = selectedItem ? selectedItem.type : null;
    const heldToolCategory = toolTypes[heldItemType]; // e.g., 'pickaxe', 'shovel', or undefined

    let speedMultiplier = 1.0; // This will be our final speed modifier

    // Check if the block requires a specific tool for drops (like stone)
    if (breakProps.tool !== 'any') {
        if (heldToolCategory === breakProps.tool) {
            // Correct tool category is held, apply material speed bonus
            speedMultiplier = toolMaterialSpeeds[heldItemType] || 1.0;
        } else {
            // WRONG TOOL for a block that REQUIRES a tool (e.g., breaking stone with hand/shovel)
            speedMultiplier = 0.15; // Massive penalty
        }
    } 
    // This block is for blocks that are breakable by anything (e.g., dirt, grass)
    else {
        if (heldToolCategory === breakProps.optimalTool) {
            // The OPTIMAL tool is held (e.g., dirt with a shovel)
            speedMultiplier = toolMaterialSpeeds[heldItemType] || 1.0;
        } else {
            // A non-optimal tool OR bare hands are used
            speedMultiplier = 0.4; // Moderate penalty, but still breakable
        }
    }
    
    // --- 5. Calculate Final Time and Progress (remains the same) ---
    const baseHardnessFactor = 600;
    const requiredTime = (breakProps.hardness * baseHardnessFactor) / speedMultiplier;
    const elapsedTime = performance.now() - breakStartTime;
    breakProgress = Math.min(elapsedTime / requiredTime, 1.0);

    // --- 6. Complete the Break (remains the same) ---
    if (breakProgress >= 1.0) {
        removeBlockAt(currentBreakingTarget.x, currentBreakingTarget.y, currentBreakingTarget.z);
    }
}
// --- END: FULL UPDATED updateBreaking FUNCTION (with Material Speeds) ---
      // --- In overworld.html ---

function getSlotLocation(slotIndex) {
    if (!slotIndex || typeof slotIndex !== "string") {
        // console.error("getSlotLocation: Invalid slotIndex provided:", slotIndex); // Optional debug
        return null;
    }

    const parts = slotIndex.split("-");
    const type = parts[0];
    let indexPrefix = ""; // For handling cases like "storage-furnace"
    let indexStr;

    if (parts.length === 3) { // e.g., "storage-furnace-0" or "hotbar-furnace-0"
        indexPrefix = parts[1]; // "furnace", "ct", "inv"
        indexStr = parts[2];
    } else if (parts.length === 2) { // e.g., "hotbar-0", "storage-0", "crafting-0"
        indexStr = parts[1];
    } else { // e.g., "crafting-output", "furnace-input-0" (if 0 is part of type for furnace)
        indexStr = parts.length > 1 ? parts[parts.length - 1] : null; // Get last part as potential index
        // For single-word types like "crafting-output", indexStr will be "output"
    }


    const index = parseInt(indexStr);

    // Handle non-indexed slots (output slots)
    if (isNaN(index) && (slotIndex === "crafting-output" || slotIndex === "craftingtable-output" || slotIndex === "furnace-output-0")) {
        if (slotIndex === "crafting-output") {
            return { array: [craftingOutput], index: 0, type: "crafting-output" };
        } else if (slotIndex === "craftingtable-output") {
            return { array: [craftingTableOutput], index: 0, type: "craftingtable-output" };
        } else if (slotIndex === "furnace-output-0") { // Assuming output has index 0
             if (!activeFurnace) { console.error("getSlotLocation: furnace-output-0 clicked but no activeFurnace!"); return null; }
             // Wrap the single item in an array to match the expected structure for setSlotData
             return { array: [activeFurnace.outputItem], index: 0, type: "furnace-output", sourceObject: activeFurnace, propertyName: 'outputItem' };
        }
        // console.error("getSlotLocation: Unhandled non-indexed slot:", slotIndex);
        return null;
    }

    // Handle indexed slots
    if (isNaN(index) && type !== "furnace") { // If index is still NaN and it's not a furnace special slot
         console.error(`getSlotLocation: Could not parse index from slotIndex: '${slotIndex}' -> '${indexStr}'`);
         return null;
    }


    switch (type) {
        case "hotbar": // Covers "hotbar-0" and "hotbar-furnace-0", "hotbar-ct-0", etc.
            return { array: hotbar, index: index, type: type, prefix: indexPrefix };
        case "storage": // Covers "storage-0" and "storage-furnace-0", "storage-ct-0", etc.
            return { array: storage, index: index, type: type, prefix: indexPrefix };
        case "armor":
            return { array: armor, index: index, type: type }; // Usually no prefix for armor
        case "crafting": // 2x2 grid
            return { array: craftingGrid, index: index, type: type };
        case "craftingtable": // 3x3 grid
            return { array: craftingTableGrid, index: index, type: type };
        case "furnace": // Specific furnace slots
            if (!activeFurnace) {
                console.error("getSlotLocation: Furnace slot clicked but no activeFurnace!");
                return null;
            }
            if (slotIndex === `furnace-input-0`) { // Or whatever you named it in updateFurnaceUI
                 // Wrap the single item in an array to match the expected structure for setSlotData
                return { array: [activeFurnace.inputItem], index: 0, type: "furnace-input", sourceObject: activeFurnace, propertyName: 'inputItem' };
            } else if (slotIndex === `furnace-fuel-0`) {
                return { array: [activeFurnace.fuelItem], index: 0, type: "furnace-fuel", sourceObject: activeFurnace, propertyName: 'fuelItem' };
            }
            // furnace-output-0 is handled above in the isNaN(index) block
            break; // Fall through to default if not matched
        default:
            console.error("getSlotLocation: Unknown slot type:", type, "from slotIndex:", slotIndex);
            return null;
    }
    // Should not be reached if all cases are handled
    return null;
}
      // --- In overworld.html ---

function setSlotData(slotIndex, itemData) {
    const loc = getSlotLocation(slotIndex);
    if (!loc) {
        console.error("setSlotData: Could not get slot location for", slotIndex);
        return false;
    }

    // Handle direct setting for special slots (like furnace slots)
    if (loc.sourceObject && typeof loc.propertyName !== 'undefined') {
        // This is for furnace input, fuel, or output slots
        const currentItem = loc.sourceObject[loc.propertyName];
        if (JSON.stringify(currentItem) === JSON.stringify(itemData)) {
            return true; // No change needed
        }
        // console.log(`setSlotData: Updating furnace slot ${loc.type} (prop: ${loc.propertyName})`, "New data:", JSON.stringify(itemData));
        loc.sourceObject[loc.propertyName] = itemData; // Directly set the property

        // Trigger furnace logic if an input or fuel slot changed
        if (loc.type === "furnace-input" || loc.type === "furnace-fuel") {
            // console.log("   -> Triggering furnace recipe/progress check due to change in:", slotIndex);
            // You'll need a function here to check if smelting can start/continue
            // checkFurnaceState(); // Example function call
        }
        // No recipe check needed if output is directly taken/set via handleInventoryClick
        return true;
    }

    // Handle array-based slots (inventory, hotbar, crafting grids)
    if (!loc.array) {
        console.error("setSlotData: Slot location has no array for", slotIndex, loc);
        return false;
    }

    // Handle crafting output slots (which are also wrapped in an array by getSlotLocation)
    if (loc.type === "crafting-output") {
        craftingOutput = itemData; // itemData is the single output item or null
        return true;
    } else if (loc.type === "craftingtable-output") {
        craftingTableOutput = itemData;
        return true;
    }

    // Standard array slot setting
    if (typeof loc.index === 'undefined' || loc.index < 0 || loc.index >= loc.array.length && !(loc.array.length === 0 && loc.index === 0) ) {
         if (loc.array.length === 1 && loc.index === 0) { // For single item arrays like furnace slots already handled by sourceObject
             // This path should be hit if loc.sourceObject was not defined but it's a single item array
         } else {
             console.error("setSlotData: Invalid index for slot", slotIndex, "Index:", loc.index, "Array length:", loc.array.length);
             return false;
         }
    }


    const currentItem = loc.array[loc.index];
    if (JSON.stringify(currentItem) === JSON.stringify(itemData)) {
        // console.log("setSlotData: Item unchanged for", slotIndex);
        return true;
    }

    // console.log("setSlotData: Updating array slot", slotIndex, "New data:", JSON.stringify(itemData));
    loc.array[loc.index] = itemData;

    if (loc.type === "crafting") {
        // console.log("   -> Triggering 2x2 recipe check due to change in:", slotIndex);
        checkCraftingRecipe();
    } else if (loc.type === "craftingtable") {
        // console.log("   -> Triggering 3x3 recipe check due to change in:", slotIndex);
        checkCraftingTableRecipe();
    }
    return true;
}
            // --- REPLACE THE ENTIRE FUNCTION WITH THIS ---
            function handleInventoryClick(event) {
        // Ignore clicks if a right-drag spread is *in progress*
        if (isDragging) {
            console.log("handleInventoryClick blocked: Right drag in progress.");
            return;
        }
        if (!isInventoryOpen && !isCraftingTableOpen) {
             console.log("handleInventoryClick blocked: No inventory open.");
             return;
        }

        const clickedSlotElement = event.target.closest(".inventory-slot");

        // Clicking outside slots (potentially dropping item)
        /*
        if (!clickedSlotElement) {
          // Check if the click originated within the bounds of an open inventory screen
          const invScreen = document.getElementById('full-inventory-screen');
          const ctScreen = document.getElementById('crafting-table-screen');
          const isClickInsideInv = isInventoryOpen && invScreen && invScreen.contains(event.target);
          const isClickInsideCt = isCraftingTableOpen && ctScreen && ctScreen.contains(event.target);

          // Only drop if the click was outside a slot *but inside* an inventory screen boundary
          if (isClickInsideInv || isClickInsideCt) {
              console.log("Clicked outside a slot within inventory area.");
              if (itemOnCursor) {
                updateInventoryUI();
              }
          } else {
               // Click was outside the inventory screen boundary entirely, do nothing here.
          }
          return; // Click was not on a slot, finished handling.
        }
          */


        // --- Proceed only if a slot was clicked ---
        const slotIndex = clickedSlotElement.dataset.slotIndex;
        if (!slotIndex) {
            console.error("Clicked element is slot-like but has no slotIndex dataset!");
            return;
        }

        // *** VITAL: Define slotLocation HERE ***
        const slotLocation = getSlotLocation(slotIndex);
        if (!slotLocation || !slotLocation.array) { // Check existence and array validity
             console.error("Could not get valid slot location for index:", slotIndex);
             return; // EXIT if location is invalid
        }
        // *** End Definition ***

        const itemInSlot = slotLocation.array[slotLocation.index]; // Get the actual item (or null)
        const clickedSlotItem = itemInSlot ? { ...itemInSlot } : null; // Get a *copy* if item exists
        const cursorMaxStack = itemOnCursor ? getItemMaxStackSize(itemOnCursor.type) : DEFAULT_MAX_STACK_SIZE;
        const slotMaxStack = clickedSlotItem ? getItemMaxStackSize(clickedSlotItem.type) : DEFAULT_MAX_STACK_SIZE;


        // --- Right Click Logic (Button 2) ---
        if (event.button === 2) {
            event.preventDefault(); // Prevent context menu

            // Case 1: Item on cursor, right-clicking a slot (place one)
            if (itemOnCursor) {
                // Check if target slot is valid for placing single items
                if (slotLocation.type === "crafting-output" || slotLocation.type === "craftingtable-output" || slotLocation.type === "armor") {
                    console.log(" Cannot place single items into output/armor with right click.");
                    return;
                }

                let currentSlotItem = slotLocation.array[slotLocation.index]; // Get direct reference for checking/modification
                if (!currentSlotItem) { // Place one in empty slot
                    console.log(" Placing 1 item in empty slot.");
                    if (itemOnCursor.count >= 1) { // Ensure cursor has items
                        let newItem = { type: itemOnCursor.type, count: 1 };
                        setSlotData(slotIndex, newItem); // Use setSlotData
                        itemOnCursor.count--;
                        if (itemOnCursor.count <= 0) itemOnCursor = null;
                        updateInventoryUI();
                    }
                } else if (currentSlotItem.type === itemOnCursor.type && currentSlotItem.count < getItemMaxStackSize(currentSlotItem.type)) { // Add one to stack
                    console.log(" Adding 1 item to existing stack.");
                     if (itemOnCursor.count >= 1) { // Ensure cursor has items
                        let updatedItem = {...currentSlotItem}; // Create copy
                        updatedItem.count++; // Increment count
                        setSlotData(slotIndex, updatedItem); // Update slot via function

                        itemOnCursor.count--;
                        if (itemOnCursor.count <= 0) itemOnCursor = null;
                        updateInventoryUI();
                     }
                } else {
                     console.log(" Cannot place item: Slot incompatible or full.");
                }
            }
            // Case 2: No item on cursor, right-clicking an existing stack (pick up half)
            else if (clickedSlotItem) { // Use the copy we made earlier
                 // Check if source slot is valid
                 if (slotLocation.type === "crafting-output" || slotLocation.type === "craftingtable-output") {
                      console.log(" Cannot split stack from output slot.");
                    return;
                }
                // Pick up half
                const amountToPickUp = Math.ceil(clickedSlotItem.count / 2);
                 console.log(` Picking up ${amountToPickUp} from stack of ${clickedSlotItem.count}.`);
                itemOnCursor = { type: clickedSlotItem.type, count: amountToPickUp }; // Item for cursor

                // Calculate remaining item data
                let remainingItem = {...clickedSlotItem}; // Copy original slot item again
                remainingItem.count -= amountToPickUp;

                // Update the original slot
                 if (remainingItem.count <= 0) {
                     setSlotData(slotIndex, null); // Clear slot if empty
                 } else {
                     setSlotData(slotIndex, remainingItem); // Update slot with remaining amount
                 }
                updateInventoryUI();
            } else {
                 console.log(" Right-click on empty slot with empty cursor - doing nothing.");
            }
            updateInventoryUI()
            return; // End right-click handling
        } // End Right Click Logic


        // --- Left Click Logic (Button 0) ---
        if (event.button === 0) {
            console.log("Processing left-click action.");

            // --- Handle Crafting Output Slots ---
            if (slotLocation.type === "crafting-output" || slotLocation.type === "craftingtable-output") {
                 console.log(" Clicked on crafting output slot.");
                 const isTableOutput = slotLocation.type === "craftingtable-output";
                 // Use direct access to current output state for check
                 const currentOutput = isTableOutput ? craftingTableOutput : craftingOutput;
                 const outputMaxStack = currentOutput ? getItemMaxStackSize(currentOutput.type) : DEFAULT_MAX_STACK_SIZE;
                 // Check if output exists and can be picked up
                 if ((!itemOnCursor || (itemOnCursor.type === currentOutput.type && itemOnCursor.count < cursorMaxStack))) {
                     const gridToCheck = isTableOutput ? craftingTableGrid : craftingGrid;
                     const gridSizeType = isTableOutput ? '3x3' : '2x2';
                     const recipe = findRecipe(gridToCheck, gridSizeType); // Find recipe first
                          if (recipe && recipe.output.type === currentOutput.type) { // Double check recipe matches output
                           // Check if cursor has space
                           const spaceOnCursor = !itemOnCursor ? outputMaxStack : cursorMaxStack - itemOnCursor.count;
                           if (currentOutput.count <= spaceOnCursor) {
                               const outputCopy = { ...currentOutput }; // Take a copy before consuming

                               // Try consuming ingredients
                               const gridElementCount = isTableOutput ? CRAFTING_TABLE_GRID_SIZE : CRAFTING_GRID_SIZE;
                           if (consumeRecipeIngredients(recipe, gridToCheck, gridElementCount)) {
                                // Successfully consumed ingredients
                               // --- Logic to add output to cursor ---
                              if (!itemOnCursor) {
                                   // If cursor was empty, just place the crafted item there
                                   itemOnCursor = outputCopy;
                                   console.log(itemOnCursor.count)
                                   console.log("Took crafted item onto empty cursor:", JSON.stringify(itemOnCursor));
                               } else if(itemOnCursor.type === outputCopy.type) {
                                   // If cursor already had a compatible item, just add the count
                                   // (The initial checks already confirmed type match and space)
                                   console.log("added items to cursor")
                                   itemOnCursor.count += outputCopy.count;
                                   console.log(`Added ${outputCopy.count} to cursor. New count: ${itemOnCursor.count}`);
                               }
                               else{
                                  console.log(itemOnCursor)
                               }

                               // --- State Check & UI Update ---
                               // Re-check recipe AFTER consumption to see if more can be made
                               if (isTableOutput) {
                                   checkCraftingTableRecipe();
                               } else {
                                   checkCraftingRecipe();
                               }
                               console.log("Cursor state before final UI update in output handler:", JSON.stringify(itemOnCursor));
                               updateInventoryUI(); // Update UI AFTER cursor is modified and recipe is re-checked

                           } else {
                               // Consumption failed (shouldn't happen if initial checks were right, but handle defensively)
                               console.error("Ingredient consumption failed unexpectedly!");
                               // Maybe force a recipe re-check and UI update anyway?
                                if (isTableOutput) checkCraftingTableRecipe(); else checkCraftingRecipe();
                                updateInventoryUI();
                           }
                          // --- ^ ^ ^ REPLACE THIS BLOCK ^ ^ ^ ---
                           } else {
                               console.log("Cannot take crafted item, cursor does not have enough space for the stack.");
                           }
                     } else {
                         console.log("Recipe no longer valid for output click, or output mismatch?");
                         // Force clear output if recipe doesn't match? Risky.
                     }
                 } else if (currentOutput && itemOnCursor) {
                     console.log("Cannot take crafted item, cursor full or different type.");
                 } else {
                      console.log("Clicked empty output slot or no valid recipe output.");
                 }
                 return; // Stop processing after output click
                 console.warn(itemOnCursor, currentOutput.type, outputMaxStack);
            } // End output slot handling

            // --- Standard Slot Interaction (Left Click) ---
             console.log(" Processing standard slot left-click.");
            if (itemOnCursor) { // Case 1 & 2: Cursor has item
                 console.log(" Cursor has item.");
                // Case 1: Slot is empty
                if (!clickedSlotItem) {
                     console.log(" Slot is empty. Placing item from cursor.");
                     // Check armor compatibility later
                    setSlotData(slotIndex, itemOnCursor); // Place item
                    itemOnCursor = null; // Clear cursor
                }
                // Case 2: Slot has item (use clickedSlotItem copy for data)
                else {
                     console.log(" Slot has item.");
                    // Case 2a: Same type, stackable
                    if (itemOnCursor.type === clickedSlotItem.type && clickedSlotItem.count < slotMaxStack) {
                         console.log(" Items are same type & stackable.");
                        const canAdd = slotMaxStack - clickedSlotItem.count;
                        const amountToAdd = Math.min(itemOnCursor.count, canAdd);
                         console.log(` Can add ${canAdd}, trying to add ${amountToAdd}.`);

                        if (amountToAdd > 0) {
                             // Create updated slot item data based on the copy
                             let updatedSlotItem = { ...clickedSlotItem };
                             updatedSlotItem.count += amountToAdd;
                             setSlotData(slotIndex, updatedSlotItem); // Update slot

                             // Update cursor item
                             itemOnCursor.count -= amountToAdd;
                             if (itemOnCursor.count <= 0) {
                                 console.log(" Cursor empty after stacking.");
                                 itemOnCursor = null;
                             }
                        } else {
                             console.log("Cannot stack further (already full or adding 0). Swapping.");
                             // Fall through to swap logic if amountToAdd is 0 but types match
                              setSlotData(slotIndex, itemOnCursor); // Place cursor item into the slot
                              itemOnCursor = clickedSlotItem; // Put the original slot item (copy) onto the cursor
                        }
                    }
                    // Case 2b: Different types or stack full - Swap
                    else {
                         console.log(" Items are different types or slot full. Swapping.");
                         // Check armor compatibility later
                         setSlotData(slotIndex, itemOnCursor); // Place cursor item into the slot
                         itemOnCursor = clickedSlotItem;   // Put the original slot item (copy) onto the cursor
                    }
                }
            }
            // Case 3: Cursor empty, slot has item - Pick up item
            else { // itemOnCursor is null
                 console.log(" Cursor is empty.");
                if (clickedSlotItem) { // Use the copy
                     console.log(" Slot has item. Picking it up.");
                    itemOnCursor = clickedSlotItem; // Assign the copy to cursor
                    setSlotData(slotIndex, null);    // Clear the original slot using slotIndex
                } else {
                }
            }
            console.log("End of left-click standard handling. Updating UI.");
            updateInventoryUI(); // Update UI after standard left click interaction
        } // End Left Click Logic
        updateInventoryUI();
      } // --- END OF handleInventoryClick FUNCTION ---

            // --- Crafting Logic ---
            const recipes = [
        // 2x2 Recipes
        {
          input: ["log", null, null, null], // Shapeless log -> planks
          output: { type: "plank", count: 4 },
          size: '2x2',
          shapeless: true
        },
        { // Stick recipe (vertical planks) - Size 2x2 allows it in both grids
          input: [null, "plank", null, "plank"],
          output: { type: "stick", count: 4 },
          size: '2x2'
        },
        {
          input: ["plank", "plank", "plank", "plank"],
          output: { type: "craftingtable", count: 1 },
          size: '2x2'
        },
         // Add more 2x2 recipes here...

        // 3x3 Recipes
        { // Wooden Pickaxe
          input: [
              'plank', 'plank', 'plank',
              null, 'stick', null,
              null, 'stick', null
          ],
          output: { type: "wooden_pickaxe", count: 1 },
          size: '3x3'
        },
        { // Wooden Axe
          input: [
              'plank', 'plank', null,
              'plank', 'stick', null,
              null, 'stick', null
          ],
          output: { type: "wooden_axe", count: 1 },
          size: '3x3'
        },
         { // Wooden Axe (Mirrored) - Optional, allows both L shapes
          input: [
              null, 'plank', 'plank',
              null, 'stick', 'plank',
              null, 'stick', null
          ],
          output: { type: "wooden_axe", count: 1 },
          size: '3x3'
        },
        { // Wooden Shovel
          input: [
              null, 'plank', null,
              null, 'stick', null,
              null, 'stick', null
          ],
          output: { type: "wooden_shovel", count: 1 },
          size: '3x3'
        },
        { // Wooden Sword
          input: [
              null, 'plank', null,
              null, 'plank', null,
              null, 'stick', null
          ],
          output: { type: "wooden_sword", count: 1 },
          size: '3x3'
        },
        {
          input: [
            "log", null, null,
            null, null, null,
            null, null, null
        ],
          output: { type: "plank", count: 4 },
          size: '3x3',
          shapeless: true
        },
        { // Stick recipe (vertical planks) - Size 2x2 allows it in both grids
          input: [
            "plank", null, null,
            "plank", null, null,
            null, null, null
        ],
          output: { type: "stick", count: 4 },
          size: '3x3'
        },
        {
          input:[
            "plank", "plank", null,
            "plank", "plank", null,
             null, null, null
          ],
          output: { type: "craftingtable", count: 1 },
          size: '3x3'
        },
        {
          input: [
            "cobblestone, cobblestone, cobblestone",
            null, "stick", null,
            null, "stick", null
          ],
          output: { type: "stone_pickaxe", count: 1 },
          size: '3x3'
        }
      ];
      // Find recipe matching the grid content and required size
      function findRecipe(grid, size) {
        const gridTypes = grid.map((item) => (item ? item.type : null));
        const expectedInputLength = (size === '3x3' ? 9 : 4);

        for (const recipe of recipes) {
          // Skip recipes not matching the required size or input length
          if (recipe.size !== size || recipe.input.length !== expectedInputLength) {
              continue;
          }

          let match = false;

          if (recipe.shapeless && size === '2x2') { // Handle 2x2 shapeless
              const recipeItems = recipe.input.filter(t => t !== null);
              const gridItems = gridTypes.filter(t => t !== null);
              if (recipeItems.length === gridItems.length) {
                  const sortedRecipe = [...recipeItems].sort();
                  const sortedGrid = [...gridItems].sort();
                   match = sortedRecipe.every((val, index) => val === sortedGrid[index]);
              }
          } else { // Shaped recipe check
              match = true;
              for (let i = 0; i < expectedInputLength; i++) {
                  if (recipe.input[i] !== gridTypes[i]) {
                      match = false;
                      break;
                  }
              }
          }

          if (match) {
            // Check if grid actually has items where recipe expects them
            // (Prevents matching recipe with empty grid slots)
             let hasRequiredItems = true;
             for (let i = 0; i < expectedInputLength; i++) {
                 // If recipe expects an item, the grid must have one (of the right type, checked above)
                 if (recipe.input[i] !== null && grid[i] === null) {
                     hasRequiredItems = false;
                     break;
                 }
                 // Also ensure grid doesn't have items where recipe expects null (for shaped recipes)
                 if (!recipe.shapeless && recipe.input[i] === null && grid[i] !== null) {
                     hasRequiredItems = false;
                     break;
                 }
             }
             if(hasRequiredItems) return recipe; // Return the first matching recipe
          }
        }
        return null; // No recipe found
      }

      // Modify consumeRecipeIngredients to accept the grid
      function consumeRecipeIngredients(recipe, grid, gridSize) {
          if (!recipe) return false;
          console.warn("executed")
          // Create a copy to check against, to handle cases where multiple grid slots
          // are consumed by the same ingredient type in shapeless recipes.
          let tempGrid = grid.map(item => item ? {...item} : null);
          let consumed = true;

          if (recipe.shapeless && recipe.size === '2x2') {
               const recipeItems = recipe.input.filter(t => t !== null);
               for(const recipeItemType of recipeItems) {
                   let foundAndConsumed = false;
                   for(let i = 0; i < gridSize; i++) {
                       if(tempGrid[i] && tempGrid[i].type === recipeItemType && tempGrid[i].count > 0) {
                           tempGrid[i].count--;
                           if(tempGrid[i].count <= 0) {
                               tempGrid[i] = null;
                           }
                           foundAndConsumed = true;
                           break; // Consume only one grid item per recipe ingredient
                       }
                   }
                   if (!foundAndConsumed) {
                       console.error(`Shapeless recipe: Failed to find/consume ingredient ${recipeItemType}`);
                       consumed = false;
                       break;
                   }
               }
          } else { // Shaped recipe consumption
              for (let i = 0; i < gridSize; i++) {
                  if (recipe.input[i] !== null) {
                      if (tempGrid[i] && tempGrid[i].type === recipe.input[i]) {
                          tempGrid[i].count--;
                          if (tempGrid[i].count <= 0) {
                              tempGrid[i] = null;
                          }
                      } else {
                          console.error(`Shaped recipe: Mismatch/missing ingredient at index ${i}. Expected ${recipe.input[i]}, got ${tempGrid[i]?.type}`);
                          consumed = false;
                          break; // Stop consumption on error
                      }
                  }
              }
          }


          // If all checks passed, apply changes to the actual grid
          if (consumed) {
              for(let i = 0; i < gridSize; i++) {
                  // Use setSlotData to ensure UI updates are triggered correctly
                  const slotType = recipe.size === '3x3' ? 'craftingtable' : 'crafting';
                  setSlotData(`${slotType}-${i}`, tempGrid[i]);
              }
          } else {
              console.error("Ingredient consumption failed. Grid state not changed.");
          }

          return consumed;
      }


      // Existing checkCraftingRecipe (for 2x2) - No change needed in signature
      function checkCraftingRecipe() {
        const recipe = findRecipe(craftingGrid, '2x2');
        const newOutput = recipe ? { ...recipe.output } : null;
        // Only update if output actually changed
        if (JSON.stringify(craftingOutput) !== JSON.stringify(newOutput)) {
          setSlotData("crafting-output", newOutput); // Update craftingOutput via setSlotData
          console.log("2x2 Crafting output updated to:", newOutput);
        }
      }

      // New function for 3x3 grid
      function checkCraftingTableRecipe() {
          const recipe = findRecipe(craftingTableGrid, '3x3');
          const newOutput = recipe ? { ...recipe.output } : null;
           // Only update if output actually changed
          if (JSON.stringify(craftingTableOutput) !== JSON.stringify(newOutput)) {
              setSlotData("craftingtable-output", newOutput); // Update craftingTableOutput
              console.log("3x3 Crafting output updated to:", newOutput);
          }
      }

      // --- Event Listeners ---
      document.addEventListener("keydown", (e) => {
        const closeInv = () => {
            let screenClosed = false;
            if (isInventoryOpen) {
                isInventoryOpen = false;
                document.getElementById("full-inventory-screen").style.display = "none";
                screenClosed = true;
            }
            if (isCraftingTableOpen) { // <-- New Check
                isCraftingTableOpen = false;
                document.getElementById("crafting-table-screen").style.display = "none";
                 // Also clear the 3x3 grid when closing? Optional, decide behavior.
                 // craftingTableGrid.fill(null);
                 // craftingTableOutput = null;
                screenClosed = true;
            }
                closeFurnaceUI(); // Call your new close function
                screenClosed = true;

            if (screenClosed) {
                 // Return items on cursor to inventory (if any screen was closed)
                if (itemOnCursor) {
                    if (!addToInventory(itemOnCursor.type, itemOnCursor.count)) {
                    console.log("Inventory full, discarding item:", itemOnCursor);
                    // Potentially drop item in world here
                    }
                    itemOnCursor = null;
                    updateCursorDisplay(); // Hides cursor item display
                }

                 // Clear any leftover drag state
                 isDragging = false;
                 dragSlots = [];
                 dragItemType = null;

                // Attempt to re-lock pointer
                document.body.style.cursor = "none"; // Hide cursor immediately
                 renderer.domElement.requestPointerLock().catch(err => console.log("Pointer lock rejected on inventory close."));
                console.log("Inventory/Crafting closed. Pointer lock requested.");
            }
        };

        // --- Toggle Inventory ---
        if (e.code === "KeyE") {
          e.preventDefault(); // Prevent typing 'e' if chat is added later
          if (isInventoryOpen || isCraftingTableOpen) { // Close if either is open
            closeInv();
          } else if (document.pointerLockElement === renderer.domElement) {
            // Open regular inventory
            isInventoryOpen = true;
            isCraftingTableOpen = false; // Ensure crafting table is closed
            document.getElementById("full-inventory-screen").style.display = "flex";
            document.getElementById("crafting-table-screen").style.display = "none"; // Hide crafting
            document.body.style.cursor = "default";
            checkCraftingRecipe(); // Check recipe when opening
            updateInventoryUI();
            document.exitPointerLock();
          }
          return;
        }

        // --- Close with Escape ---
        if ((isInventoryOpen || isCraftingTableOpen) && e.code === "Escape") {
          e.preventDefault();
          closeInv();
          closeFurnaceUI()
          return;
        }

        // --- Hotbar Selection & Movement ---
        if (!isInventoryOpen && !isCraftingTableOpen && document.pointerLockElement === renderer.domElement) {
          if (e.code === 'KeyQ') {
            e.preventDefault(); // Prevent any default browser action
            handleDropItem();
          }
          const key = e.key.toLowerCase();
          if (key in keys) keys[key] = true;
          if (e.code === "Space") keys.space = true;
          if (e.code === "ShiftLeft" || e.code === "ShiftRight") keys.shift = true;
          if (e.code === "ControlLeft" || e.code === "ControlRight") keys.control = true;

          // Hotbar keys 1-9
          if (!isNaN(parseInt(key)) && parseInt(key) >= 1 && parseInt(key) <= 9) {
            selectedHotbarSlot = parseInt(key) - 1;
            updateInventoryUI(); // Update to show selection change
          }
        }
        if(e.key === "ctrl"){
            keys.ctrl = true;
        }
        if(e.key === "x"){
            keys.x = true;
        }
        if(keys.x && keys.ctrl){
            e.preventDefault();
            console.log("CTRL + S pressed");
            // Add your save logic here
        }
      });
      document.addEventListener("keyup", (e) => {
        if (!isInventoryOpen) {
          const k = e.key.toLowerCase();
          if (k in keys) keys[k] = false;
          if (e.code === "Space") keys.space = false;
          if (e.code === "ShiftLeft" || e.code === "ShiftRight")
            keys.shift = false;
          if(e.key === "ctrl"){
              keys.ctrl = false;
          }
          if(e.key === "s"){
              keys.s = false;
          }
        }
      });
      document.addEventListener("mousemove", (e) => {
        if (document.pointerLockElement === renderer.domElement) {
          yaw -= e.movementX * mouseSensitivity;
          pitch -= e.movementY * mouseSensitivity;
          pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        }
        if (isInventoryOpen && itemOnCursorDisplay) {
          itemOnCursorDisplay.style.left = `${e.clientX + 5}px`;
          itemOnCursorDisplay.style.top = `${e.clientY + 5}px`;
        }
      });
                  // --- START: FULLY REVISED mousedown LISTENER ---
      document.addEventListener("mousedown", (e) => {
        // --- Pointer Lock Request ---
        if (e.target === renderer.domElement) {
          if (!isInventoryOpen && !isCraftingTableOpen && document.pointerLockElement !== renderer.domElement) {
            renderer.domElement.requestPointerLock()
              .catch((err) => console.error("Pointer lock request failed:", err));
          }
          // --- Block Breaking/Placing (Left/Right Click in World) ---
          else if (!isInventoryOpen && !isCraftingTableOpen && document.pointerLockElement === renderer.domElement) {
            if (e.button === 0) { // Left Click - Start Breaking
              isBreaking = true;
              currentBreakingTarget = null;
              breakProgress = 0;
              breakStartTime = performance.now();
            } else if (e.button === 2) { // Right Click - Place/Interact
              e.preventDefault()
              handleBlockPlace();
            }
          }
        }
        // --- Inventory Interaction ---
        // Check if click is within either inventory screen
        else if ((isInventoryOpen && document.getElementById("full-inventory-screen").contains(e.target)) ||
                 (isCraftingTableOpen && document.getElementById("crafting-table-screen").contains(e.target)) )
        {
             e.preventDefault(); // Prevent text selection, etc. inside inventory

             // --- V V V NEW: DRAG INITIATION LOGIC V V V ---
             const clickedSlotElement = e.target.closest('.inventory-slot');

             // Check if dragging should start (Left OR Right click)
             if (clickedSlotElement && itemOnCursor && (e.button === 0 || e.button === 2)) {
                 const slotIndex = clickedSlotElement.dataset.slotIndex;
                 // Check if the clicked slot is a valid target to START a drag from/into
                 if (isValidSpreadTarget(slotIndex)) {
                     // Initiate Dragging State
                     isDragging = true;
                     dragButton = e.button; // Store which button (0 or 2)
                     dragItemType = itemOnCursor.type;
                     dragSlots = [slotIndex]; // Start with the first slot
                     console.log(`Started drag with button ${dragButton} on slot ${slotIndex}`);

                     // IMPORTANT: Prevent handleInventoryClick from processing this specific click
                     // as a single place/swap action, because we are starting a drag spread.
                     return;
                 }
             }
             // --- ^ ^ ^ NEW: DRAG INITIATION LOGIC ^ ^ ^ ---

             // If drag was NOT initiated, process the click normally
             // (Handles single left/right clicks, pickup, place-one, split-stack)
             handleInventoryClick(e);

        }
         // Clicking elsewhere while inventory is open (e.g., outside the window) might implicitly drop item if needed
         // else if (isInventoryOpen || isCraftingTableOpen) {
             // Potentially handle clicking outside the inventory bounds here if desired
             // Currently handled in handleInventoryClick if target isn't a slot
         //}
      });
      // --- END: FULLY REVISED mousedown LISTENER ---
      renderer.domElement.addEventListener("mouseup", (e) => {
        if (e.button === 0 && isBreaking) {
          isBreaking = false;
          currentBreakingTarget = null;
          breakProgress = 0;
          breakStartTime = 0;
          indicatorCube.visible = false;
          console.log("Stopped breaking.");
        }
      });
      document.addEventListener("pointerlockchange", () => {
        const isLocked = document.pointerLockElement === renderer.domElement;
        document.getElementById("crosshair").style.display = isLocked
          ? "block"
          : "none";
        // Show HUD if pointer locked OR any inventory screen is open
        document.getElementById("hud").style.display =
          isLocked || isInventoryOpen || isCraftingTableOpen ? "grid" : "none";

        if (!isLocked && !isInventoryOpen && !isCraftingTableOpen) { // Hide things if no lock AND no inventory open
          indicatorCube.visible = false;
          document.body.style.cursor = "default";
           // Make sure inventory screens are hidden if pointer lock lost unexpectedly
           document.getElementById("full-inventory-screen").style.display = "none";
           document.getElementById("crafting-table-screen").style.display = "none";
           isInventoryOpen = false; // Update state too
           isCraftingTableOpen = false;
        } else if (isLocked) {
          document.body.style.cursor = "none";
        } else { // Not locked, but inventory might be open
            document.body.style.cursor = "default";
        }
      });
      document.addEventListener("pointerlockerror", (e) => {
        console.error("Pointer lock error:", e);
        document.body.style.cursor = "default";
      });
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      window.addEventListener("wheel", (event) => {
        if (
          !isInventoryOpen &&
          document.pointerLockElement === renderer.domElement
        ) {
          if (event.deltaY < 0) {
            selectedHotbarSlot =
              (selectedHotbarSlot - 1 + HOTBAR_SIZE) % HOTBAR_SIZE;
          } else if (event.deltaY > 0) {
            selectedHotbarSlot = (selectedHotbarSlot + 1) % HOTBAR_SIZE;
          }
          updateInventoryUI();
        }
      });
            // --- Event Listeners for Right-Click Item Spreading ---

            function isValidSpreadTarget(slotIndex) {
          if (!slotIndex) return false;
          // Allow spreading in storage, hotbar, and crafting grids
          // Disallow output slots, armor slots
          return slotIndex.startsWith('storage-') ||
                 slotIndex.startsWith('hotbar-') ||
                 slotIndex.startsWith('crafting-') || // 2x2 grid
                 slotIndex.startsWith('craftingtable-'); // 3x3 grid
      }
      function getCraftingRecipe(recipeIndex) {
    return recipes[recipeIndex];
}

function removeCraftingRecipe(recipeIndex) {
    // Remove the current crafting recipe
    // This might involve updating a data structure or a database
    // For example:
    delete recipes[recipeIndex];
    recipeIndex = null;
}

            // --- START: REVISED mousemove LISTENER (Drag part) ---
            document.addEventListener('mousemove', (e) => {
          // Inventory item following cursor (if applicable)
          if ((isInventoryOpen || isCraftingTableOpen) && itemOnCursorDisplay) { // Check if *any* inventory is open
            itemOnCursorDisplay.style.left = `${e.clientX + 5}px`;
            itemOnCursorDisplay.style.top = `${e.clientY + 5}px`;
          }

          // Handle dragging over inventory slots
          if (isDragging) { // Check the generic dragging flag
              const slotElement = e.target.closest('.inventory-slot');
              if (slotElement) {
                  const slotIndex = slotElement.dataset.slotIndex;
                  // Add slot only if it's a valid target and not the same as the last one added
                  if (isValidSpreadTarget(slotIndex) && dragSlots[dragSlots.length - 1] !== slotIndex) {
                      dragSlots.push(slotIndex);
                      // console.log("Dragging over slots:", dragSlots); // Optional debug
                  }
              }
          }

          // Camera movement (if pointer locked)
          if (document.pointerLockElement === renderer.domElement) {
            yaw -= e.movementX * mouseSensitivity;
            pitch -= e.movementY * mouseSensitivity;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
         }
      });
      // --- END: REVISED mousemove LISTENER (Drag part) ---
                     // --- START: FULLY REVISED mouseup LISTENER (Drag part) ---
       document.addEventListener('mouseup', (e) => {
           // Stop block breaking on left mouse button release
           if (e.button === 0 && isBreaking) {
             isBreaking = false;
             currentBreakingTarget = null;
             breakProgress = 0;
             breakStartTime = 0;
             indicatorCube.visible = false; // Also hide indicator
             // console.log("Stopped breaking."); // Optional debug
           }

           // --- V V V Handle End of Inventory Drag V V V ---
           if (isDragging && e.button === dragButton) { // Ensure the correct button was released
               e.preventDefault(); // Prevent potential text selection etc.
               console.log(`Finishing drag initiated by button ${dragButton}. Slots:`, dragSlots);

               if (itemOnCursor && dragSlots.length > 0) {
                   const numSlots = dragSlots.length;
                   const totalItemsOnCursor = itemOnCursor.count;
                   const dragItemMaxStack = getItemMaxStackSize(dragItemType); // Max stack for this item type
                   let itemsDistributed = 0;

                   // --- Distribution Logic based on Drag Button ---
                   if (dragButton === 0 && !dragSlots.includes('crafting-output-0') && !dragSlots.includes('craftingtable-output-0')) { // LEFT CLICK DRAG = Even Spread
                       console.log("Distributing evenly (Left Drag)");
                       console.warn(itemOnCursor)
                       const baseAmount = Math.floor(totalItemsOnCursor / numSlots);
                       let remainder = totalItemsOnCursor % numSlots;

                       for (const slotIndex of dragSlots) {
                           if (itemOnCursor.count <= 0) break; // Stop if cursor empty

                           const amountForThisSlot = baseAmount + (remainder > 0 ? 1 : 0);
                           if (amountForThisSlot <= 0 && baseAmount <= 0) continue; // Skip if nothing to add
                           //skip if slot is a crafting output or crafting table output
const craftingSlots = ['crafting-1', 'crafting-2', 'crafting-3', 'crafting-4', 'crafting-5', 'crafting-6', 'crafting-7', 'crafting-8', 'crafting-9'];

const craftingTableSlots = ['craftingtable-1', 'craftingtable-2', 'craftingtable-3', 'craftingtable-4', 'craftingtable-5', 'craftingtable-6', 'craftingtable-7', 'craftingtable-8', 'craftingtable-9'];

// ...

if (slotIndex === 'crafting-output') { 
    const recipe = findRecipe(craftingGrid, '2x2');
    consumeRecipeIngredients(recipe, craftingGrid, 4);
    itemOnCursor.count += recipe.output.count;//the count of the item output
    updateInventoryUI()
    return;
}
else if (slotIndex === 'craftingtable-output') {
    const recipe = findRecipe(craftingTableGrid, '3x3');
    consumeRecipeIngredients(recipe, craftingTableGrid, 9);
    itemOnCursor.count += recipe.output.count;//the count of the item output
    updateInventoryUI()
    return;
}

                           const slotLoc = getSlotLocation(slotIndex);
                           if (!slotLoc) continue;

                           let targetSlotItem = slotLoc.array[slotLoc.index]; // Direct reference or null

                           // Check compatibility and space
                           if (!targetSlotItem || (targetSlotItem.type === dragItemType && targetSlotItem.count < dragItemMaxStack)) {
                               let actuallyAdded = 0;
                               let spaceAvailable = dragItemMaxStack;
                               if(targetSlotItem) {
                                   spaceAvailable = dragItemMaxStack - targetSlotItem.count;
                               }

                               actuallyAdded = Math.min(amountForThisSlot, spaceAvailable);

                               if (actuallyAdded > 0) {
                                   if (!targetSlotItem) {
                                       // Place new stack
                                       slotLoc.array[slotLoc.index] = { type: dragItemType, count: actuallyAdded };
                                   } else {
                                       // Add to existing stack
                                       targetSlotItem.count += actuallyAdded; // Modify existing item directly
                                   }
                                   itemsDistributed += actuallyAdded;
                                   // Use setSlotData AFTER modifying the array to trigger recipe checks etc.
                                   setSlotData(slotIndex, slotLoc.array[slotLoc.index]);
                                   if (remainder > 0) remainder--;
                                  // console.log(`Slot ${slotIndex}: Tried ${amountForThisSlot}, Added ${actuallyAdded}. Remainder: ${remainder}`);
                               }

                           } else {
                               // console.log(`Slot ${slotIndex}: Incompatible type or full.`);
                                // Decrement remainder even if slot is skipped? Or only if amount > 0?
                                if (amountForThisSlot > 0 && remainder > 0) remainder--;
                           }
                       } // End loop for left drag

                   } else if (dragButton === 2) { // RIGHT CLICK DRAG = Spread ONE item per slot
                       console.log("Distributing one per slot (Right Drag)");
                       for (const slotIndex of dragSlots) {
                           if (itemOnCursor.count <= 0) break; // Stop if cursor empty

                           const slotLoc = getSlotLocation(slotIndex);
                           if (!slotLoc) continue;

                           let targetSlotItem = slotLoc.array[slotLoc.index];

                           // Check compatibility and space (only need space for 1)
                           if (!targetSlotItem || (targetSlotItem.type === dragItemType && targetSlotItem.count < dragItemMaxStack)) {
                               let actuallyAdded = 0;
                               if (!targetSlotItem) {
                                   slotLoc.array[slotLoc.index] = { type: dragItemType, count: 1 };
                                   actuallyAdded = 1;
                               } else { // targetSlotItem exists, is compatible, and has space
                                   targetSlotItem.count++;
                                   actuallyAdded = 1;
                               }

                               if (actuallyAdded === 1) {
                                   itemsDistributed++;
                                   // Use setSlotData AFTER modifying array
                                   setSlotData(slotIndex, slotLoc.array[slotLoc.index]);
                                  // console.log(`Slot ${slotIndex}: Added 1.`);
                               }
                           } else {
                               // console.log(`Slot ${slotIndex}: Incompatible or full for adding 1.`);
                           }
                       } // End loop for right drag
                   }
                   // --- End Distribution Logic ---

                   // Update cursor count based on actual items placed
                   if (itemOnCursor) { // Check again as it might become null
                       itemOnCursor.count -= itemsDistributed;
                       if (itemOnCursor.count <= 0) {
                           itemOnCursor = null; // Clear cursor if empty
                       }
                       // console.log("Cursor left with:", itemOnCursor?.count ?? 0);
                   }
               } // End if itemOnCursor and dragSlots > 0

               // Reset dragging state regardless of outcome
               isDragging = false;
               dragButton = -1;
               dragSlots = [];
               dragItemType = null;
               updateInventoryUI(); // Final UI update after drag finishes
           }
            // --- ^ ^ ^ Handle End of Inventory Drag ^ ^ ^ ---
           // Reset drag state if mouse button released doesn't match the drag button (e.g., started with left, released right)
           else if (isDragging && e.button !== dragButton) {
               console.log(`Drag cancelled - wrong button released (Started: ${dragButton}, Released: ${e.button})`);
               isDragging = false;
               dragButton = -1;
               dragSlots = [];
               dragItemType = null;
               // No UI update needed usually, as nothing changed
           }
       });
       // --- END: FULLY REVISED mouseup LISTENER (Drag part) ---
        // Prevent context menu on the inventory screens
       document.getElementById('full-inventory-screen').addEventListener('contextmenu', e => e.preventDefault());
       document.getElementById('crafting-table-screen').addEventListener('contextmenu', e => e.preventDefault());

      // --- Animation Loop ---
      let lastFrameTime;
      const chunkUpdateInterval = 100;
      let lastChunkUpdateTime = 0;
      let fps = 0;
      let startMeasureFps = true;
      let triggeredMeasure = false;
      let timeStart = new Date();
      let previousIsSneaking = false;
      function animate(currentTime) {
        const now = performance.now();
        if (lastFrameTime === undefined) {
          lastFrameTime = now;
        }
        const deltaTime = (now - lastFrameTime) / 1000.0; // time in seconds
        lastFrameTime = now;
        const clampedDeltaTime = Math.min(deltaTime, 0.1); // Prevent large jumps

        const previousCameraY = camera.position.y;

        // --- Update player stance based on shift key ---
        updatePlayerStance()

        if (keys.shift !== previousIsSneaking) {
        if (keys.shift) { // Just started sneaking
            // Player is now shorter, eyes are lower.
            // To keep feet at same spot, camera (eyes) must move down by the difference in eye levels.
            const eyeLevelDifference = PLAYER_STANDING_EYE_LEVEL_OFFSET - PLAYER_SNEAKING_EYE_LEVEL_OFFSET;
            camera.position.y -= eyeLevelDifference;
            // console.log("Started sneaking, lowered camera by", eyeLevelDifference);
        } else { // Just stopped sneaking
            // Player is now taller, eyes are higher.
            // To keep feet at same spot, camera (eyes) must move up.
            const eyeLevelDifference = PLAYER_STANDING_EYE_LEVEL_OFFSET - PLAYER_SNEAKING_EYE_LEVEL_OFFSET;
            camera.position.y += eyeLevelDifference;
            // console.log("Stopped sneaking, raised camera by", eyeLevelDifference);

            // TODO: Add a check here to prevent standing up into a block.
            // If standing up would cause collision with a block above,
            // force player to remain sneaking or push them out.
            // This is a more complex collision check. For now, it might clip.
        }
    }
    previousIsSneaking = keys.shift;


        // --- Handle Player Updates ---
        if (
          !isInventoryOpen &&
          !isCraftingTableOpen && // Added check
          document.pointerLockElement === renderer.domElement
        ) {
          // Pass deltaTime to updateCameraPosition
          updateCameraPosition(clampedDeltaTime);

          // Block highlighting / Indicator Cube logic
          mouse.x = 0;
          mouse.y = 0;
          raycaster.setFromCamera(mouse, camera);
          const inter = findBlockIntersection(raycaster.ray);
          if (inter) {
            const bp = inter.blockPos;
            indicatorCube.position.set(bp.x + 0.5, bp.y + 0.5, bp.z + 0.5);
            indicatorCube.visible = true;
          } else {
            indicatorCube.visible = false;
          }

          // Block Breaking logic
          updateBreaking(clampedDeltaTime);

        } else {
            // Reset breaking state if focus lost or inventory open
             if (isBreaking) {
                isBreaking = false;
                currentBreakingTarget = null;
                breakProgress = 0;
                breakStartTime = 0;
                indicatorCube.visible = false; // Also hide indicator
             }

            // *** NEW: Apply damping even when inventory is open/pointer lost ***
            // This prevents sliding indefinitely if you open inventory while moving
            playerVelocity.multiplyScalar(dampingFactor);
               // Optional: Stop if very slow
              if (playerVelocity.lengthSq() < stopThreshold * stopThreshold) {
                 playerVelocity.set(0, 0, 0);
               }
            // *** END NEW ***
        }


        // Handle chunk loading/unloading based on player movement
        // (Keep your existing logic here, potentially passing camera.position if needed)
        if (
          chunksNeedUpdate ||
          now - lastChunkUpdateTime > chunkUpdateInterval
        ) {
          /*
          for(let cx = -RENDER_DISTANCE; cx <= RENDER_DISTANCE; cx++) {
            for(let cz = -RENDER_DISTANCE; cz <= RENDER_DISTANCE; cz++) {
              const chunkX = lastPlayerChunkX + cx;
              worker2.postMessage(["updateChunks", {chunkId: -2}]);
              worker.postMessage(["updateChunks", {chunkId: -1}]);
              worker3.postMessage(["updateChunks", {chunkId: 0}]);
              worker4.postMessage(["updateChunks", {chunkId: 1}]);
              worker5.postMessage(["updateChunks", {chunkId: 2}]);
            }
          }
            */
           socket.emit("updateChunks");
          lastChunkUpdateTime = now;
        }

        if(startMeasureFps) {
          fps++
          if(!triggeredMeasure) {
          setTimeout(() => {
              startMeasureFps = false;
              console.log(`fps: ${fps}`)
              setTimeout(() => {
                  startMeasureFps = true;
                  triggeredMeasure = false;
                  fps = 0;
              }, 1000)
          }, 1000)
        }
        triggeredMeasure = true;
        }

        collisionTick()

        renderer.render(scene, camera);
        

        //new fps measurer
        //nah, it's bad. Not accurate
        /*
        fps++
        if(!triggeredMeasure) {
          triggeredMeasure = true;
          timeStart = timeStart.getTime();
        }
        let currentTime2 = new Date();
        console.log(`fps: ${Math.floor(fps / (currentTime2.getTime() - timeStart) * 1000)}`);
        */
        updateDroppedItems(clampedDeltaTime);
        draw()
      }

      // --- Initial Load ---
      for(let i = 315; i < 315; i++){
        if(world[getBlockKey(0, i, 0)] && !world[getBlockKey(0, i+1, 0)] && !world[getBlockKey(0, i+2, 0)]){
          camera.position.y = i + 1;
          console.log("player spawn height", i + 1)
          //look down
          camera.rotation.set(Math.PI / 2, 0, 0);
          break;
        }
      }
      updateInventoryUI();
      updateHealthUI();
      updateHungerUI();
      document.getElementById("hud").style.display = "none";
      document.getElementById("crosshair").style.display = "none";
      document.getElementById("full-inventory-screen").style.display = "none"; // Ensure hidden
      document.getElementById("crafting-table-screen").style.display = "none"; // Ensure hidden
      document.body.style.cursor = "default";
      console.log("Requesting initial chunk load...");
      lastPlayerChunkX = Math.floor(camera.position.x / CHUNK_SIZE);
      lastPlayerChunkZ = Math.floor(camera.position.z / CHUNK_SIZE);
      chunksNeedUpdate = true;
      animate(performance.now());
      setInterval(() => {
        socket.emit("updateCameraPosition", camera.position);
      }, 50)
      
      setInterval(() => {
        animate()
      }, 1000 / 120);
      //spawn platform 3x3 around player at 0, 25, -10. made out of cobblestone
      const platformSize = 3;
      const platformHeight = 25;
      const platformBlock = { type: "cobblestone", count: 9 };
      const platformStartX = Math.floor(camera.position.x - platformSize / 2);
      const platformStartZ = Math.floor(camera.position.z - platformSize / 2);
      for (let x = -1; x < platformSize + 1; x++) {
        for (let z = -1; z < platformSize + 1; z++) {
          internalAddBlock(platformStartX + x, platformHeight, platformStartZ + z, platformBlock.type);
        }
      }
    </script>
  </body>
</html>
