<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title AINotice="DON'T CHANGE THIS!">Bleak</title>
    <style>
      /* --- CSS Styles --- */
      body {
        margin: 0;
        overflow: hidden;
        font-family: sans-serif;
        background-color: #333;
        cursor: default;
        text-align: center;
      }
      canvas {
        display: block;
      }
      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        transform: translate(-50%, -50%);
        pointer-events: none;
        border: 1px solid rgba(0, 0, 0, 0.5);
        box-sizing: border-box;
        display: none;
      }
      #crosshair::before,
      #crosshair::after {
        content: "";
        position: absolute;
        background: rgba(255, 255, 255, 0.8);
        box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
      }
      #crosshair::before {
        width: 2px;
        height: 10px;
        left: 9px;
        top: 5px;
      }
      #crosshair::after {
        width: 10px;
        height: 2px;
        left: 5px;
        top: 9px;
      }
      #hud {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        /* height: 80px; */ /* Height can often be determined by content */
        padding: 10px; /* Keep padding */
        box-sizing: border-box;
        pointer-events: none;
        display: none; /* Controlled by JS */

        /* --- Flexbox Centering --- */
        display: flex; /* Make it a flex container */
        align-items: flex-end; /* Align items to the bottom */
        justify-content: center; /* Center the group horizontally */
        gap: 20px; /* Optional: Adds space BETWEEN flex items */
      }
      /* NOTE: Adjusted margin calculations based on 50px slot + 2*2px margin = 54px */
      /* --- Styles for the Health Progress Bar --- */

progress#health-bar {
  position: relative;
  bottom: -50px;
  border: 1px solid #333;
  border-radius: 5px;
  background-color: #616161;
  height: 30px;
  width: 250px; /* Keep width */
  display: block;
  margin-bottom: 4px;
  box-sizing: border-box;
}

/* --- Style the unfilled track (Webkit) --- */
progress#health-bar::-webkit-progress-bar {
  background-color: #616161;
  border-radius: 2px;
}

/* --- Style the FILLED value bar (Webkit) --- */
progress#health-bar::-webkit-progress-value {
  background-color: #F44336; /* Red for health */
  border-radius: 2px;
  background-image: none;
  box-shadow: none;
  transition: width 0.2s ease-in-out;
}

/* --- Style the FILLED value bar (Firefox) --- */
progress#health-bar::-moz-progress-bar {
  background-color: #F44336; /* Red for health */
  border-radius: 2px;
  background-image: none;
  box-shadow: none;
  transition: width 0.1s ease-in-out;
}

/* --- REMOVE ALL old .heart styles --- */
/* .hud-icon.heart { ... } */
/* .heart::before { ... } */
/* etc. */
      #inventory-ui {
        display: flex;
        background-color: rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(100, 100, 100, 0.7);
        padding: 5px;
        box-sizing: border-box;
      }
      #hunger-bar {
        position: relative;
        right: 6em;
        display: flex;
        flex-direction: row-reverse;
        margin-right: calc(
          50% - (9 * 54px / 2) - 91px
        ); /* Center relative to hotbar */
      }
      .hud-icon {
        width: 18px;
        height: 18px;
        margin: 0 1px;
        background-size: cover;
        image-rendering: pixelated;
        position: relative;
      }
      .heart::before {
        content: "";
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: grey;
      }
      .heart.full::before {
        background-color: red;
      }
      .heart.half::before {
        background-color: pink;
      }
      .heart.empty::before {
        background-color: dimgrey;
      }
      .hunger::before {
        content: "";
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: sienna;
        border: 1px solid saddlebrown;
        box-sizing: border-box;
      }
      .hunger.full::before {
        background-color: peru;
      }
      .hunger.empty::before {
        background-color: dimgrey;
        border-color: black;
      }
      .inventory-slot {
        width: 50px;
        height: 50px;
        border: 2px solid rgba(200, 200, 200, 0.5);
        margin: 2px;
        background-color: rgba(50, 50, 50, 0.5);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        color: white;
        position: relative;
        user-select: none;
        box-sizing: border-box;
      }
      .inventory-slot.selected {
        border-color: white;
        box-shadow: 0 0 5px white;
      }
      .slot-item-name {
        text-transform: capitalize;
        margin-bottom: 3px;
        pointer-events: none;
      }
      .slot-item-count {
        position: absolute;
        bottom: 2px;
        right: 4px;
        font-size: 12px;
        font-weight: bold;
        text-shadow: 1px 1px 1px black;
        pointer-events: none;
      }
      #full-inventory-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: calc(9 * 54px + 20px);
        background-color: rgba(10, 10, 10, 0.85);
        border: 3px solid #555;
        border-radius: 5px;
        padding: 10px;
        box-sizing: border-box;
        display: none;
        flex-direction: column;
        align-items: center;
        pointer-events: auto;
      }
      #inventory-top-row {
        display: flex;
        justify-content: space-between;
        width: 100%;
        margin-bottom: 15px;
        align-items: flex-start;
      }
      #armor-slots-container {
        display: flex;
      }
      #armor-slots-container .inventory-slot {
        background-color: rgba(80, 80, 80, 0.6);
      }
      #crafting-area {
        display: flex;
        align-items: center;
      }
      #crafting-grid {
        display: grid;
        grid-template-columns: repeat(2, 54px);
        grid-template-rows: repeat(2, 54px);
        gap: 1px;
      }
      #crafting-area::after {
        content: "â†’";
        font-size: 24px;
        color: #ccc;
        margin: 0 10px;
      }
      #crafting-output-slot .inventory-slot {
        background-color: rgba(70, 70, 100, 0.6);
      }
      #storage-inventory-container {
        display: grid;
        grid-template-columns: repeat(9, 54px);
        gap: 1px;
        margin-bottom: 10px;
      }
      #hotbar-inventory-container {
        position: absolute;
        left: 800px;
        display: grid;
        grid-template-columns: repeat(9, 54px);
        gap: 1px;
        margin-top: 5px;
        border-top: 1px solid #444;
        padding-top: 10px;
      }
      #item-on-cursor-display {
        position: absolute;
        width: 50px;
        height: 50px;
        background-color: rgba(100, 100, 100, 0.7);
        border: 2px solid white;
        border-radius: 3px;
        display: none;
        pointer-events: none;
        z-index: 1000;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        color: white;
        box-sizing: border-box;
      }
      #item-on-cursor-display .slot-item-name {
        position: static;
        text-shadow: 1px 1px 1px black;
      }
      #item-on-cursor-display .slot-item-count {
        position: absolute;
        bottom: 2px;
        right: 4px;
        text-shadow: 1px 1px 1px black;
      }
            /* --- Styles for Crafting Table Screen --- */
            #crafting-table-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        /* Width: 3 grid slots + padding + arrow + output + padding */
        width: calc(3 * 54px + 2 * 10px + 30px + 54px + 10px);
        background-color: rgba(10, 10, 10, 0.85);
        border: 3px solid #555;
        border-radius: 5px;
        padding: 10px;
        box-sizing: border-box;
        display: none; /* Initially hidden */
        flex-direction: column;
        align-items: center;
        pointer-events: auto;
      }

      #crafting-table-main-area {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
        width: 100%;
        justify-content: center; /* Center grid/arrow/output */
      }

      #crafting-table-label {
          position: absolute;
          top: 10px;
          left: 15px;
          color: #ccc;
          font-size: 14px;
      }


      #crafting-table-grid {
        display: grid;
        grid-template-columns: repeat(3, 54px);
        grid-template-rows: repeat(3, 54px);
        gap: 1px;
        margin-right: 10px; /* Space before arrow */
      }

      #crafting-table-arrow {
          font-size: 24px;
          color: #ccc;
          margin: 0 10px;
      }

      #crafting-table-output-slot .inventory-slot {
          background-color: rgba(70, 70, 100, 0.6);
      }

       /* Use specific IDs for storage/hotbar in CT screen */
      #storage-inventory-container-ct,
      #hotbar-inventory-container-ct {
        display: grid;
        grid-template-columns: repeat(9, 54px);
        gap: 1px;
      }
       #storage-inventory-container-ct {
           margin-bottom: 10px;
       }
       #hotbar-inventory-container-ct {
        margin-top: 5px;
        border-top: 1px solid #444;
        padding-top: 10px;
      }

       /* Rename old storage/hotbar container selectors */
       #storage-inventory-container-inv,
       #hotbar-inventory-container-inv {
        display: grid;
        grid-template-columns: repeat(9, 54px);
        gap: 1px;
       }
       #storage-inventory-container-inv {
            margin-bottom: 10px;
       }
       #hotbar-inventory-container-inv {
        margin-top: 5px;
        border-top: 1px solid #444;
        padding-top: 10px;
       }
       progress#airBubble{
        position: relative;
      bottom: -50px;
      border: 1px solid #333;
      border-radius: 5px;
      background-color: #616161;
      height: 30px;
      width: 250px;
      display: block;
      margin-bottom: 4px;
      box-sizing: border-box;
       }
       /* --- Styles for Furnace UI Screen --- */
#furnace-screen {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  /* Adjust width based on content.
     Approx: 3 slots wide + padding + progress indicators
     (54*3) + (2*2px margins per slot) + (some space for progress) + (2*padding) */
  width: calc(3 * 54px + 2 * 4px + 80px + 2 * 10px);
  background-color: rgba(10, 10, 10, 0.85); /* Dark background */
  border: 3px solid #555; /* Similar to other UIs */
  border-radius: 5px;
  padding: 10px;
  box-sizing: border-box;
  display: none; /* Initially hidden, controlled by JS */
  flex-direction: column;
  align-items: center;
  pointer-events: auto; /* Allow interaction */
  color: #ccc; /* Default text color */
}

#furnace-label {
  position: absolute;
  top: 10px;
  left: 15px;
  font-size: 14px;
  color: #ccc;
}

#furnace-main-area {
  display: flex;
  flex-direction: column; /* Stack input/fuel above progress/output */
  align-items: center;
  margin-bottom: 15px;
  width: 100%;
}

/* Styling for the row containing input/fuel and output */
.furnace-io-row {
    display: flex;
    justify-content: space-around; /* Or center, depending on layout */
    align-items: center;
    width: 100%; /* Or fit to content */
    margin-bottom: 8px;
}


/* Container for individual slots to help with layout if needed */
.inventory-slot-container {
  /* Uses .inventory-slot styles defined globally */
  margin: 5px; /* Spacing around slots */
}

#furnace-input-slot {
    margin-bottom: 20px; /* Space between input and fuel */
}
#furnace-fuel-slot {
    /* Styles for fuel slot if different */
    position: relative;
}

#furnace-output-slot.furnace-output-style .inventory-slot {
  /* Special styling for output slot if needed, similar to crafting output */
  background-color: rgba(70, 70, 100, 0.6);
  /* Larger size to stand out, maybe */
  /* width: 60px; height: 60px; */    
}

/* Progress Indicators Styling */
#furnace-progress-indicators {
  display: flex;
  align-items: center;
  justify-content: center; /* Center the progress items */
  height: 54px; /* Match slot height */
  margin: 5px 0; /* Space around progress indicators */
}

.furnace-progress-icon-container {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px; /* Width of the flame icon/bar */
    height: 30px; /* Height of the flame icon/bar */
    margin: 0 10px; /* Space around fuel progress */
}

/* Fuel Burning Progress (flame) */
#furnace-fuel-progress {
  width: 16px;  /* Width of the flame image/bar */
  height: 16px; /* Height of the flame image/bar */
  background-image: url('path/to/your/empty_flame_icon.png'); /* Empty flame icon */
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center bottom; /* Fill from bottom up */
  position: relative; /* For the fill element */
}

#furnace-fuel-progress .furnace-progress-bar-fill.fuel-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 0%; /* Initially 0%, JS will change this to 0-100% */
  background-image: url('path/to/your/filled_flame_icon.png'); /* Filled flame icon */
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center bottom;
  transition: height 0.1s linear; /* Smooth fill */
}


/* Smelting Progress Arrow */
.furnace-arrow-container {
  width: 24px;  /* Width of the arrow */
  height: 18px; /* Height of the arrow */
  position: relative; /* For positioning the progress arrow on top */
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px; /* Size of the arrow character */
  margin: 0 10px; /* Space around arrow */
}

#furnace-smelting-arrow-background {
  color: #555; /* Dark grey for the background arrow */
  position: absolute;
}

#furnace-smelting-arrow-progress {
  color: #999; /* Lighter grey or white for the progress arrow */
  position: absolute;
  overflow: hidden; /* Important for the fill effect */
  width: 0%; /* Initially 0%, JS changes this to 0-100% */
  white-space: nowrap; /* Keep arrow on one line */
  transition: width 0.1s linear; /* Smooth fill */
}


/* Shared styles for mirrored inventory/hotbar containers in furnace UI */
#storage-inventory-container-furnace,
#hotbar-inventory-container-furnace {
  display: grid;
  grid-template-columns: repeat(9, 54px); /* Matches your main inventory */
  gap: 1px; /* Matches your main inventory */
}

#storage-inventory-container-furnace {
  margin-bottom: 10px;
}

#hotbar-inventory-container-furnace {
  margin-top: 5px;
  border-top: 1px solid #444;
  padding-top: 10px;
}
 #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111;
            color: #eee;
            display: flex; /* Use flex to show it */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            font-family: monospace;
            font-size: 1.5em;
        }

        #loading-text {
            margin-top: 20px;
        }

        .spinner {
            border: 8px solid #f3f3f333; /* Light grey */
            border-top: 8px solid #eee; /* White */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1.5s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
  </head>
  <body>
        <div id="loading-screen">
        <div class="spinner"></div>
        <p id="loading-text">Connecting to Server...</p>
    </div>
    <div id="crosshair"></div>
    <div id="hud">
      <progress id="airBubble" value="10" max="10"></progress>
      <progress id="health-bar" value="20" max="20">test</progress>
      <div id="hunger-bar"></div>
      <div id="inventory-ui"></div>
    </div>
    <div id="full-inventory-screen">
      <div id="inventory-top-row">
        <div id="armor-slots-container"></div>
        <div id="crafting-area">
          <div id="crafting-grid"></div>
          <div id="crafting-output-slot"></div>
        </div>
      </div>
      <div id="storage-inventory-container-inv"></div>
      <div id="hotbar-inventory-container-inv"></div>
    </div>
    <div id="item-on-cursor-display"></div>
</div>
<div id="item-on-cursor-display"></div>
<div id="crafting-table-screen">
  <div id="crafting-table-main-area">
      <div id="crafting-table-label">Crafting</div>
      <div id="crafting-table-grid"></div>
      <div id="crafting-table-arrow">â†’</div>
      <div id="crafting-table-output-slot"></div>
  </div>
  <div id="storage-inventory-container-ct"></div> <!-- Separate container for CT screen -->
  <div id="hotbar-inventory-container-ct"></div> <!-- Separate container for CT screen -->
</div>
<div id="furnace-screen">
  <div id="furnace-label">Furnace</div>

  <div id="furnace-main-area">
      <!-- Input Slot -->
      <div id="furnace-input-slot" class="inventory-slot-container">
          <!-- The actual .inventory-slot will be dynamically generated by JS -->
      </div>

      <!-- Fuel Slot -->
      <div id="furnace-fuel-slot" class="inventory-slot-container">
          <!-- The actual .inventory-slot will be dynamically generated by JS -->
      </div>

      <!-- Progress Indicators -->
      <div id="furnace-progress-indicators">
          <div class="furnace-progress-icon-container">
              <!-- Fuel Burning Progress (e.g., a flame icon) -->
              <div id="furnace-fuel-progress" class="furnace-progress-bar">
                  <div class="furnace-progress-bar-fill fuel-fill"></div>
              </div>
          </div>

          <div class="furnace-arrow-container">
              <!-- Smelting Progress Arrow -->
              <span id="furnace-smelting-arrow-background">â†’</span> <!-- Background arrow (always visible) -->
              <span id="furnace-smelting-arrow-progress">â†’</span>  <!-- Foreground arrow (fills up) -->
          </div>
      </div>

      <!-- Output Slot -->
      <div id="furnace-output-slot" class="inventory-slot-container furnace-output-style">
          <!-- The actual .inventory-slot will be dynamically generated by JS -->
      </div>
  </div>

  <!-- Inventory and Hotbar (mirrored from main inventory) -->
  <div id="storage-inventory-container-furnace" class="inventory-grid-container">
      <!-- Populated by JS -->
  </div>
  <div id="hotbar-inventory-container-furnace" class="inventory-grid-container">
      <!-- Populated by JS -->
  </div>
</div>
<!-- END: New Crafting Table Screen -->
<script src="three.js"></script>
<script>
  const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
</script>
<script src="db.js"></script>
<script>
        setTimeout(() => {
        saveUnloadedBlocks(world)
      }, 3000)
</script>
<script src="GLTFLoader.js"></script>
<script src="holdItemAnimation.js"></script>
<script src="/socket.io/socket.io.js"></script>

<script>function hasSolidBlock(x, y, z) {

  const key = getBlockKey(x, y, z);
  return world[key]?.solid === true;
}</script>
<script src="mobs.js"></script>
<script>
  const textureLoader = new THREE.TextureLoader();
const textures = {
    grass: {
      side: textureLoader.load("/textures/testgrassblock_side.png"),
      top: textureLoader.load("/textures/testgrassblock.png"),
      bottom: textureLoader.load("/textures/dirt.png"),
    },
    leaves: { all: textureLoader.load("/textures/leaves.png") },
    log: {
      side: textureLoader.load("/textures/oak_log.png"),
      top: textureLoader.load("/textures/oak_log_top.png"),
      bottom: textureLoader.load("/textures/oak_log_top.png"),
    },
    dirt: { all: textureLoader.load("/textures/dirt.png") },
    stone: { all: textureLoader.load("/textures/stone.png") },
    plank: { all: textureLoader.load("/textures/planks.png") }, 
    craftingtable: {
        side: textureLoader.load("/textures/craftingtable_side.png"),
        top: textureLoader.load("/textures/craftingtable_top.png"),
        bottom: textureLoader.load("/textures/planks.png"),
    },
    furnace: {
      front: textureLoader.load("/textures/furnace_front.png"),
      top: textureLoader.load("/textures/furnace_top.png"),
      bottom: textureLoader.load("/textures/cobblestone.png"),
      side: textureLoader.load("/textures/furnace_side.png"),
    },
    cobblestone: { all: textureLoader.load("/textures/cobblestone.png") },
    stick: { all: null }, 
    wooden_pickaxe: { all: textureLoader.load("/textures/wooden_pickaxe.png") },
    wooden_axe: { all: null },
    wooden_shovel: { all: null },
    wooden_sword: { all: null },
    coal_ore: { all: textureLoader.load("/textures/coal_ore.png") },
    oxidized_iron_ore: { all: textureLoader.load("/textures/iron_ore.png") },
    water: { all: textureLoader.load("/textures/water.png") },
    bedrock: { all: textureLoader.load("/textures/bedrock.png") },
    landmine: { all: textureLoader.load("/textures/moss_block.png") },
  };
  Object.values(textures).forEach((t) =>
    Object.values(t).forEach((tex) => {
      if (tex instanceof THREE.Texture) {
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
      }
    })
  );

  const materials = {
    grass: {
      side: new THREE.MeshLambertMaterial({ map: textures.grass.side }),
      top: new THREE.MeshLambertMaterial({ map: textures.grass.top }),
      bottom: new THREE.MeshLambertMaterial({ map: textures.grass.bottom }),
    },
    leaves: {
      all: new THREE.MeshLambertMaterial({
        map: textures.leaves.all,
        transparent: true,
        alphaTest: 0.1,
        side: THREE.DoubleSide,
      }),
    },
    log: {
      side: new THREE.MeshLambertMaterial({ map: textures.log.side }),
      top: new THREE.MeshLambertMaterial({ map: textures.log.top }),
      bottom: new THREE.MeshLambertMaterial({ map: textures.log.bottom }),
    },
    dirt: { 
      all: new THREE.MeshLambertMaterial({ map: textures.dirt.all }),
    },
    stone: {
      all: new THREE.MeshLambertMaterial({ map: textures.stone.all }),
    },
    bedrock: {
      all: new THREE.MeshLambertMaterial({ map: textures.bedrock.all }),
    },
    plank: {
      all: new THREE.MeshLambertMaterial({ map: textures.plank.all }),
    },
    craftingtable: {
        side: new THREE.MeshLambertMaterial({ map: textures.craftingtable.side }),
        top: new THREE.MeshLambertMaterial({ map: textures.craftingtable.top }),
        bottom: new THREE.MeshLambertMaterial({ map: textures.craftingtable.bottom }),
    },
    furnace: {
        front: new THREE.MeshLambertMaterial({ map: textures.furnace.front }),
        top: new THREE.MeshLambertMaterial({ map: textures.furnace.top }),
        bottom: new THREE.MeshLambertMaterial({ map: textures.furnace.bottom }),
        side: new THREE.MeshLambertMaterial({ map: textures.furnace.side }),
    },
    cobblestone: { all: new THREE.MeshLambertMaterial({ map: textures.cobblestone.all }) },
    coal_ore: { all: new THREE.MeshLambertMaterial({ map: textures.coal_ore.all }) },
    oxidized_iron_ore: { all: new THREE.MeshLambertMaterial({ map: textures.oxidized_iron_ore.all }) },
    water: { all: new THREE.MeshLambertMaterial({
       map: textures.water.all,
        transparent: true,
        opacity: 0.5,
      }) 
    },
    landmine: { all: new THREE.MeshLambertMaterial({ map: textures.landmine.all }) },
    wooden_pickaxe: { all: new THREE.MeshBasicMaterial({ map: textures.wooden_pickaxe.all }) },
    cave_air_all: { all: null }, 
  };
  

</script>
<script src="breaking.js"></script>
    <script defer>
      let currentDimension = 'overworld'
      const OVERWORLD_GRAVITY = 0.0025; 
      const SPACE_GRAVITY = 0.0005;
      let gravity = (currentDimension === 'space') ? SPACE_GRAVITY : OVERWORLD_GRAVITY;
      let verticalVelocity = 0;
      let isOnGround = false;
      let jumpHeight = 0.085;

      const mobs = new Map();
      const projectiles = [];

      let droppedItems = [];
      const ITEM_LIFESPAN = 5 * 60 * 1000; 
      const ITEM_PICKUP_RADIUS = 1.5;
      const ITEM_GRAVITY = 0.002;
      const ITEM_BOUNCE_FACTOR = -0.4;

      const worker = new Worker('chunkWorker.js');
      const worker2 = new Worker('chunkWorkerNew.js');
      const workers = [worker];
      const newWorkers = [worker2]
      const socket = io()
const meshCreationQueue = [];
const materialMap = new Map();
function addMaterialToMap(id, material) {
    
    if (material && material instanceof THREE.Material) {
        materialMap.set(id, material);
    } else {
        
        if (material !== null) {
           console.warn(`MainThread: Attempted to map invalid material for ID: ${id}`);
        }
    }
}



addMaterialToMap('grass_top', materials.grass.top);
addMaterialToMap('grass_bottom', materials.grass.bottom);
addMaterialToMap('grass_side', materials.grass.side);
addMaterialToMap('log_top', materials.log.top); 
addMaterialToMap('log_side', materials.log.side);
addMaterialToMap('leaves_all', materials.leaves.all);
addMaterialToMap('dirt_all', materials.dirt.all);
addMaterialToMap('stone_all', materials.stone.all);
addMaterialToMap('plank_all', materials.plank.all);
addMaterialToMap('craftingtable_top', materials.craftingtable.top);
addMaterialToMap('craftingtable_bottom', materials.craftingtable.bottom);
addMaterialToMap('craftingtable_side', materials.craftingtable.side);
addMaterialToMap('cobblestone_all', materials.cobblestone.all);
addMaterialToMap('coal_ore_all', materials.coal_ore.all);
addMaterialToMap('oxidized_iron_ore_all', materials.oxidized_iron_ore.all);
addMaterialToMap('water_all', materials.water.all);
addMaterialToMap('bedrock_all', materials.bedrock.all);
addMaterialToMap('wooden_pickaxe_all', materials.wooden_pickaxe.all);
addMaterialToMap('furnace_front', materials.furnace.front);
addMaterialToMap('furnace_top', materials.furnace.top);
addMaterialToMap('furnace_bottom', materials.furnace.bottom);
addMaterialToMap('furnace_side', materials.furnace.side);
addMaterialToMap('cave_air_all', materials.cave_air_all.all);
addMaterialToMap('landmine_all', materials.landmine.all);
addMaterialToMap('landmine_all', materials.landmine.all);




const experimental = true;
let chunksMax = 25;
const indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
indexedDB.deleteDatabase("worldDB");
let worldDB = indexedDB.open("worldDB", 1);

worldDB.onupgradeneeded = function(event) {
  const db = event.target.result;
  db.createObjectStore("world", { keyPath: "id" });
};

worldDB.onsuccess = function(event) {
  const db = event.target.result;
  console.log("World DB opened successfully.");
};

function disposeChunkMeshes2(chunk) {
  
  
  if (chunk) {
      removeChunkBlocksFromClientMemory(chunk);
  }

  let needsToRedo = false;
  let meshesRemoved = 0;
    if (chunk && chunk.meshes) { 
        chunk.meshes.forEach((mesh) => {
                 scene.remove(mesh);
                  if(!mesh.isInstancedMesh){
                    mesh = scene.getObjectByName(`chunk_${chunk.id}_mesh_${mesh.faceName}_${mesh.material}`);
                    scene.remove(mesh)
                  }
                 if(scene.children.includes(mesh)){
                    console.warn("Failed to remove mesh from scene:", mesh.name);
                 }
                 else{
                  meshesRemoved++;
                 }
        });
        
        
        if (chunks.has(chunk.id)) {
            chunks.get(chunk.id).meshes.clear();
        }
  }
  else{
    
    
  }
}



function setChunkMeshesVisibility(chunk, isVisible) {
    if (chunk && chunk.meshes) {
        chunk.meshes.forEach(mesh => {
            mesh.visible = isVisible;
        });
    }
}

const occlusionRaycaster = new THREE.Raycaster();
const cameraDirection = new THREE.Vector3();
const chunkCenter = new THREE.Vector3();

function updateChunkVisibility() {
    
    
    

    camera.getWorldDirection(cameraDirection);

    const sortedChunks = [];
    chunks.forEach(chunk => {
        
        if (chunk.state === ChunkState.Active && chunk.meshes && chunk.meshes.size > 0) {
            const { wx, wz } = chunkToWorldCoords(chunk.cx, chunk.cz);
            
            chunkCenter.set(wx + CHUNK_SIZE / 2, camera.position.y, wz + CHUNK_SIZE / 2);
            
            
            const distance = camera.position.distanceTo(chunkCenter);
            
            
            const cameraToChunk = chunkCenter.clone().sub(camera.position).normalize();
            
            
            const dot = cameraDirection.dot(cameraToChunk);

            if (dot > -0.2) { 
                 sortedChunks.push({ chunk, distance });
            } else {
                 
                 
                 setChunkMeshesVisibility(chunk, true);
            }
        }
    });

    
    sortedChunks.sort((a, b) => a.distance - b.distance);

    const potentialOccluders = [];

    
    for (let i = 0; i < sortedChunks.length; i++) {
        const entry = sortedChunks[i];
        const { chunk, distance } = entry;

        
        
        const occlusionThreshold = (RENDER_DISTANCE - 1) * CHUNK_SIZE;

        if (distance < occlusionThreshold) {
            
            
            setChunkMeshesVisibility(chunk, true);
            if (chunk.meshes) {
                chunk.meshes.forEach(mesh => potentialOccluders.push(mesh));
            }
            continue;
        }

        
        const { wx, wz } = chunkToWorldCoords(chunk.cx, chunk.cz);
        const targetPos = new THREE.Vector3(
            wx + CHUNK_SIZE / 2,
            camera.position.y, 
            wz + CHUNK_SIZE / 2
        );

        occlusionRaycaster.set(camera.position, targetPos.sub(camera.position).normalize());
        
        
        const intersections = occlusionRaycaster.intersectObjects(potentialOccluders);

        let isOccluded = false;
        if (intersections.length > 0) {
            
            const firstHitDistance = intersections[0].distance;
            if (firstHitDistance < distance) {
                isOccluded = true;
            }
        }

        
        setChunkMeshesVisibility(chunk, !isOccluded);
    }
}
socket.on('spawnMobs', (mobsData) => {
        const mobGeometry = new THREE.BoxGeometry(1, 1, 1);
        const mobMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red turrets

        mobsData.forEach(mobData => {
            if (!mobs.has(mobData.id)) {
                const mobMesh = new THREE.Mesh(mobGeometry, mobMaterial);
                mobMesh.position.set(mobData.position.x, mobData.position.y, mobData.position.z);
                scene.add(mobMesh);
                mobs.set(mobData.id, { data: mobData, mesh: mobMesh });
            }
        });
    });

    socket.on('fireProjectile', (data) => {
        const projGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const projMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow bolt
        const projectileMesh = new THREE.Mesh(projGeometry, projMaterial);

        const start = new THREE.Vector3(data.start.x, data.start.y, data.start.z);
        const end = new THREE.Vector3(data.end.x, data.end.y, data.end.z);

        projectileMesh.position.copy(start);
        scene.add(projectileMesh);

        projectiles.push({
            mesh: projectileMesh,
            start: start,
            end: end,
            startTime: performance.now(),
            duration: 300 // Must match server-side delay
        });
    });

    socket.on('playerHit', (data) => {
    // This reuses your existing damage function
    applyDamage(data.damage, data.source);

    // Apply knockback if direction is provided
    if (data.direction) {
        const knockbackForce = 2.0; // How strong the knockback is
        
        // Add impulse to the player's velocity
        playerVelocity.x += data.direction.x * knockbackForce;
        playerVelocity.z += data.direction.z * knockbackForce;

        // Optional: add a small upward knockback
        if (verticalVelocity < 0.05) { // Only if not already jumping high
             verticalVelocity += 0.05;
        }
    }
  });
socket.on('connect', () => {
    console.log("Connected to server!");
    showLoadingScreen("Loading World...");
});
  socket.on('mobDied', (mobId) => {
      const mob = mobs.get(mobId);
      if (mob) {
          scene.remove(mob.mesh);
          mob.mesh.geometry.dispose();
          mob.mesh.material.dispose();
          mobs.delete(mobId);
          console.log(`Removed mob ${mobId} from scene.`);
      }
  });
socket.on("chunkMeshData", data => {
  meshCreationQueue.push(data);
})
    socket.on("chunkMeshEmpty", data => {
        const { chunkId } = data;
        const chunk = chunks.get(chunkId);
        console.log(chunk)
        if (chunk) {
            
            disposeChunkMeshes2(chunk);    
            console.log("attempted to remove mesh")
            chunk.state = ChunkState.Active; 
        }
    })
    socket.on('chunkDataLoaded', data => {
        const { cx, cz, blocks } = data;
        const chunkId = getChunkId(cx, cz);
        let chunk = chunks.get(chunkId);
        console.log("chunkDataLoaded received")
        
        if (!chunk) {
            chunks.set(chunkId, {
                id: chunkId,
                state: ChunkState.LoadingData, 
                meshes: new Map(),
            });
            chunk = chunks.get(chunkId);
        }
        else if(chunk.state !== ChunkState.LoadingData){
          chunk.state = ChunkState.LoadingData
        }
        if (chunk.state !== ChunkState.LoadingData) {
             console.warn(`MainThread: Received block data for chunk ${chunkId} but its state is ${chunk.state}. Ignoring.`);
             return;
        }

        
        if (blocks) {
            
            Object.assign(world, blocks);
            
        } else {
             console.warn(`MainThread: Received 'chunkDataLoaded' for ${chunkId} but 'blocks' data was missing.`);
        }

        
        chunk.state = ChunkState.DataLoaded;

        
        
        chunksNeedUpdate = true;

    })
    socket.on("disposeChunkMesh", data => {
      const chunk = chunks.get(data);
      disposeChunkMeshes2(chunk);
    })
    socket.on('forcePlayerState', (data) => {
    console.log(`Received force state from server. New dimension: ${data.dimension}`);

    isPlayerFrozen = true;
    gravity = 0.0005;
    showLoadingScreen("Teleporting...");

    currentDimension = data.dimension;

    
    chunks.forEach(chunk => {
        disposeChunkMeshes2(chunk); 
    });
    chunks.clear();
    world = {}; 

    
    camera.position.set(data.position.x, data.position.y, data.position.z);
    
    

    
    if (data.dimension === 'space') {
        scene.background = new THREE.Color(0x000010); 
        scene.fog.color.set(0x000010);
        scene.fog.far = 2000; 
    } else {
        
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog.color.set(0x87ceeb);
        scene.fog.far = RENDER_DISTANCE * CHUNK_SIZE;
    }

    
    chunksNeedUpdate = true;
    updateChunks(); 
});
    </script>
        <!-- === START: SIMPLEX NOISE Code === -->
        <script>
            class SimplexNoise {
                /**
                 * Creates a new SimplexNoise instance.
                 * @param {number|string} [seed] - Optional seed for the random number generator. If not provided, Math.random() is used.
                 */
                constructor(seed) {
                    
                    this.random = (function (seedStr) {
                        let seed = 1; 
                        if (typeof seedStr === 'string') {
                            seed = 0;
                            for (let i = 0; i < seedStr.length; i++) {
                                seed = (seed * 31 + seedStr.charCodeAt(i)) | 0; 
                            }
                        } else if (typeof seedStr === 'number') {
                            seed = seedStr;
                        } else if (seed === undefined) {
                            seed = Math.floor(Math.random() * 0xFFFFFFFF);
                        }
                        seed = (seed === 0) ? 1 : seed | 0; 
      
                        return function () {
                            let t = seed += 0x6D2B79F5;
                            t = Math.imul(t ^ t >>> 15, t | 1);
                            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                            return ((t ^ t >>> 14) >>> 0) / 4294967296; 
                        };
                    })(seed);
      
                    
                    this.p = new Uint8Array(256);
                    for (let i = 0; i < 256; i++) { this.p[i] = i; }
                    for (let i = 255; i > 0; i--) {
                        const j = Math.floor(this.random() * (i + 1));
                        [this.p[i], this.p[j]] = [this.p[j], this.p[i]]; 
                    }
                    this.perm = new Uint8Array(512);
                    this.permMod12 = new Uint8Array(512);
                    for (let i = 0; i < 512; i++) {
                        this.perm[i] = this.p[i & 255];
                        this.permMod12[i] = this.perm[i] % 12;
                    }
      
                    
                    this.F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                    this.G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
                    this.F3 = 1.0 / 3.0;
                    this.G3 = 1.0 / 6.0;
                    this.grad3 = [
                        [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
                        [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
                        [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
                    ];
                    this.grad2 = [
                         [1, 0], [-1, 0], [0, 1], [0, -1],
                         [1, 1], [-1, 1], [1, -1], [-1, -1]
                    ];
                }
      
                dot(g, x, y) { return g[0] * x + g[1] * y; }
                dot3(g, x, y, z) { return g[0] * x + g[1] * y + g[2] * z; }
      
                noise2D(xin, yin) {
                    let n0, n1, n2;
                    const s = (xin + yin) * this.F2;
                    const i = Math.floor(xin + s);
                    const j = Math.floor(yin + s);
                    const t = (i + j) * this.G2;
                    const X0 = i - t;
                    const Y0 = j - t;
                    const x0 = xin - X0;
                    const y0 = yin - Y0;
                    let i1, j1;
                    if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; }
                    const x1 = x0 - i1 + this.G2;
                    const y1 = y0 - j1 + this.G2;
                    const x2 = x0 - 1.0 + 2.0 * this.G2;
                    const y2 = y0 - 1.0 + 2.0 * this.G2;
                    const ii = i & 255;
                    const jj = j & 255;
                    const gi0 = this.perm[ii + this.perm[jj]] % this.grad2.length;
                    const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % this.grad2.length;
                    const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % this.grad2.length;
                    let t0 = 0.5 - x0 * x0 - y0 * y0;
                    if (t0 < 0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * this.dot(this.grad2[gi0], x0, y0); }
                    let t1 = 0.5 - x1 * x1 - y1 * y1;
                    if (t1 < 0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * this.dot(this.grad2[gi1], x1, y1); }
                    let t2 = 0.5 - x2 * x2 - y2 * y2;
                    if (t2 < 0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * this.dot(this.grad2[gi2], x2, y2); }
                    return 70.0 * (n0 + n1 + n2); 
                }
      
                noise3D(xin, yin, zin) {
                    let n0, n1, n2, n3;
                    const s = (xin + yin + zin) * this.F3;
                    const i = Math.floor(xin + s);
                    const j = Math.floor(yin + s);
                    const k = Math.floor(zin + s);
                    const t = (i + j + k) * this.G3;
                    const X0 = i - t; const Y0 = j - t; const Z0 = k - t;
                    const x0 = xin - X0; const y0 = yin - Y0; const z0 = zin - Z0;
                    let i1, j1, k1; let i2, j2, k2;
                    if (x0 >= y0) {
                        if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                        else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                        else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
                    } else {
                        if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
                        else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
                        else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                    }
                    const x1 = x0 - i1 + this.G3; const y1 = y0 - j1 + this.G3; const z1 = z0 - k1 + this.G3;
                    const x2 = x0 - i2 + 2.0 * this.G3; const y2 = y0 - j2 + 2.0 * this.G3; const z2 = z0 - k2 + 2.0 * this.G3;
                    const x3 = x0 - 1.0 + 3.0 * this.G3; const y3 = y0 - 1.0 + 3.0 * this.G3; const z3 = z0 - 1.0 + 3.0 * this.G3;
                    const ii = i & 255; const jj = j & 255; const kk = k & 255;
                    const gi0 = this.permMod12[ii + this.perm[jj + this.perm[kk]]];
                    const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]];
                    const gi2 = this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]];
                    const gi3 = this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]];
                    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                    if (t0 < 0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0); }
                    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                    if (t1 < 0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1); }
                    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                    if (t2 < 0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2); }
                    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                    if (t3 < 0) n3 = 0.0; else { t3 *= t3; n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3); }
                    return 32.0 * (n0 + n1 + n2 + n3); 
                }
            }
      
            /**
             * Generates 2D Fractal Brownian Motion (fBm) noise using a SimplexNoise instance.
             */
            function generateFractalNoise2D(simplex, x, y, octaves, persistence, lacunarity, initialFrequency = 0.5, initialAmplitude = 0.5) {
                let total = 0;
                let frequency = initialFrequency;
                let amplitude = initialAmplitude;
                let maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    total += simplex.noise2D(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }
                if (maxValue === 0) return 0;
                return total / maxValue; 
            }
            function generateFractalNoise3D(simplex, x, y, z, octaves, persistence, lacunarity, initialFrequency = 0.5, initialAmplitude = 0.5) {
                let total = 0;
                let frequency = initialFrequency;
                let amplitude = initialAmplitude;
                let maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    total += simplex.noise3D(x * frequency, y * frequency, z * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }
                if (maxValue === 0) return 0;
                return total / maxValue; 
            }
          </script>
          <!-- === END: SIMPLEX NOISE Code === -->

    <script>
      
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      scene.background = new THREE.Color("rgb(135, 206, 235)");
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      camera.position.y = 1000

      const loadingScreen = document.getElementById('loading-screen');
const loadingText = document.getElementById('loading-text');

let isPlayerFrozen = true;
      
      const indicatorGeometry = new THREE.BoxGeometry(1.01, 1.01, 1.01);
      const indicatorMaterial = new THREE.LineBasicMaterial({
        color: 0x000000,
        linewidth: 10,
      });
      const indicatorEdges = new THREE.EdgesGeometry(indicatorGeometry);
      const indicatorCube = new THREE.LineSegments(
        indicatorEdges,
        indicatorMaterial
      );
      indicatorCube.visible = false;
      scene.add(indicatorCube);
      const beaconLight = new THREE.PointLight(0xffffff, 1, 100);
      const beaconBeam = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1000, 1),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
      )
      beaconLight.position.set(Math.floor(Math.random() * (400 - 300) + 300), -30, Math.floor(Math.random() * (400 - 300) + 300)); 
      beaconBeam.position.set(beaconLight.position.x, beaconLight.position.y, beaconLight.position.z);
      scene.add(beaconLight);
      scene.add(beaconBeam);


      
      


const PLAYER_STANDING_HEIGHT = 1.8;
const PLAYER_STANDING_EYE_LEVEL_OFFSET = 1.62; 
const PLAYER_STANDING_COLLISION_HEIGHT = 1.78;
const PLAYER_WIDTH = 0.8; 


const PLAYER_SNEAKING_HEIGHT = 1.5; 
const PLAYER_SNEAKING_EYE_LEVEL_OFFSET = 1.35; 
const PLAYER_SNEAKING_COLLISION_HEIGHT = 1.48; 


let currentPlayerHeight = PLAYER_STANDING_HEIGHT;
let currentPlayerEyeLevelOffset = PLAYER_STANDING_EYE_LEVEL_OFFSET;
let currentPlayerCollisionHeight = PLAYER_STANDING_COLLISION_HEIGHT;


let playerFeetOffset = -currentPlayerEyeLevelOffset; 
let playerCollisionBottomOffset = -currentPlayerEyeLevelOffset; 
let playerCollisionTopOffset = playerFeetOffset + currentPlayerCollisionHeight; 




      camera.position.set(0, 60, 10);
      
      let playerHealth = 20;
      let playerMaxHealth = 20;
      let playerHunger = 31;
      let playerMaxHunger = 20;
      let isInventoryOpen = false;
      let fallDistance = 0;
      let wasOnGround = false; 

      
      const REGEN_HUNGER_THRESHOLD = 18; 
      const HEALTH_REGEN_INTERVAL = 4000; 
      const saturation_regen_interval = 1000 / 4;
      const HUNGER_COST_PER_REGEN = 1; 
      let timeSinceLastRegen = 0;

      let world = {}

      
      const CHUNK_SIZE = 16;
      const RENDER_DISTANCE = 2;
      const UNLOAD_DISTANCE = RENDER_DISTANCE + 1;
      let chunks = new Map();
      let lastPlayerChunkX = Infinity;
      let lastPlayerChunkZ = Infinity;
      let chunksNeedUpdate = true;

      
      const MAX_INSTANCES_PER_GEOMETRY_PER_CHUNK = 16 * 16 * 16;
      const faceGeometries = {};
      faceGeometries.right = new THREE.PlaneGeometry(1, 1)
        .rotateY(Math.PI / 2)
        .translate(0.5, 0, 0);
      faceGeometries.left = new THREE.PlaneGeometry(1, 1)
        .rotateY(-Math.PI / 2)
        .translate(-0.5, 0, 0);
      faceGeometries.top = new THREE.PlaneGeometry(1, 1)
        .rotateX(-Math.PI / 2)
        .translate(0, 0.5, 0);
      faceGeometries.bottom = new THREE.PlaneGeometry(1, 1)
        .rotateX(Math.PI / 2)
        .translate(0, -0.5, 0);
      faceGeometries.front = new THREE.PlaneGeometry(1, 1).translate(0, 0, 0.5);
      faceGeometries.back = new THREE.PlaneGeometry(1, 1)
        .rotateY(Math.PI)
        .translate(0, 0, -0.5);
      faceGeometries.right.name = "right";
      faceGeometries.left.name = "left";
      faceGeometries.top.name = "top";
      faceGeometries.bottom.name = "bottom";
      faceGeometries.front.name = "front";
      faceGeometries.back.name = "back";

      function worldToChunkCoords(worldX, worldZ) {
    const cx = Math.floor(worldX / CHUNK_SIZE);
    const cz = Math.floor(worldZ / CHUNK_SIZE);
    return { cx, cz };
  }
  const ChunkState = {
    Unknown: 0,
    LoadingData: 1,
    DataLoaded: 2,
    Meshing: 3,
    Active: 4,
    Inactive: 5,
    NeedsRemesh: 6,
  };
  function chunkToWorldCoords(chunkX, chunkZ) {
return { wx: chunkX * CHUNK_SIZE, wz: chunkZ * CHUNK_SIZE };
}
function getBlock(x, y, z) {
const key = getBlockKey(x, y, z);
const data = world[key];

return data ? { ...data, id: key, x: Math.floor(x), y: Math.floor(y), z: Math.floor(z) } : undefined;
}
function getBlockKey(x, y, z) {
return `${Math.floor(x)}_${Math.floor(y)}_${Math.floor(z)}`;
}
  function hasBlock(x, y, z) {
    return world[getBlockKey(x, y, z)] !== undefined;
  }

      let lightLevel = 0;
      let time = 3000;
      let state = "increase"
      const LOD = new THREE.LOD();
      let SCENE2 = new Set();

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.15);
      directionalLight.castShadow = true
      directionalLight.position.set(1, 1, 1);
      let ambientLight = new THREE.AmbientLight()
      ambientLight.color = new THREE.Color(0xffffff)
      ambientLight.intensity = 0.2
      scene.add(ambientLight)
      scene.add(directionalLight);

      
      const dummy = new THREE.Object3D();

      
      const DEFAULT_MAX_STACK_SIZE = 64;
      const HOTBAR_SIZE = 9;
      const STORAGE_SIZE = 27;
      const ARMOR_SIZE = 4;
      const CRAFTING_GRID_SIZE = 4; 
      const CRAFTING_TABLE_GRID_SIZE = 9; 
      let hotbar = Array(HOTBAR_SIZE).fill(null);
      let storage = Array(STORAGE_SIZE).fill(null);
      let armor = Array(ARMOR_SIZE).fill(null);
      let craftingGrid = Array(CRAFTING_GRID_SIZE).fill(null);
      let craftingOutput = null;
      let craftingTableGrid = Array(CRAFTING_TABLE_GRID_SIZE).fill(null); 
      let craftingTableOutput = null; 
      let selectedHotbarSlot = 0;
      let itemOnCursor = null;
      const itemOnCursorDisplay = document.getElementById(
        "item-on-cursor-display"
      );
      let isCraftingTableOpen = false; 
      let isFurnaceOpen = false;

      let isDragging = false; 
      let dragButton = -1
      let dragSlots = []; 
      let dragItemType = null; 
      const ITEM_MAX_STACK_SIZES = {
          'stone': 64,
          'cobblestone': 64,
          'dirt': 64,
          'grass': 64,
          'log': 64,
          'plank': 64,
          'stick': 64,
          'craftingtable': 64,
          'leaves': 64, 
          
          'wooden_pickaxe': 1,
          'wooden_sword': 1,
          'wooden_shovel': 1,
          'wooden_axe': 1,
          'coal_ore': 64,
          'oxidixed_iron_ore': 64,
      };

            
            function getItemMaxStackSize(itemType) {
          
          return ITEM_MAX_STACK_SIZES[itemType] || DEFAULT_MAX_STACK_SIZE;
      }
      

      
      function getBlockDisplayName(type) {
        return type || "";
      }
function createItemDrop(position, itemType) {
    
    if (itemType === 'air' || itemType === 'cave_air' || itemType === 'water') {
        return;
    }
    
    let itemTexture = textures.stone.all; 
    if (textures[itemType] && textures[itemType].all) {
        itemTexture = textures[itemType].all;
    } else if (textures[itemType] && textures[itemType].side) {
        
        itemTexture = textures[itemType].side;
    }

    
    const geometry = new THREE.PlaneGeometry(0.4, 0.4);
    const material = new THREE.MeshBasicMaterial({
        map: itemTexture,
        side: THREE.DoubleSide,
        transparent: true
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(position);
    scene.add(mesh);

    
    const itemEntity = {
        mesh: mesh,
        type: itemType,
        position: new THREE.Vector3(position.x, position.y, position.z),
        velocity: new THREE.Vector3((Math.random() - 0.5) * 0.1, 0.05, (Math.random() - 0.5) * 0.1), 
        creationTime: performance.now(),
        pickupCooldown: 200,
        onGround: false
    };

    droppedItems.push(itemEntity);
}

function triggerExplosion(x, y, z) {
    const blastRadius = 4; 
    const detonationQueue = new Set([getBlockKey(x, y, z)]);
    const processedForExplosion = new Set();
    const blocksToRemove = [];
    const affectedBlocks = []; 
    const affectedChunkIds = new Set();

    while (detonationQueue.size > 0) {
        const blockKey = detonationQueue.values().next().value;
        detonationQueue.delete(blockKey);
        
        if (processedForExplosion.has(blockKey)) continue;
        processedForExplosion.add(blockKey);

        const pos = blockKey.split('_').map(Number);
        const ex = pos[0], ey = pos[1], ez = pos[2];
        
        if (world[blockKey]) {
            
            delete world[blockKey];
            blocksToRemove.push({ x: ex, y: ey, z: ez });
            affectedChunkIds.add(getChunkId(Math.floor(ex / CHUNK_SIZE), Math.floor(ez / CHUNK_SIZE)));
        }
        
        for (let dx = -blastRadius; dx <= blastRadius; dx++) {
            for (let dy = -blastRadius; dy <= blastRadius; dy++) {
                for (let dz = -blastRadius; dz <= blastRadius; dz++) {
                    if (dx*dx + dy*dy + dz*dz > blastRadius * blastRadius) continue;

                    const blockX = ex + dx;
                    const blockY = ey + dy;
                    const blockZ = ez + dz;
                    const key = getBlockKey(blockX, blockY, blockZ);
                    const block = world[key];

                    if (!block) continue;

                    if (block.type === 'landmine' && !processedForExplosion.has(key)) {
                        detonationQueue.add(key);
                    } 
                    else if (block.type !== 'bedrock') {
                        
                        
                        affectedBlocks.push({ x: blockX, y: blockY, z: blockZ, type: block.type });
                        

                        delete world[key];
                        blocksToRemove.push({ x: blockX, y: blockY, z: blockZ });
                        affectedChunkIds.add(getChunkId(Math.floor(blockX / CHUNK_SIZE), Math.floor(blockZ / CHUNK_SIZE)));
                    }
                }
            }
        }
    }

    
    blocksToRemove.forEach(pos => {
        socket.emit('removeBlockWorker', pos);
    });
    
    
    
    affectedBlocks.forEach(blockInfo => {
        let dropType = blockInfo.type;

        
        if (dropType === 'stone') dropType = 'cobblestone';
        if (dropType === 'grass') dropType = 'dirt';
        if (dropType === 'leaves' && Math.random() < 0.1) dropType = 'apple';

        
        if (dropType !== 'air' && dropType !== 'cave_air' && dropType !== 'water' && dropType !== 'bedrock') {
            createItemDrop({ x: blockInfo.x + 0.5, y: blockInfo.y + 0.5, z: blockInfo.z + 0.5 }, dropType);
        }
    });
    
    
    
    if (affectedChunkIds.size > 0) {
        socket.emit('remeshChunks', Array.from(affectedChunkIds));
    }
    
    const playerFeetY = camera.position.y - currentPlayerEyeLevelOffset;
    const playerPos = new THREE.Vector3(camera.position.x, playerFeetY, camera.position.z);
    const explosionCenter = new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5);
    const distanceToPlayer = playerPos.distanceTo(explosionCenter);

    const maxDamage = 15; 
    const damageFalloff = distanceToPlayer / (blastRadius * 2);

    if (damageFalloff < 1.0) {
        const damage = Math.floor(maxDamage * (1.0 - damageFalloff));
        if (damage > 0) {
            applyDamage(damage, "explosion");
        }
    }
}
      function addToInventory(itemType, count = 1) {
        if (!itemType || count <= 0) return false;
        let remainingCount = count;
        const maxStack = getItemMaxStackSize(itemType); 

        const tryAddToSlots = (slots) => {
          
          for (let i = 0; i < slots.length; i++) {
            if (
              slots[i] &&
              slots[i].type === itemType &&
              slots[i].count < maxStack 
            ) {
              const canAdd = maxStack - slots[i].count;
              const amountToAdd = Math.min(remainingCount, canAdd);
              slots[i].count += amountToAdd;
              remainingCount -= amountToAdd;
              if (remainingCount <= 0) return true; 
            }
          }
          
          for (let i = 0; i < slots.length; i++) {
            if (slots[i] === null) {
              const amountToAdd = Math.min(remainingCount, maxStack); 
              slots[i] = { type: itemType, count: amountToAdd };
              remainingCount -= amountToAdd;
              if (remainingCount <= 0) return true; 
            }
          }
          return false; 
        };

        
        if (tryAddToSlots(hotbar)) {
          updateInventoryUI(); 
          return true;
        }
        if (tryAddToSlots(storage)) {
          updateInventoryUI(); 
          return true;
        }

        
        if (remainingCount < count) {
          console.log(
            `Partially added ${count - remainingCount} of ${itemType}. Inventory might be full.`
          );
          updateInventoryUI(); 
          return true; 
        } else {
          return false; 
        }
      }
      
      function renderSlot(item, index, isSelected = false) {
        const slot = document.createElement("div");
        slot.classList.add("inventory-slot");
        slot.dataset.slotIndex = index;
        if (isSelected) {
          slot.classList.add("selected");
        }
        if (item) {
          const nameSpan = document.createElement("span");
          nameSpan.classList.add("slot-item-name");
          nameSpan.textContent = getBlockDisplayName(item.type);
          slot.appendChild(nameSpan);
          if (item.count > 1) {
            const countSpan = document.createElement("span");
            countSpan.classList.add("slot-item-count");
            countSpan.textContent = item.count;
            slot.appendChild(countSpan);
          } /* Add texture background here */
        } else {
          slot.style.backgroundColor = "rgba(40, 40, 40, 0.4)";
        }
        return slot;
      }
      function updateInventoryUI() {
        
        const hotbarContainer = document.getElementById("inventory-ui");
        if (hotbarContainer) hotbarContainer.innerHTML = "";
        else console.error("#inventory-ui not found");

        
        const storageContainerInv = document.getElementById("storage-inventory-container-inv");
        const armorContainer = document.getElementById("armor-slots-container");
        const hotbarMirrorContainerInv = document.getElementById("hotbar-inventory-container-inv");
        const craftingGridContainer = document.getElementById("crafting-grid");
        const craftingOutputContainer = document.getElementById("crafting-output-slot");

        
        const storageContainerCt = document.getElementById("storage-inventory-container-ct");
        const hotbarMirrorContainerCt = document.getElementById("hotbar-inventory-container-ct");
        const craftingTableGridContainer = document.getElementById("crafting-table-grid");
        const craftingTableOutputContainer = document.getElementById("crafting-table-output-slot");

        
        if (isInventoryOpen) {
            if (storageContainerInv) storageContainerInv.innerHTML = "";
            else console.error("#storage-inventory-container-inv not found");
            if (armorContainer) armorContainer.innerHTML = "";
            else console.error("#armor-slots-container not found");
            if (hotbarMirrorContainerInv) hotbarMirrorContainerInv.innerHTML = "";
            else console.error("#hotbar-inventory-container-inv not found");
            if (craftingGridContainer) craftingGridContainer.innerHTML = "";
            else console.error("#crafting-grid not found");
            if (craftingOutputContainer) craftingOutputContainer.innerHTML = "";
            else console.error("#crafting-output-slot not found");
        }
         if (isCraftingTableOpen) {
            if (storageContainerCt) storageContainerCt.innerHTML = "";
             else console.error("#storage-inventory-container-ct not found");
            if (hotbarMirrorContainerCt) hotbarMirrorContainerCt.innerHTML = "";
            else console.error("#hotbar-inventory-container-ct not found");
            if (craftingTableGridContainer) craftingTableGridContainer.innerHTML = "";
            else console.error("#crafting-table-grid not found");
            if (craftingTableOutputContainer) craftingTableOutputContainer.innerHTML = "";
            else console.error("#crafting-table-output-slot not found");
        }

        
        if (hotbarContainer) {
          for (let i = 0; i < HOTBAR_SIZE; i++) {
            hotbarContainer.appendChild(
              renderSlot(hotbar[i], `hotbar-${i}`, i === selectedHotbarSlot)
            );
          }
        }

        
        if (isInventoryOpen) {
          if (armorContainer) {
            for (let i = 0; i < ARMOR_SIZE; i++) {
              armorContainer.appendChild(renderSlot(armor[i], `armor-${i}`));
            }
          }
          if (craftingGridContainer) {
            for (let i = 0; i < CRAFTING_GRID_SIZE; i++) {
              craftingGridContainer.appendChild(
                renderSlot(craftingGrid[i], `crafting-${i}`)
              );
            }
          }
          if (craftingOutputContainer) {
            checkCraftingRecipe(); 
            craftingOutputContainer.appendChild(
              renderSlot(craftingOutput, "crafting-output")
            );
          }
          if (storageContainerInv) {
            for (let i = 0; i < STORAGE_SIZE; i++) {
              storageContainerInv.appendChild(
                renderSlot(storage[i], `storage-${i}`)
              );
            }
          }
          if (hotbarMirrorContainerInv) {
            for (let i = 0; i < HOTBAR_SIZE; i++) {
              hotbarMirrorContainerInv.appendChild(
                renderSlot(hotbar[i], `hotbar-${i}`) 
              );
            }
          }
        }

         
        if (isCraftingTableOpen) {
            if (craftingTableGridContainer) {
                for(let i = 0; i < CRAFTING_TABLE_GRID_SIZE; i++) {
                    craftingTableGridContainer.appendChild(
                        renderSlot(craftingTableGrid[i], `craftingtable-${i}`)
                    );
                }
            }
            if (craftingTableOutputContainer) {
                craftingTableOutputContainer.appendChild(
                    renderSlot(craftingTableOutput, "craftingtable-output")
                );
            }
            if (storageContainerCt) {
                for (let i = 0; i < STORAGE_SIZE; i++) {
                    storageContainerCt.appendChild(
                        renderSlot(storage[i], `storage-${i}`) 
                    );
                }
            }
            if (hotbarMirrorContainerCt) {
                for (let i = 0; i < HOTBAR_SIZE; i++) {
                    hotbarMirrorContainerCt.appendChild(
                        renderSlot(hotbar[i], `hotbar-${i}`) 
                    );
                }
            }
        }

        updateCursorDisplay();
      }
      function updateCursorDisplay() {
        if (!itemOnCursorDisplay) return;
        if (itemOnCursor) {
          itemOnCursorDisplay.style.display = "flex";
          itemOnCursorDisplay.innerHTML = "";
          const nameSpan = document.createElement("span");
          nameSpan.classList.add("slot-item-name");
          nameSpan.textContent = getBlockDisplayName(itemOnCursor.type);
          itemOnCursorDisplay.appendChild(nameSpan);
          if (itemOnCursor.count > 1) {
            const countSpan = document.createElement("span");
            countSpan.classList.add("slot-item-count");
            countSpan.textContent = itemOnCursor.count;
            itemOnCursorDisplay.appendChild(countSpan);
          }
        } else {
          itemOnCursorDisplay.style.display = "none";
        }
      }
      function updateHealthUI() {
    const healthBar = document.getElementById("health-bar");
    if (!healthBar) {
        console.error("#health-bar progress element not found");
        return;
    }
    
    healthBar.max = playerMaxHealth;
    
    healthBar.value = playerHealth;

    
    
    
    
    
    
    
}
function updateBubblesUI() {
    const bubblesProgressBar = document.getElementById("airBubble");
    if (!bubblesProgressBar) {
        console.error("#airBubble progress element not found");
        return;
    }
}
      function updateHungerUI() {
        const hungerContainer = document.getElementById("hunger-bar");
        if (!hungerContainer) return;
        hungerContainer.innerHTML = "";
        const fullShanks = Math.floor(playerHunger / 2);
        for (let i = 0; i < playerMaxHunger / 2; i++) {
          const shank = document.createElement("div");
          shank.classList.add("hud-icon", "hunger");
          if (i < fullShanks) {
            shank.classList.add("full");
          } else {
            shank.classList.add("empty");
          }
          hungerContainer.appendChild(shank);
        }
      }
      
function showLoadingScreen(text) {
    loadingText.textContent = text;
    loadingScreen.style.display = 'flex';
}


function hideLoadingScreen() {
    loadingScreen.style.display = 'none';
    immune = true;
    setTimeout(() => {
      immune = false;
    }, 3000)
}

let activeFurnace = null;


const SMELTING_RECIPES = {
    'oxidized_iron_ore': { result: 'raw_iron', experience: 0.7 }, 
    'raw_iron': { result: 'iron_ingot', experience: 0.7 },
    'sand': { result: 'glass', experience: 0.1 },
    'cobblestone': { result: 'stone', experience: 0.1 },
    
    
    'raw_porkchop': { result: 'cooked_porkchop', experience: 0.35 },
    'raw_beef': { result: 'cooked_beef', experience: 0.35 },
    'potato': { result: 'baked_potato', experience: 0.35 },
    
};

const TICKS_PER_ITEM_SMELT = 200; 

const FUEL_VALUES = { 
    'coal': 1600,        
    'charcoal': 1600,    
    'log': 300,          
    'plank': 300,        
    'wooden_pickaxe': 200, 
    'wooden_axe': 200,
    'wooden_shovel': 200,
    'wooden_sword': 200,
    'stick': 100,        
    'lava_bucket': 20000 
    
};


function getSmeltingResult(inputType) {
    return SMELTING_RECIPES[inputType] ? SMELTING_RECIPES[inputType].result : null;
}


function getFuelBurnTime(fuelType) {
    
    if (fuelType && fuelType.includes('log')) return FUEL_VALUES['log'];
    if (fuelType && fuelType.includes('plank')) return FUEL_VALUES['plank'];
    return FUEL_VALUES[fuelType] || 0; 
}
function updateFurnaceUI() {
    const furnaceScreen = document.getElementById('furnace-screen');
    if (!furnaceScreen || furnaceScreen.style.display === 'none') {
        return; 
    }

    
    const inputSlotContainer = document.getElementById('furnace-input-slot');
    const fuelSlotContainer = document.getElementById('furnace-fuel-slot');
    const outputSlotContainer = document.getElementById('furnace-output-slot');

    
    const storageContainerFurnace = document.getElementById('storage-inventory-container-furnace');
    const hotbarContainerFurnace = document.getElementById('hotbar-inventory-container-furnace');

    
    if (inputSlotContainer) inputSlotContainer.innerHTML = '';
    if (fuelSlotContainer) fuelSlotContainer.innerHTML = '';
    if (outputSlotContainer) outputSlotContainer.innerHTML = '';
    if (storageContainerFurnace) storageContainerFurnace.innerHTML = '';
    if (hotbarContainerFurnace) hotbarContainerFurnace.innerHTML = '';

    
    if (activeFurnace) {
        
        if (inputSlotContainer) {
            
            inputSlotContainer.appendChild(renderSlot(activeFurnace.inputItem, 'furnace-input-0'));
        }
        if (fuelSlotContainer) {
            fuelSlotContainer.appendChild(renderSlot(activeFurnace.fuelItem, 'furnace-fuel-0'));
        }
        if (outputSlotContainer) {
            outputSlotContainer.appendChild(renderSlot(activeFurnace.outputItem, 'furnace-output-0'));
        }

        
        updateFurnaceProgressIndicators();

    } else {
        
        if (inputSlotContainer) inputSlotContainer.appendChild(renderSlot(null, 'furnace-input-0'));
        if (fuelSlotContainer) fuelSlotContainer.appendChild(renderSlot(null, 'furnace-fuel-0'));
        if (outputSlotContainer) outputSlotContainer.appendChild(renderSlot(null, 'furnace-output-0'));
        
        updateFurnaceProgressIndicators(true); 
    }


    
    
    if (storageContainerFurnace) {
        for (let i = 0; i < STORAGE_SIZE; i++) {
            
            storageContainerFurnace.appendChild(renderSlot(storage[i], `storage-furnace-${i}`));
        }
    }
    
    if (hotbarContainerFurnace) {
        for (let i = 0; i < HOTBAR_SIZE; i++) {
            hotbarContainerFurnace.appendChild(renderSlot(hotbar[i], `hotbar-furnace-${i}`));
        }
    }
    
    updateCursorDisplay();
}



function updateFurnaceProgressIndicators(forceReset = false) {
    const fuelFillElement = document.querySelector('#furnace-fuel-progress .fuel-fill');
    const arrowProgressElement = document.getElementById('furnace-smelting-arrow-progress');

    if (!fuelFillElement || !arrowProgressElement) {
        
        return;
    }

    if (forceReset || !activeFurnace ) {
        fuelFillElement.style.height = '0%';
        arrowProgressElement.style.width = '0%';
        return;
    }

    
    
    let fuelPercentage = 0;
    if (activeFurnace.currentMaxFuelBurnTime > 0) { 
        fuelPercentage = (activeFurnace.fuelBurnTimeRemaining / activeFurnace.currentMaxFuelBurnTime) * 100;
    }
    fuelFillElement.style.height = `${Math.max(0, Math.min(100, fuelPercentage))}%`;

    
    let smeltingPercentage = 0;
    if (activeFurnace.inputItem && TICKS_PER_ITEM_SMELT > 0) {
        smeltingPercentage = (activeFurnace.smeltProgress / TICKS_PER_ITEM_SMELT) * 100;
    }
    arrowProgressElement.style.width = `${Math.max(0, Math.min(100, smeltingPercentage))}%`;
}







function openFurnaceUI(furnaceBlockWorldData) { 
    

    if (!furnaceBlockWorldData) {
        console.error("MainThread: openFurnaceUI - ABORTING: No furnace block data provided.");
        activeFurnace = null;
        return;
    }

    
    
    const furnaceKey = getBlockKey(furnaceBlockWorldData.x, furnaceBlockWorldData.y, furnaceBlockWorldData.z);
    if (!world[furnaceKey].furnaceData) { 
        
        world[furnaceKey].furnaceData = {
            inputItem: null,
            fuelItem: null,
            outputItem: null,
            fuelBurnTimeRemaining: 0,
            currentMaxFuelBurnTime: 0,
            smeltProgress: 0,
            smeltTimeTotalForItem: TICKS_PER_ITEM_SMELT, 
            id: furnaceKey
        };
    }

    activeFurnace = world[furnaceKey].furnaceData; 

    
    isCraftingTableOpen = false;
    isInventoryOpen = true;
    isFurnaceOpen = true; 
    if(document.getElementById("full-inventory-screen")) document.getElementById("full-inventory-screen").style.display = "none";
    if(document.getElementById("crafting-table-screen")) document.getElementById("crafting-table-screen").style.display = "none";

    const furnaceScreen = document.getElementById('furnace-screen');
    if (furnaceScreen) {
        furnaceScreen.style.display = 'flex';
        furnaceScreen.style.pointerEvents = 'auto';
        updateFurnaceUI(); 
        document.body.style.cursor = 'default';
        if (document.pointerLockElement) {
            document.exitPointerLock();
        }
    } else {
        console.error("MainThread: openFurnaceUI - #furnace-screen element NOT FOUND!");
        activeFurnace = null;
        isFurnaceOpen = false;
    }
}



function closeFurnaceUI() { 
    const furnaceScreen = document.getElementById('furnace-screen');
    console.log("Closing furnace UI");
    if (furnaceScreen) {
        furnaceScreen.style.display = 'none';
    }
    activeFurnace = null; 
    
}

      
      function internalAddBlock(
        worldX,
        worldY,
        worldZ,
        blockType,
        overwrite = false
      ) {
        const blockKey = getBlockKey(worldX, worldY, worldZ);
        if (!overwrite && world[blockKey]) return;
        const isSolid = ["grass", "log", "dirt", "stone", "plank", "craftingtable", "leaves", "cobblestone", "coal_ore", "oxidized_iron_ore", "bedrock", "landmine"].includes(
          blockType
        );
        world[blockKey] = { type: blockType, solid: isSolid };
        if(blockType === "leaves" || blockType === "water") {
            console.log(world[blockKey])
        }
      }
      function addBlock(x, y, z, blockType) {
    internalAddBlock(x, y, z, blockType, true); 
    
    socket.emit('addBlockWorker', { x, y, z, type: blockType }); 

    
    const cx = Math.floor(x / CHUNK_SIZE);
    const cz = Math.floor(z / CHUNK_SIZE);
    const affectedChunkIds = new Set([getChunkId(cx, cz)]);
    
    const borderXMin = x % CHUNK_SIZE === 0;
    const borderXMax = (x + 1) % CHUNK_SIZE === 0; 
    const borderZMin = z % CHUNK_SIZE === 0;
    const borderZMax = (z + 1) % CHUNK_SIZE === 0;

    if (borderXMin) affectedChunkIds.add(getChunkId(cx - 1, cz));
    if (borderXMax) affectedChunkIds.add(getChunkId(cx + 1, cz));
    if (borderZMin) affectedChunkIds.add(getChunkId(cx, cz - 1));
    if (borderZMax) affectedChunkIds.add(getChunkId(cx, cz + 1));
    
    if (borderXMin && borderZMin) affectedChunkIds.add(getChunkId(cx - 1, cz - 1));
    if (borderXMin && borderZMax) affectedChunkIds.add(getChunkId(cx - 1, cz + 1));
    if (borderXMax && borderZMin) affectedChunkIds.add(getChunkId(cx + 1, cz - 1));
    if (borderXMax && borderZMax) affectedChunkIds.add(getChunkId(cx + 1, cz + 1));


    
    socket.emit('remeshChunks', Array.from(affectedChunkIds));

    
}
      function getChunk(x, y, z) {
        const cx = Math.floor(x / CHUNK_SIZE);
        const cz = Math.floor(z / CHUNK_SIZE);
        return chunks.get(`${cx}_${cz}`);
      }

      function removeBlockAt(x, y, z) {
    const blockKey = getBlockKey(x, y, z);
    const blockData = getBlock(x, y, z); 
    
    if (!blockData) return false;

    
    
    

    const blockType = blockData.type;
    let dropType = blockType;
    if (blockType === 'stone') {
        dropType = 'cobblestone';
    } else if (blockType === 'grass') {
        dropType = 'dirt';
    }
    else if(blockType === 'leaves') {
      if(Math.random() < 0.1) {
        dropType = 'apple'; 
      } else {
        dropType = null;
      }
    }

    let canHarvest = false;
    const breakProps = breakInfo[blockType];
    const requiredToolCategory = breakProps ? breakProps.tool : 'any';

    if (!requiredToolCategory || requiredToolCategory === 'any') {
        canHarvest = true;
    } else {
        const selectedItem = hotbar[selectedHotbarSlot];
        const heldItemType = selectedItem ? selectedItem.type : null;
        const heldToolCategory = toolTypes[heldItemType];
        if (heldToolCategory === requiredToolCategory) {
            canHarvest = true;
        }
    }

    if (canHarvest && dropType) {
        createItemDrop({ x: x + 0.5, y: y + 0.5, z: z + 0.5 }, dropType);
    }
    
    

    
    delete world[blockKey];

    
    socket.emit('removeBlockWorker', { x, y, z });

    
    const cx = Math.floor(x / CHUNK_SIZE);
    const cz = Math.floor(z / CHUNK_SIZE);
    const affectedChunkIds = new Set([getChunkId(cx, cz)]);
    const borderXMin = x % CHUNK_SIZE === 0;
    const borderXMax = (x + 1) % CHUNK_SIZE === 0;
    const borderZMin = z % CHUNK_SIZE === 0;
    const borderZMax = (z + 1) % CHUNK_SIZE === 0;
    if (borderXMin) affectedChunkIds.add(getChunkId(cx - 1, cz));
    if (borderXMax) affectedChunkIds.add(getChunkId(cx + 1, cz));
    if (borderZMin) affectedChunkIds.add(getChunkId(cx, cz - 1));
    if (borderZMax) affectedChunkIds.add(getChunkId(cx, cz + 1));
    if (borderXMin && borderZMin) affectedChunkIds.add(getChunkId(cx - 1, cz - 1));
    if (borderXMin && borderZMax) affectedChunkIds.add(getChunkId(cx - 1, cz + 1));
    if (borderXMax && borderZMin) affectedChunkIds.add(getChunkId(cx + 1, cz - 1));
    if (borderXMax && borderZMax) affectedChunkIds.add(getChunkId(cx + 1, cz + 1));

    
    socket.emit('remeshChunks', Array.from(affectedChunkIds));

    return true;
}
document.addEventListener('keydown', function (event) {
  if (event.ctrlKey && event.key === 'w') {
    event.preventDefault();
  }
});

      
            

      
      const WORLD_SEED = "012345!"; 
      const simplex = new SimplexNoise(WORLD_SEED);

      
      
      const FRACTAL_OCTAVES = 6;
      const FRACTAL_PERSISTENCE = 0.5;
      const FRACTAL_LACUNARITY = 2.0;

      
      const BiomeType = { Plains: 0, Forest: 1, Mountain: 2, River: 3 };
      const biomeParameters = {
        [BiomeType.Plains]: {
        name: "Plains",
        baseHeight: 1,
        
        terrainAmplitude: 3,     
        terrainScale: 0.06,      
        terrainOctaves: 3,         
        terrainPersistence: 0.45,  

        
        hillAmplitude: 15,       
        hillScale: 0.008,        
        hillOctaves: 4,          
        hillPersistence: 0.5,

        
        treeDensity: 0.005, treeHeightMin: 3, treeHeightMax: 5, 
        surfaceBlock: "grass", underSurfaceBlock: "dirt", dirtDepth: 3,
        stoneLevelModifier: -10, plainsForestPatchChance: 0.03, plainsForestPatchDensity: 0.05,
    },
        [BiomeType.Forest]: {
          name: "Forest", baseHeight: 3, terrainAmplitude: 4, terrainScale: 0.03,
          treeDensity: 0.04, treeHeightMin: 4, treeHeightMax: 7,
          surfaceBlock: "grass", underSurfaceBlock: "dirt", dirtDepth: 4,
          stoneLevelModifier: -8,
          terrainOctaves: 1
        },
        [BiomeType.Mountain]: {
          name: "Mountain", baseHeight: 3, 
          terrainAmplitude: 30, 
          terrainScale: 0.02, 
          treeDensity: 0.005, treeHeightMin: 3, treeHeightMax: 5,
          surfaceBlock: "grass", 
          underSurfaceBlock: "stone", dirtDepth: 3, stoneLevelModifier: 0,
          snowLevel: 55, 
          terrainOctaves: 2, 
          terrainPersistence: 0.55, 
          terrainLacunarity: 2.1, 
          roughnessAmplitude: 1, 
        },
        [BiomeType.River]: {
          name: "River", baseHeight: 1, terrainAmplitude: 3, terrainScale: 0.04,
          treeDensity: 0.003, treeHeightMin: 3, treeHeightMax: 5,
          surfaceBlock: "water", underSurfaceBlock: "dirt", dirtDepth: 3,
          stoneLevelModifier: -10, plainsForestPatchChance: 0.03, plainsForestPatchDensity: 0.05,
          
          terrainOctaves: 0.2, terrainPersistence: 0.45,
        },
      };

      
      const biomeNoiseScale = 0.0025;
      const biomeOctaves = 4; 
      const biomePersistence = 0.5;
      const biomeLacunarity = 2.0;
      const forestThreshold = 0.4; 
      const mountainThreshold = 0.5; 

            
            const CAVE_SEED_OFFSET = 10000; 
      const RIVER_SEED_OFFSET = 20000;

      
      const caveNoiseScale = 0.06;   
      const caveThreshold = 0.65;  
      const minCaveY = -60;        
      const maxCaveY = 40;         

      function getBiome(worldX, worldZ) {
          const noiseValue = generateFractalNoise2D( 
              simplex, 
              worldX * biomeNoiseScale,
              worldZ * biomeNoiseScale,
              biomeOctaves,
              biomePersistence,
              biomeLacunarity
          ); 

          
          const normalizedNoise = (noiseValue + 1) / 2.0;

          if (normalizedNoise < forestThreshold) return BiomeType.Plains;
          else if (normalizedNoise > mountainThreshold) return BiomeType.Mountain;
          else return BiomeType.Forest;
      }

      function getCave(worldX, worldZ, worldY) {
         const noiseValue = generateFractalNoise3dD(
            simplex,
            worldX * biomeNoiseScale,
            worldY * biomeNoiseScale,
            worldZ * biomeNoiseScale,
            biomeOctaves,
            biomePersistence,
            biomeLacunarity
         )
        const normalizedNoise = (noiseValue + 1) / 2.0;

        if (normalizedNoise > 0.5) return true;
        else return false;
      }

            
            function calculateTerrainInfo(worldX, worldZ) {
        const biomeType = getBiome(worldX, worldZ);
        const params = biomeParameters[biomeType];

        
        const terrainOctaves = params.terrainOctaves || FRACTAL_OCTAVES;
        const terrainPersistence = params.terrainPersistence || FRACTAL_PERSISTENCE;
        const terrainLacunarity = params.terrainLacunarity || FRACTAL_LACUNARITY;
        const heightNoise = generateFractalNoise2D(
            simplex,
            worldX * params.terrainScale,
            worldZ * params.terrainScale,
            terrainOctaves,
            terrainPersistence,
            terrainLacunarity
        );
        const normalizedHeightNoise = (heightNoise + 1) / 2.0;
        const baseHeightValue = params.baseHeight + normalizedHeightNoise * params.terrainAmplitude;
        const roughnessAmplitude = params.roughnessAmplitude || (biomeType === BiomeType.Mountain ? 3 : 1);
        const roughnessScale = 0.1;
        const roughnessNoise = simplex.noise2D(worldX * roughnessScale, worldZ * roughnessScale);
        const terrainHeight = Math.floor(baseHeightValue + roughnessNoise * roughnessAmplitude);
        

        
        return {
            height: terrainHeight, 
            biome: biomeType,
            params: params,
        };
      }
      
                  
      function generateChunkData(chunk) {
        const { wx: chunkStartX, wz: chunkStartZ } = chunkToWorldCoords(chunk.cx, chunk.cz);

        for (let x = 0; x < CHUNK_SIZE; x++) {
          for (let z = 0; z < CHUNK_SIZE; z++) {
            const worldX = chunkStartX + x;
            const worldZ = chunkStartZ + z;

            
            const terrainInfo = calculateTerrainInfo(worldX, worldZ);
            const originalSurfaceY = terrainInfo.height; 
            const actualSurfaceY = originalSurfaceY
            const biomeParams = terrainInfo.params;
            const biomeType = terrainInfo.biome;

                        
            
            const oreNoiseScale = 0.08;   
            const oreNoiseSeedOffset = 1000; 

            
            const coalThreshold = 0.85;  
            const coalMinY = 0;
            const coalMaxY = 128;         

            
            const ironThreshold = 0.95;   
            const ironMinY = -60;        
            const ironMaxY = 70;         
            const ironPeakY = 16;        
            const ironSpread = 40;       
            

            
            

            
            const stoneStartY = originalSurfaceY - biomeParams.dirtDepth + biomeParams.stoneLevelModifier;

            
            const minYGen = -64; 
            for (let y = minYGen; y <= actualSurfaceY; y++) {
                
                if (hasBlock(worldX, y, worldZ)) continue;

                
                let isCaveAir = false;
                
                if (y >= minCaveY && y < actualSurfaceY && y <= maxCaveY) {
                    
                    const caveNoiseValue = simplex.noise3D(
                        (worldX + CAVE_SEED_OFFSET) * caveNoiseScale,
                        (y + CAVE_SEED_OFFSET) * caveNoiseScale,
                        (worldZ + CAVE_SEED_OFFSET) * caveNoiseScale
                    );
                    const normalizedCaveNoise = (caveNoiseValue + 1) / 2.0;

                    if (normalizedCaveNoise > caveThreshold) {
                        isCaveAir = true; 
                    }
                }
                
                if (isCaveAir) {
                    continue; 
                }
                


                
                let blockType = 'stone'; 

              
              if (y === actualSurfaceY) {
                  
                  blockType = (biomeType === BiomeType.Mountain && y >= biomeParams.snowLevel)
                      ? 'stone' 
                      : biomeParams.surfaceBlock; 
              }
              
              else if (y > stoneStartY) { 
                  blockType = biomeParams.underSurfaceBlock; 
              }
              else if(y === 11 && !hasBlock(worldX, 12, worldZ)){
                blockType = 'water'
              } 
              

                
                internalAddBlock(worldX, y, worldZ, blockType);

            } 


            
            
            const oreCheckMinY = Math.min(minCaveY, -64);
            const oreCheckMaxY = actualSurfaceY; 

            
            let coalOrePlacedInColumn = false;
            let ironOrePlacedInColumn = false;

            for (let y = oreCheckMinY; y <= oreCheckMaxY; y++) {
              const blockKey = getBlockKey(worldX, y, worldZ);
              const currentBlock = world[blockKey]; 

              
              if (currentBlock && currentBlock.type === 'stone') {

                  
                  if (!coalOrePlacedInColumn && y >= coalMinY && y <= coalMaxY) {
                      const coalNoiseVal = simplex.noise3D(
                          (worldX + oreNoiseSeedOffset) * oreNoiseScale,
                          (y + oreNoiseSeedOffset) * oreNoiseScale,
                          (worldZ + oreNoiseSeedOffset) * oreNoiseScale
                      );
                      const normalizedCoalNoise = (coalNoiseVal + 1) / 2.0;

                      if (normalizedCoalNoise > coalThreshold) {
                          let isExposed = false;
                          const neighbors = [ { dx: 1, dy: 0, dz: 0 }, { dx: -1, dy: 0, dz: 0 }, { dx: 0, dy: 1, dz: 0 }, { dx: 0, dy: -1, dz: 0 }, { dx: 0, dy: 0, dz: 1 }, { dx: 0, dy: 0, dz: -1 }];
                          for (const n of neighbors) { if (!hasBlock(worldX + n.dx, y + n.dy, worldZ + n.dz)) { isExposed = true; break; } }

                          let placeThisOre = true;
                          if (isExposed && Math.random() >= 0.5) { placeThisOre = false; }

                          if (placeThisOre) {
                              internalAddBlock(worldX, y, worldZ, 'coal_ore', true);
                              coalOrePlacedInColumn = true; 
                               continue; 
                          }
                      }
                  }

                 
                 if (!ironOrePlacedInColumn && y >= ironMinY && y <= ironMaxY) {
                     const distFromPeak = Math.abs(y - ironPeakY);
                     const normalizedDist = Math.min(1.0, distFromPeak / ironSpread);
                     const currentIronThreshold = ironThreshold + normalizedDist * (1.0 - ironThreshold);

                     const ironNoiseVal = simplex.noise3D(
                         (worldX - oreNoiseSeedOffset) * oreNoiseScale * 1.1,
                         (y - oreNoiseSeedOffset) * oreNoiseScale * 1.1,
                         (worldZ - oreNoiseSeedOffset) * oreNoiseScale * 1.1
                     );
                     const normalizedIronNoise = (ironNoiseVal + 1) / 2.0;

                     if (normalizedIronNoise > currentIronThreshold) {
                         let isExposed = false;
                         const neighbors = [ { dx: 1, dy: 0, dz: 0 }, { dx: -1, dy: 0, dz: 0 }, { dx: 0, dy: 1, dz: 0 }, { dx: 0, dy: -1, dz: 0 }, { dx: 0, dy: 0, dz: 1 }, { dx: 0, dy: 0, dz: -1 }];
                         for (const n of neighbors) { if (!hasBlock(worldX + n.dx, y + n.dy, worldZ + n.dz)) { isExposed = true; break; } }

                         let placeThisOre = true;
                         if (isExposed && Math.random() >= 0.5) { placeThisOre = false; }

                         if (placeThisOre) {
                             internalAddBlock(worldX, y, worldZ, 'oxidized_iron_ore', true);
                             ironOrePlacedInColumn = true; 
                         }
                     }
                 } 

              } 
            } 


            
            const surfaceBlockData = getBlock(worldX, actualSurfaceY, worldZ);
            const surfaceBlockType = surfaceBlockData ? surfaceBlockData.type : null;

            
            console.log(surfaceBlockType)
            if (
                (surfaceBlockType === biomeParams.surfaceBlock || surfaceBlockType === 'dirt' || surfaceBlockType === 'grass_block' ) && 
                actualSurfaceY < (biomeParams.snowLevel ?? Infinity))
            {
                 
                 let treeDensity = 0;
                 let treeHeightMin = 4; 
                 let treeHeightMax = 6;

                 if (biomeType === BiomeType.Forest) {
                     treeDensity = biomeParams.treeDensity;
                     treeHeightMin = biomeParams.treeHeightMin;
                     treeHeightMax = biomeParams.treeHeightMax;
                 } else if (biomeType === BiomeType.Plains) {
                    
                    if (Math.random() < biomeParams.plainsForestPatchChance) {
                       treeDensity = biomeParams.plainsForestPatchDensity || biomeParameters[BiomeType.Forest].treeDensity; 
                       treeHeightMin = biomeParameters[BiomeType.Forest].treeHeightMin;
                       treeHeightMax = biomeParameters[BiomeType.Forest].treeHeightMax;
                    } else {
                       treeDensity = biomeParams.treeDensity; 
                       treeHeightMin = biomeParams.treeHeightMin;
                       treeHeightMax = biomeParams.treeHeightMax;
                    }
                 } else if (biomeType === BiomeType.Mountain) {
                     treeDensity = biomeParams.treeDensity;
                     treeHeightMin = biomeParams.treeHeightMin;
                     treeHeightMax = biomeParams.treeHeightMax;
                 }

                 
                 if (Math.random() < treeDensity) {
                    
                    const heightNorth = calculateTerrainInfo(worldX, worldZ + 1).height;
                    const heightSouth = calculateTerrainInfo(worldX, worldZ - 1).height;
                    const heightEast = calculateTerrainInfo(worldX + 1, worldZ).height;
                    const heightWest = calculateTerrainInfo(worldX - 1, worldZ).height;
                    const maxSlope = Math.max(
                        Math.abs(originalSurfaceY - heightNorth), Math.abs(originalSurfaceY - heightSouth),
                        Math.abs(originalSurfaceY - heightEast), Math.abs(originalSurfaceY - heightWest)
                    );
                    
                        const treeHeight = Math.floor(Math.random() * (treeHeightMax - treeHeightMin + 1)) + treeHeightMin;
                        try{
                        generateTreeStructure(worldX, actualSurfaceY + 1, worldZ, treeHeight);
                        console.log("Tree placed at", worldX, actualSurfaceY + 1, worldZ);
                        }
                        catch(e){
                            console.error("Error placing tree:", e);
                        }
                 }
                 console.log("triggered?")
            } 

          } 
        } 
        console.log("world updated!")
        chunk.state = ChunkState.DataLoaded;
        console.log("triggered")
      }
      
      function generateTreeStructure(rX, rY, rZ, h) {
        for (let i = 0; i < h; i++) {
          internalAddBlock(rX, rY + i, rZ, "log");
        }
        const lR = 2;
        const tTY = rY + h - 1;
        for (let ly = tTY - 1; ly <= tTY + 1; ly++) {
          for (let lx = -lR; lx <= lR; lx++) {
            for (let lz = -lR; lz <= lR; lz++) {
              const bX = rX + lx;
              const bY = ly;
              const bZ = rZ + lz;
              const dSq =
                lx * lx + (bY - (tTY + 0.5)) * (bY - (tTY + 0.5)) + lz * lz;
              if (dSq > (lR + 0.5) * (lR + 0.5)) continue;
              if (bX === rX && bZ === rZ && bY <= tTY) continue;
              if (!hasSolidBlock(bX, bY, bZ)) {
                internalAddBlock(bX, bY, bZ, "leaves");
              }
            }
          }
        }
        if (!hasSolidBlock(rX, tTY + 2, rZ)) {
          internalAddBlock(rX, tTY + 2, rZ, "leaves");
        }
      }

      
      
      function markChunkForRemesh(cx, cz, checkNeighbors = false) {
        const cId = getChunkId(cx, cz);
        const ch = chunks.get(cId);
        if (
          ch &&
          (ch.state === ChunkState.Active || ch.state === ChunkState.Inactive)
        ) {
          ch.state = ChunkState.NeedsRemesh;
          chunksNeedUpdate = true;
          socket.emit("chunksNeedUpdate", chunksNeedUpdate);
        }
        if (checkNeighbors) {
          markChunkForRemesh(cx + 1, cz);
          markChunkForRemesh(cx - 1, cz);
          markChunkForRemesh(cx, cz + 1);
          markChunkForRemesh(cx, cz - 1);
        }
      }
      function getChunkId(chunkX, chunkZ) {
    return `${chunkX}_${chunkZ}`;
  }

  function removeChunkBlocksFromClientMemory(chunk) {
    if (!chunk) return;
    const { wx: chunkStartX, wz: chunkStartZ } = chunkToWorldCoords(chunk.cx, chunk.cz);
    const minYGen = -64;
    const maxYGen = 128;

    for (let x = 0; x < CHUNK_SIZE; x++) {
        for (let z = 0; z < CHUNK_SIZE; z++) {
            for (let y = minYGen; y <= maxYGen; y++) {
                const blockKey = getBlockKey(chunkStartX + x, y, chunkStartZ + z);
                if (world[blockKey]) {
                    delete world[blockKey];
                }
            }
        }
    }
}
      function addBlockInstanceFace(chunk, x, y, z, blockType, faceName) {
const geo = faceGeometries[faceName];
const material = getMaterialForBlockFace(blockType, faceName);
if (!material || !geo) return;
const meshData = getChunkInstancedMesh(chunk, material, geo, faceName);
if (!meshData) return;
if (meshData.count < MAX_INSTANCES_PER_GEOMETRY_PER_CHUNK) {
  dummy.position.set(x + 0.5, y + 0.5, z + 0.5);
  dummy.updateMatrix();
  meshData.mesh.setMatrixAt(meshData.count, dummy.matrix);
  meshData.count++;
} else {
  console.warn(`Max instances reached for ${meshData.mesh.name}`);
}
}
function getChunkInstancedMesh(chunk, material, faceGeometry, faceName) {
if (!chunk || !material || !faceGeometry || !faceName) {
  console.error("Missing parameters for getChunkInstancedMesh");
  return null;
}
if (!chunk.meshes) {
  chunk.meshes = new Map();
}
const key = `${faceName}_${material.uuid}`;
let meshData = chunk.meshes.get(key);
if (!meshData) {
  const mesh = new THREE.InstancedMesh(
    faceGeometry,
    material,
    MAX_INSTANCES_PER_GEOMETRY_PER_CHUNK
  );
  mesh.count = 0;
  mesh.name = `chunk_${chunk.id}_mesh_${key}`;
  meshData = { mesh: mesh, count: 0 };
  chunk.meshes.set(key, meshData);
}
return meshData;
}
function getMaterialForBlockFace(blockType, faceName) {
const m = materials[blockType];
if (!m) {
  console.warn(
    `No material found for block type: ${blockType}, using dirt.`
  );
  return materials.dirt.all;
}
if (m.all) return m.all;
switch (faceName) {
  case "top":
    return m.top || m.side || m.all;
  case "bottom":
    return m.bottom || m.side || m.all;
  default:
    return m.side || m.top || m.all;
}
}
function disposeChunkMeshes(chunk) {
if (chunk.meshes) {
  chunk.meshes.forEach((mD) => {
    scene.remove(
      mD.mesh
    );
  });
  chunk.meshes.clear();
}
}
      function meshChunk(chunk) {
    chunk.state = ChunkState.Meshing;
    disposeChunkMeshes(chunk);
    chunk.meshes = new Map();
    const { wx: sX, wz: sZ } = chunkToWorldCoords(chunk.cx, chunk.cz);
    let facesAdded = 0;
    const faces = [
      { face: "right",  dx: 1,  dy: 0,  dz: 0 },
      { face: "left",   dx: -1, dy: 0,  dz: 0 },
      { face: "top",    dx: 0,  dy: 1,  dz: 0 },
      { face: "bottom", dx: 0,  dy: -1, dz: 0 },
      { face: "front",  dx: 0,  dy: 0,  dz: 1 },
      { face: "back",   dx: 0,  dy: 0,  dz: -1 },
    ];
    const minBY = -38;
    const maxBY = 60;
    for (let x = 0; x < CHUNK_SIZE; x++) {
      for (let z = 0; z < CHUNK_SIZE; z++) {
        for (let y = minBY; y < maxBY; y++) {
          const blockCoordX = sX + x;
          const blockCoordY = y;
          const blockCoordZ = sZ + z;
          const bedrockLayer = minBY - 1;
          const bD = getBlock(blockCoordX, blockCoordY, blockCoordZ);
          if (bD) {
            faces.forEach((faceDirection) => {
              const nX = blockCoordX + faceDirection.dx;
              const nY = blockCoordY + faceDirection.dy;
              const nZ = blockCoordZ + faceDirection.dz;
              const nB = getBlock(nX, nY, nZ);
              const nIsT = !nB
              if (nIsT) {
                addBlockInstanceFace(chunk, blockCoordX, blockCoordY, blockCoordZ, bD.type, faceDirection.face);
                facesAdded++;
              }
              if (y === bedrockLayer) {
                addBlockInstanceFace(chunk, blockCoordX, blockCoordY, blockCoordZ, "bedrock", faceDirection.face);
                facesAdded++;
              }
            });
          }
        }
      }
    }
    const group = new THREE.Group();
    group.name = `chunk_${chunk.id}_group`;
    chunk.meshes.forEach((mD) => {
      if (mD.count > 0) {
        mD.mesh.count = mD.count;
        mD.mesh.instanceMatrix.needsUpdate = true;
        scene.add(mD.mesh);
    }
    })
    chunk.state = ChunkState.Active;
  }
  
function updatePlayerStance() {
    const isSneaking = keys.shift; 

    if (isSneaking) {
        currentPlayerHeight = PLAYER_SNEAKING_HEIGHT;
        currentPlayerEyeLevelOffset = PLAYER_SNEAKING_EYE_LEVEL_OFFSET;
        currentPlayerCollisionHeight = PLAYER_SNEAKING_COLLISION_HEIGHT;
    } else {
        currentPlayerHeight = PLAYER_STANDING_HEIGHT;
        currentPlayerEyeLevelOffset = PLAYER_STANDING_EYE_LEVEL_OFFSET;
        currentPlayerCollisionHeight = PLAYER_STANDING_COLLISION_HEIGHT;
    }

    
    
    playerFeetOffset = -currentPlayerEyeLevelOffset; 
                                                    
                                                    

    
    
    
    
    

    
    playerCollisionBottomOffset = -currentPlayerEyeLevelOffset; 
    playerCollisionTopOffset = currentPlayerCollisionHeight - currentPlayerEyeLevelOffset; 
                                                                                        

    
    
    
}
  
function checkIfSafeToUnfreeze() {
    // 1. Get the player's current chunk coordinates
    const playerChunkX = Math.floor(camera.position.x / CHUNK_SIZE);
    const playerChunkZ = Math.floor(camera.position.z / CHUNK_SIZE);
    const playerChunkId = getChunkId(playerChunkX, playerChunkZ);

    // 2. Check if that chunk exists on the client and is in the 'Active' state
    const chunk = chunks.get(playerChunkId);
    if (chunk && chunk.state === ChunkState.Active) {
        // 3. It's safe! Unfreeze the player and hide the loading screen.
        console.log("Player is on an active chunk. Unfreezing physics.");
        isPlayerFrozen = false;
        hideLoadingScreen();
    }
}

function collisionTick() {
    const originalPlayerCameraY = camera.position.y; 

    
    let verticalMovementAppliedThisFrame = verticalVelocity; 

    
    if (!wasOnGround && verticalVelocity <= 0) {
        
        
        
        
        fallDistance += Math.abs(verticalMovementAppliedThisFrame); 
    }

    verticalVelocity -= gravity; 
    camera.position.y += verticalVelocity; 

    let newIsOnGroundThisFrame = false; 

    
    let currentCamX = camera.position.x;
    let currentCamY = camera.position.y; 
    let currentCamZ = camera.position.z;

    
    
    const playerFeetWorldY = currentCamY - currentPlayerEyeLevelOffset;
    const playerCollisionBoxMinY_world = playerFeetWorldY; 
    const playerCollisionBoxMaxY_world = playerFeetWorldY + currentPlayerCollisionHeight; 

    const playerCollisionBoxMinX_world = currentCamX - PLAYER_WIDTH / 2;
    const playerCollisionBoxMaxX_world = currentCamX + PLAYER_WIDTH / 2;
    const playerCollisionBoxMinZ_world = currentCamZ - PLAYER_WIDTH / 2;
    const playerCollisionBoxMaxZ_world = currentCamZ + PLAYER_WIDTH / 2;

    
    const collisionCheckRadius = 1.5; 
    const minBlockXToCheck = Math.floor(playerCollisionBoxMinX_world - collisionCheckRadius);
    const maxBlockXToCheck = Math.ceil(playerCollisionBoxMaxX_world + collisionCheckRadius);
    const minBlockYToCheck = Math.floor(playerCollisionBoxMinY_world - collisionCheckRadius);
    const maxBlockYToCheck = Math.ceil(playerCollisionBoxMaxY_world + collisionCheckRadius);
    const minBlockZToCheck = Math.floor(playerCollisionBoxMinZ_world - collisionCheckRadius);
    const maxBlockZToCheck = Math.ceil(playerCollisionBoxMaxZ_world + collisionCheckRadius);

    
    for (let bX = minBlockXToCheck; bX <= maxBlockXToCheck; bX++) {
        for (let bY = minBlockYToCheck; bY <= maxBlockYToCheck; bY++) {
            for (let bZ = minBlockZToCheck; bZ <= maxBlockZToCheck; bZ++) {
                if (!hasSolidBlock(bX, bY, bZ)) { 
                    continue;
                }

                
                const blockMinX = bX;
                const blockMaxX = bX + 1;
                const blockMinY = bY;
                const blockMaxY = bY + 1;
                const blockMinZ = bZ;
                const blockMaxZ = bZ + 1;

                
                if (
                    playerCollisionBoxMaxX_world > blockMinX && playerCollisionBoxMinX_world < blockMaxX &&
                    playerCollisionBoxMaxY_world > blockMinY && playerCollisionBoxMinY_world < blockMaxY &&
                    playerCollisionBoxMaxZ_world > blockMinZ && playerCollisionBoxMinZ_world < blockMaxZ
                ) {

                const block = getBlock(bX, bY, bZ);
                if (block && block.type === 'landmine') {
                    triggerExplosion(bX, bY, bZ);
                    return;
                }


                    
                    
                    const playerCollisionCenterX = currentCamX;
                    const playerCollisionCenterY = playerFeetWorldY + (currentPlayerCollisionHeight / 2);
                    const playerCollisionCenterZ = currentCamZ;

                    
                    const blockCenterX = bX + 0.5;
                    const blockCenterY = bY + 0.5;
                    const blockCenterZ = bZ + 0.5;

                    
                    const deltaX = playerCollisionCenterX - blockCenterX;
                    const deltaY = playerCollisionCenterY - blockCenterY;
                    const deltaZ = playerCollisionCenterZ - blockCenterZ;

                    const overlapX = (PLAYER_WIDTH / 2 + 0.5) - Math.abs(deltaX);
                    const overlapY = (currentPlayerCollisionHeight / 2 + 0.5) - Math.abs(deltaY);
                    const overlapZ = (PLAYER_WIDTH / 2 + 0.5) - Math.abs(deltaZ);

                    
                    if (overlapY < overlapX && overlapY < overlapZ) { 
                        if (deltaY > 0 && verticalVelocity <= 0) { 
                            
                            if (!wasOnGround && world[getBlockKey(bX, bY + 1, bZ)]?.type !== "water") {
                                if (fallDistance > 3.0) {
                                    const damage = Math.floor(fallDistance - 3.0);
                                    if (damage > 0 && currentDimension === "overworld") {
                                        
                                        applyDamage(damage, "fall");
                                    }
                                }
                            }
                            else if(world[getBlockKey(bX, bY + 1, bZ)]?.type === "water"){
                                fallDistance = 0;
                            }
                            fallDistance = 0; 
                            newIsOnGroundThisFrame = true; 
                            verticalVelocity = 0; 

                            
                            
                            camera.position.y = blockMaxY + currentPlayerEyeLevelOffset;

                        } else if (deltaY <= 0) { 
                            if (verticalVelocity > 0) { 
                                verticalVelocity = 0; 
                            }
                            
                            
                            
                            
                            camera.position.y = (blockMinY - currentPlayerCollisionHeight) + currentPlayerEyeLevelOffset;
                            
                        }
                        currentCamY = camera.position.y; 
                        
                        
                        
                        

                    } else if (overlapX < overlapZ) { 
                        camera.position.x += (deltaX > 0 ? overlapX : -overlapX);
                        currentCamX = camera.position.x;
                        playerVelocity.x = 0;
                        
                        if ((playerVelocity.x > 0 && deltaX < 0) || (playerVelocity.x < 0 && deltaX > 0)) {
                            playerVelocity.x = 0;
                        }
                    } else { 
                        camera.position.z += (deltaZ > 0 ? overlapZ : -overlapZ);
                        currentCamZ = camera.position.z;
                        playerVelocity.z = 0;
                        
                        if ((playerVelocity.z > 0 && deltaZ < 0) || (playerVelocity.z < 0 && deltaZ > 0)) {
                            playerVelocity.z = 0;
                        }
                    }
                } 
            } 
        } 
    } 

    isOnGround = newIsOnGroundThisFrame; 

    
    if (!isOnGround && wasOnGround) {
        
        if (verticalVelocity <=0) { 
            fallDistance = 0; 
        }
    }
    wasOnGround = isOnGround; 

    
    if (camera.position.y < -65) { 
        
    }
    
    for(let mob in mobs){

    }
}


let immune = true;
let justLogOn = true;

document.addEventListener("pointerlockchange", () => {
  if(justLogOn){
    justLogOn = false;
    setTimeout(() => {
      immune = false;
    }, 3000)
  }
});
const fallDamageSound = new Audio("minecraft-fall-damage.mp3");
function applyDamage(amount, source = "unknown") {
    if(immune)return;
    console.log(immune)
    playerHealth -= amount;
    if(source === "fall" && currentDimension === "overworld"){ fallDamageSound.play();
      console.log(`Damage taken: ${amount} from ${source}. Health remaining: ${playerHealth}`); 
      updateHealthUI(); 
    }
    camera.rotation.x += 0.1;
    setTimeout(() => {
        camera.rotation.x -= 0.1;
    }, 100);
    
    if (playerHealth <= 0) {
        handlePlayerDeath(source);
    }
}


function handlePlayerDeath(reason = "unknown") {
    console.log(`Player died! Reason: ${reason}. Reloading page.`);
    
    
        window.location.reload(); 
    
}
      let tickInterval = setInterval(tick, 50); 
      let tps = 0;
      let triggeredTpsMeasure = false;
      let lastTickTime = performance.now();
      let timeOutInRain = 0;
      let rainFreezeDamageInterval = 20000;
      let timeStayedInRain = 0;
      let underABlock = false;
      let rainTimeOut = Math.random() * (12000 - 6000) + 6000;
      let rainTimeWait = 0;
      let weather = "clear"
      let timeAfterRainClear = Math.random() * (24000 - 12000) + 12000;
      let beaconNum = 0;
      let starveInterval = 3000;

      const walkingOnGrassSound = new Audio("walking_on_grass.mp3");


      function tick() {
    const now = performance.now();
    const tickDeltaTime = now - lastTickTime; 
    lastTickTime = now;
    socket.emit("updateCameraPosition", camera.position);

    
    time++
        if(time % 24000 === 0) {
          time = 0;
        }
        let colour = scene.background;
        colour = `${colour.r}, ${colour.g}, ${colour.b}`.split(", ").map(Number).map(c => c * 255).map(c => Math.floor(c));
        if(state === "increase") {
        directionalLight.intensity += (1 / 4000);
        ambientLight.intensity += (1 / 5000);
        if(directionalLight.intensity >= 0.7 || ambientLight.intensity >= 0.5){
          directionalLight.intensity = 0.7;
          ambientLight.intensity = 0.5;
        }
        if(time >= 6000 && time <= 18000){
          state = "decrease"
        }
        }
        else if(state === "decrease") {
        directionalLight.intensity -= (1 / 6000);
        ambientLight.intensity -= (1 / 6000);
        if(directionalLight.intensity <= 0 || ambientLight.intensity <= 0.2){
          directionalLight.intensity = 0;
          ambientLight.intensity = 0.2;
        }
        if(time >= 18000){
          state = "increase"
        }
        }


    
    timeSinceLastRegen += tickDeltaTime; 

    if (timeSinceLastRegen >= HEALTH_REGEN_INTERVAL && playerHealth < playerMaxHealth && playerHunger >= REGEN_HUNGER_THRESHOLD) {
        timeSinceLastRegen = 0; 

        
          playerHealth += 1; 
          playerHunger -= HUNGER_COST_PER_REGEN; 

          
          playerHealth = Math.min(playerHealth, playerMaxHealth);
          playerHunger = Math.max(0, playerHunger); 

          console.log(`Regenerated health. Health: ${playerHealth}, Hunger: ${playerHunger}`); 

          
          updateHealthUI();
          updateHungerUI();
    }
    else if(timeSinceLastRegen >= saturation_regen_interval && playerHealth < playerMaxHealth && playerHunger >= 20){
        timeSinceLastRegen = 0;
        playerHunger -= 0.25;
        playerHealth += 1;
        updateHungerUI();
        updateHealthUI();
    }

    
    tps++;
    if (!triggeredTpsMeasure) {
        triggeredTpsMeasure = true;
        setTimeout(() => {
            
            const measuredTPS = Math.min(tps, 20); 
            
            tps = 0;
            triggeredTpsMeasure = false;
        }, 1000);
    }
    
    if(world[getBlockKey(camera.position.x, camera.position.y - 1, camera.position.z)] && world[getBlockKey(camera.position.x, camera.position.y - 1, camera.position.z)].type === "grass_block") {
    walkingOnGrassSound.play()
    }
    if (activeFurnace && activeFurnace.inputItem && activeFurnace.fuelItem) {
        let madeProgress = false;
        
        if (activeFurnace.fuelBurnTime > 0) {
            activeFurnace.fuelBurnTime -= 1; 
            madeProgress = true;
            if (activeFurnace.fuelBurnTime <= 0) {
                
                activeFurnace.fuelItem.count--;
                if(activeFurnace.fuelItem.count <= 0) activeFurnace.fuelItem = null;
                
                madeProgress = true; 
            }
        } else if (activeFurnace.fuelItem) { 
             
             
             
        }


        
        if (activeFurnace.fuelBurnTime > 0 && activeFurnace.inputItem) {
            activeFurnace.smeltProgress += 1; 
            madeProgress = true;
            if (activeFurnace.smeltProgress >= activeFurnace.smeltTimeTotal) {
                
                
                
                
                
                
                
                
                
            }
        } else {
            
            if (activeFurnace.smeltProgress > 0) {
                activeFurnace.smeltProgress = Math.max(0, activeFurnace.smeltProgress - 2);
                madeProgress = true;
            }
        }

        if (madeProgress) {
             updateFurnaceProgressIndicators(); 
             
             
        }
    }
    if (activeFurnace && isFurnaceOpen) { 
        let furnaceNeedsUIUpdate = false;

        const canSmelt = activeFurnace.inputItem && getSmeltingResult(activeFurnace.inputItem.type);
        const hasFuel = activeFurnace.fuelBurnTimeRemaining > 0;

        
        if (!hasFuel && canSmelt && activeFurnace.fuelItem) {
            const burnTime = getFuelBurnTime(activeFurnace.fuelItem.type);
            if (burnTime > 0) {
                activeFurnace.fuelBurnTimeRemaining = burnTime;
                activeFurnace.currentMaxFuelBurnTime = burnTime; 
                activeFurnace.fuelItem.count--;
                if (activeFurnace.fuelItem.count <= 0) {
                    activeFurnace.fuelItem = null;
                }
                
                furnaceNeedsUIUpdate = true;
            }
        }

        
        if (canSmelt && activeFurnace.fuelBurnTimeRemaining > 0) {
            activeFurnace.smeltProgress++; 
            activeFurnace.fuelBurnTimeRemaining--; 

            if (activeFurnace.fuelBurnTimeRemaining <= 0 && activeFurnace.fuelItem) {
                 
                const nextBurnTime = getFuelBurnTime(activeFurnace.fuelItem.type);
                if (nextBurnTime > 0) {
                    activeFurnace.fuelBurnTimeRemaining = nextBurnTime;
                    activeFurnace.currentMaxFuelBurnTime = nextBurnTime;
                    activeFurnace.fuelItem.count--;
                    if (activeFurnace.fuelItem.count <= 0) activeFurnace.fuelItem = null;
                    
                } else {
                     
                     activeFurnace.currentMaxFuelBurnTime = 0; 
                }
            }
            furnaceNeedsUIUpdate = true;


            if (activeFurnace.smeltProgress >= TICKS_PER_ITEM_SMELT) {
                const resultType = getSmeltingResult(activeFurnace.inputItem.type);
                if (resultType) {
                    
                    if (!activeFurnace.outputItem) {
                        activeFurnace.outputItem = { type: resultType, count: 1 };
                    } else if (activeFurnace.outputItem.type === resultType && activeFurnace.outputItem.count < getItemMaxStackSize(resultType)) {
                        activeFurnace.outputItem.count++;
                    } else {
                        
                        
                        activeFurnace.smeltProgress = TICKS_PER_ITEM_SMELT -1; 
                         
                        
                        
                        
                        
                    }

                    
                    if (activeFurnace.outputItem && activeFurnace.outputItem.type === resultType) {
                         activeFurnace.inputItem.count--;
                         if (activeFurnace.inputItem.count <= 0) {
                             activeFurnace.inputItem = null;
                         }
                         activeFurnace.smeltProgress = 0; 
                         
                    }
                }
                furnaceNeedsUIUpdate = true;
            }
        } else {
            
            
            if (activeFurnace.smeltProgress > 0 && activeFurnace.fuelBurnTimeRemaining <= 0) {
                activeFurnace.smeltProgress = Math.max(0, activeFurnace.smeltProgress - 2); 
                furnaceNeedsUIUpdate = true;
            }
        }

        if (furnaceNeedsUIUpdate) {
            updateFurnaceUI(); 
        }
    } 
  if(rainTimeWait >= rainTimeOut){
    rain()
    rainTimeWait = 0
    rainTimeOut = Math.random() * (12000 - 6000) + 6000
    setTimeout(() => {
      weather = "clear"
      scene.background = new THREE.Color("rgb(135, 206, 235)");
      timeAfterRainClear = Math.random() * (24000 - 12000) + 12000
    }, timeAfterRainClear);
  }
    if(timeOutInRain >= rainFreezeDamageInterval && weather === "rain" && !underABlock){
      timeOutInRain = 17000;
      if(!immune && getBlockKey)playerHealth -= 1
      console.log("rain damage")
      updateHealthUI()
    }
    
    for(let y = 0; y < 315 - camera.position.y; y++){
      if(hasSolidBlock(camera.position.x, camera.position.y + y, camera.position.z)){
        timeOutInRain -= 75 / 315;
        underABlock = true;
      }
      else{
        timeOutInRain += 75 / 315
        underABlock = false;
      }
  }
  rainTimeWait += 1
  if (Math.floor(camera.position.x) === beaconBeam.position.x && Math.floor(camera.position.z) === beaconBeam.position.z) {
    if (beaconNum === 0) {
        beaconBeam.visible = false;
        beaconNum = 1;
        alert("You have reached Level 1 Goal!");
        alert("You have gained a new Ability! Your speed is now 1.5x faster!");
        maxSpeed *= 1.5;
        beaconLight.position.set(Math.floor(Math.random() * 300 - 300), -30, Math.floor(Math.random() * 300 - 300));
        beaconBeam.position.set(beaconLight.position.x, beaconLight.position.y, beaconLight.position.z);
        beaconBeam.visible = true;
    }
    else if (beaconNum === 1) {
        
        beaconNum = 2; 
        alert("You have reached Level 2 Goal!");
        alert("The beacon resonates with a strange energy... it's tearing a hole in reality!");

        
        beaconBeam.visible = false;
        beaconLight.visible = false;

        
        socket.emit('teleportToSpace');
        immune = true;
        setTimeout(() => {
          immune = false;
        }, 5000);
    }
    
    else if (beaconNum === 2) {
        
    }
}
  
  if(playerHunger <= 0 && starveInterval <= 0) {
    starveInterval = 3000;
    playerHealth -= 1;
    console.log("Player is starving! Health reduced by 1.");
    updateHealthUI();
    if(playerHealth <= 0) {
      handlePlayerDeath("starvation");
    }
  }
  else{
    starveInterval -= tickDeltaTime;
  }
  
  if(playerHunger > 0) {
    playerHunger -= 0.001; 
    updateHungerUI();
  }
  else{
    playerHunger = 0; 
  }
}
  const furnaceScreenElement = document.getElementById('furnace-screen');
if (furnaceScreenElement) {
    
    furnaceScreenElement.addEventListener('contextmenu', e => {
        
        e.preventDefault(); 
    });
    
    furnaceScreenElement.addEventListener('click', handleInventoryClick);
} else {
    console.error("#furnace-screen element not found for event listeners!");
}

function rain(){
  weather = "rain"
  scene.background = new THREE.Color("rgb(55, 126, 155)")
}
      
      const solidBlocks = ['grass', 'dirt', 'stone', 'cobblestone', 'iron_ore', 'gold_ore', 'diamond_ore', 'log', 'leaves', 'craftingtable', 'coal_ore', 'oxidized_iron_ore', 'bedrock', 'plank', 'furnace', "landmine"];
      function handleBlockPlace() {
        
        if (isInventoryOpen || isCraftingTableOpen || document.pointerLockElement !== renderer.domElement) {
            return;
        }

        
        mouse.x = 0;
        mouse.y = 0;
        raycaster.setFromCamera(mouse, camera);
        const inter = findBlockIntersection(raycaster.ray);

        if (inter) {
          const targetBlockPos = inter.blockPos;
          const targetBlockData = getBlock(targetBlockPos.x, targetBlockPos.y, targetBlockPos.z);

          
          if (targetBlockData && targetBlockData.type === 'craftingtable') {
              console.log("Opening crafting table UI");
              isCraftingTableOpen = true;
              isInventoryOpen = false; 
              document.getElementById("crafting-table-screen").style.display = "flex";
              document.getElementById("full-inventory-screen").style.display = "none";
              document.body.style.cursor = "default";
              checkCraftingTableRecipe(); 
              updateInventoryUI();
              document.exitPointerLock();
              return; 
          }
          else if(targetBlockData && targetBlockData.type === 'furnace') {
              console.log("Opening furnace UI");
              isFurnaceOpen = true;
              isInventoryOpen = false; 
              document.getElementById("furnace-screen").style.display = "flex";
              document.getElementById("full-inventory-screen").style.display = "none";
              document.body.style.cursor = "default";
              openFurnaceUI(targetBlockPos);
              document.getElementById("hud").style.display = "none";
              updateInventoryUI();
              document.exitPointerLock();
              return; 
          }

          
          const selectedItem = hotbar[selectedHotbarSlot];
          if (!selectedItem) return; 
          if (solidBlocks.includes(selectedItem.type)) {
          const placePos = {
            x: inter.blockPos.x + inter.normal.x,
            y: inter.blockPos.y + inter.normal.y,
            z: inter.blockPos.z + inter.normal.z,
          };

          
          const plMX = camera.position.x - PLAYER_WIDTH / 2;          
          const plPX = camera.position.x + PLAYER_WIDTH / 2;          
          const plMY = camera.position.y + playerCollisionBottomOffset; 
          const plPY = camera.position.y + playerCollisionTopOffset;   
          const plMZ = camera.position.z - PLAYER_WIDTH / 2;          
          const plPZ = camera.position.z + PLAYER_WIDTH / 2;          

          
          const bMX = placePos.x;          
          const bPX = placePos.x + 1;      
          const bMY = placePos.y;          
          const bPY = placePos.y + 1;      
          const bMZ = placePos.z;          
          const bPZ = placePos.z + 1;      

          
          const iX = plPX > bMX && plMX < bPX; 
          const iY = plPY > bMY && plMY < bPY; 
          const iZ = plPZ > bMZ && plMZ < bPZ; 

          
          if (iX && iY && iZ) {
            console.log("Placement stopped: Intersects player.");
            return; 
          }
          


          
          if (hasSolidBlock(placePos.x, placePos.y, placePos.z)) {
            console.log("Placement stopped: Space occupied.");
            return; 
          }

          
          addBlock(placePos.x, placePos.y, placePos.z, selectedItem.type); 
          selectedItem.count--; 
          if (selectedItem.count <= 0) {
            hotbar[selectedHotbarSlot] = null; 
          }
          updateInventoryUI(); 
        }
        else{
          useItem(selectedItem);
        }
      }
      }

      function useItem(item) {
        switch(item.type){
          case "apple":
            if(playerHunger >= 20) return;
            playerHunger += 5;
            clearInterval(starveInterval);
            if(hotbar[selectedHotbarSlot].count <= 1){
              hotbar[selectedHotbarSlot] = null;
              updateInventoryUI()
              updateHungerUI();
              return;
            }
            hotbar[selectedHotbarSlot].count--;
            updateHungerUI();
            updateInventoryUI();
            break;
        }
      }
      
      function findBlockIntersection(ray) {
        /* ... unchanged ... */ const step = 0.05;
        const max = 4.5;
        let dist = 0;
        const cur = new THREE.Vector3();
        const prev = new THREE.Vector3();
        prev.copy(ray.origin);
        while (dist < max) {
          cur.copy(ray.origin).add(ray.direction.clone().multiplyScalar(dist));
          const bX = Math.floor(cur.x);
          const bY = Math.floor(cur.y);
          const bZ = Math.floor(cur.z);
          if (hasBlock(bX, bY, bZ) && world[getBlockKey(bX, bY, bZ)] && world[getBlockKey(bX, bY, bZ)].solid) {
            const dx = prev.x - (bX + 0.5);
            const dy = prev.y - (bY + 0.5);
            const dz = prev.z - (bZ + 0.5);
            const aX = Math.abs(dx);
            const aY = Math.abs(dy);
            const aZ = Math.abs(dz);
            const norm = new THREE.Vector3();
            let face = "";
            if (aX > aY && aX > aZ) {
              norm.setX(Math.sign(dx));
              face = dx > 0 ? "right" : "left";
            } else if (aY > aZ) {
              norm.setY(Math.sign(dy));
              face = dy > 0 ? "top" : "bottom";
            } else {
              norm.setZ(Math.sign(dz));
              face = dz > 0 ? "front" : "back";
            }
            return {
              blockPos: { x: bX, y: bY, z: bZ },
              face: face,
              point: cur,
              normal: norm,
            };
          }
          prev.copy(cur);
          dist += step;
        }
        return null;
      }

      
      const moveSpeed = 5;
      const airControlFactor = 0.8;
      const airAccelerationFactor = 0.5; 
      let friction = 0.05;
      let velocityX = 0;
      let velocityZ = 0;
      const keys = {
        w: false,
        a: false,
        s: false,
        d: false,
        space: false,
        shift: false,
        ctrl: false,
        x: false,
        l: false,
      };
      let yaw = -Math.PI / 2;
      let pitch = 0;
      const mouseSensitivity = 0.001;
      const playerVelocity = new THREE.Vector3(0, 0, 0); 
      let maxSpeed = 5.0 * 1.2; 
      const acceleration = 60.0; 
      const dampingFactor = 0.83; 
      const stopThreshold = 0.05; 
      




const AIR_ACCELERATION_SAME_AS_GROUND = true; 
const AIR_ACCELERATION_FACTOR = 0.2; 

const SPRINT_SPEED_MULTIPLIER = 1.5; 
const SNEAK_SPEED_MULTIPLIER = 0.3;  






function handleDropItem() {
    
    const selectedItem = hotbar[selectedHotbarSlot];

    
    if (!selectedItem) {
        return;
    }

    
    selectedItem.count--;

    
    const itemTypeToDrop = selectedItem.type;

    
    if (selectedItem.count <= 0) {
        hotbar[selectedHotbarSlot] = null;
    }

    
    updateInventoryUI();

    
    const spawnPosition = camera.position.clone();
    const throwDirection = new THREE.Vector3();
    camera.getWorldDirection(throwDirection); 

    
    spawnPosition.add(throwDirection.clone().multiplyScalar(1.0));

    
    const throwVelocity = throwDirection.multiplyScalar(0.3);
    throwVelocity.y += 0.1;

    
    createItemDrop(spawnPosition, itemTypeToDrop, throwVelocity);
}



function updateDroppedItems(deltaTime) {
    if (droppedItems.length === 0) return;

    
    for (let i = droppedItems.length - 1; i >= 0; i--) {
        const item = droppedItems[i];

        
        if (performance.now() - item.creationTime > ITEM_LIFESPAN) {
            scene.remove(item.mesh);
            item.mesh.geometry.dispose();
            item.mesh.material.dispose();
            droppedItems.splice(i, 1);
            continue; 
        }
        if (item.pickupCooldown > 0) {
            item.pickupCooldown -= deltaTime * 1000; 
        }

        
        const playerPos = new THREE.Vector3(camera.position.x, camera.position.y - (currentPlayerHeight/2), camera.position.z);
        
        
        
        if (item.pickupCooldown <= 0 && item.position.distanceTo(playerPos) < ITEM_PICKUP_RADIUS) {
            if (addToInventory(item.type, 1)) {
                scene.remove(item.mesh);
                item.mesh.geometry.dispose();
                item.mesh.material.dispose();
                droppedItems.splice(i, 1);
                continue;
            }
        }

        
        if (!item.onGround) {
            item.velocity.y -= ITEM_GRAVITY;
            item.position.add(item.velocity);
            
            
            const blockBelow = getBlock(item.position.x, item.position.y - 0.2, item.position.z);
            if (blockBelow && blockBelow.solid) {
                item.onGround = true;
                item.velocity.y = 0; 
                item.position.y = Math.floor(item.position.y) + 0.25; 
            }
        }
        
        
        item.mesh.position.y = item.position.y + Math.sin(performance.now() * 0.002 + item.creationTime) * 0.1;
        item.mesh.position.x = item.position.x;
        item.mesh.position.z = item.position.z;
        item.mesh.rotation.y += 0.01; 
    }
}

function updateCameraPosition(deltaTime) {
    
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

    const right = new THREE.Vector3(1, 0, 0);
    right.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

    const inputDirection = new THREE.Vector3(); 
    if (keys.w) inputDirection.add(forward);
    if (keys.s) inputDirection.sub(forward);
    if (keys.a) inputDirection.sub(right);
    if (keys.d) inputDirection.add(right);

    if (inputDirection.lengthSq() > 0) { 
        inputDirection.normalize();
    }

    
    const isSneaking = keys.shift;
    
    const canSprint = keys.ctrl && isOnGround && !isSneaking && (keys.w || inputDirection.z < -0.1); 

    let speedMultiplier = 1.0;
    if (isSneaking) {
        speedMultiplier = SNEAK_SPEED_MULTIPLIER;
    } else if (canSprint) {
        speedMultiplier = SPRINT_SPEED_MULTIPLIER;
    }

    const currentApplicableMaxSpeed = maxSpeed * speedMultiplier;
    
    const currentApplicableAcceleration = acceleration; 

    
    let effectiveAccelerationRate;
    if (AIR_ACCELERATION_SAME_AS_GROUND) {
        effectiveAccelerationRate = currentApplicableAcceleration;
    } else {
        effectiveAccelerationRate = isOnGround ? currentApplicableAcceleration : currentApplicableAcceleration * AIR_ACCELERATION_FACTOR;
    }

    
    const accelerationToApply = inputDirection.multiplyScalar(effectiveAccelerationRate * deltaTime);
    playerVelocity.x += accelerationToApply.x;
    playerVelocity.z += accelerationToApply.z;

    
    let currentDamping = dampingFactor; 
    if (!isOnGround) {
        currentDamping = 0.985; 
    }
    
    playerVelocity.x *= Math.pow(currentDamping, deltaTime * 60);
    playerVelocity.z *= Math.pow(currentDamping, deltaTime * 60);
    
    
    


    
    const horizontalSpeedSq = playerVelocity.x * playerVelocity.x + playerVelocity.z * playerVelocity.z;
    if (horizontalSpeedSq > currentApplicableMaxSpeed * currentApplicableMaxSpeed) {
        const horizontalSpeed = Math.sqrt(horizontalSpeedSq);
        playerVelocity.x = (playerVelocity.x / horizontalSpeed) * currentApplicableMaxSpeed;
        playerVelocity.z = (playerVelocity.z / horizontalSpeed) * currentApplicableMaxSpeed;
    }

    
    if (!(keys.w || keys.a || keys.s || keys.d) && playerVelocity.lengthSq() < stopThreshold * stopThreshold) {
        playerVelocity.x = 0;
        playerVelocity.z = 0;
    }

    
    
    camera.position.x += playerVelocity.x * deltaTime;
    camera.position.z += playerVelocity.z * deltaTime;

    
    if (keys.space && isOnGround) {
        verticalVelocity = jumpHeight; 
        isOnGround = false;       
        wasOnGround = true;       
        fallDistance = 0;         
    }

    
    
    camera.rotation.set(pitch, yaw, 0, "YXZ"); 

    
    const { cx: currentChunkCoordX, cz: currentChunkCoordZ } = worldToChunkCoords(
        camera.position.x,
        camera.position.z
    );
    if (currentChunkCoordX !== lastPlayerChunkX || currentChunkCoordZ !== lastPlayerChunkZ) {
        lastPlayerChunkX = currentChunkCoordX;
        lastPlayerChunkZ = currentChunkCoordZ;
        chunksNeedUpdate = true; 
        
    }
}
      
      let isBreaking = false;
      let currentBreakingTarget = null;
      let breakStartTime = 0;
      let breakProgress = 0;
      




function updateBreaking(deltaTime) {
    
    if (!isBreaking || isInventoryOpen || isCraftingTableOpen || document.pointerLockElement !== renderer.domElement) {
        if (isBreaking) {
            isBreaking = false;
            currentBreakingTarget = null;
        }
        return;
    }

    
    mouse.x = 0;
    mouse.y = 0;
    raycaster.setFromCamera(mouse, camera);
    const inter = findBlockIntersection(raycaster.ray);
    const targetPosition = inter ? inter.blockPos : null;

    if (!targetPosition || !currentBreakingTarget || targetPosition.x !== currentBreakingTarget.x || targetPosition.y !== currentBreakingTarget.y || targetPosition.z !== currentBreakingTarget.z) {
        currentBreakingTarget = targetPosition;
        breakProgress = 0;
        breakStartTime = performance.now();
        if (!currentBreakingTarget) return;
    }

    
    const blockKey = getBlockKey(currentBreakingTarget.x, currentBreakingTarget.y, currentBreakingTarget.z);
    const blockData = world[blockKey];
    if (!blockData) { isBreaking = false; return; }

    const blockType = blockData.type;
    const breakProps = breakInfo[blockType];
    if (!breakProps || breakProps.hardness <= 0) {
        breakProgress = 0;
        return;
    }

    
    const selectedItem = hotbar[selectedHotbarSlot];
    const heldItemType = selectedItem ? selectedItem.type : null;
    const heldToolCategory = toolTypes[heldItemType]; 

    let speedMultiplier = 1.0; 

    
    if (breakProps.tool !== 'any') {
        if (heldToolCategory === breakProps.tool) {
            
            speedMultiplier = toolMaterialSpeeds[heldItemType] || 1.0;
        } else {
            
            speedMultiplier = 0.15; 
        }
    } 
    
    else {
        if (heldToolCategory === breakProps.optimalTool) {
            
            speedMultiplier = toolMaterialSpeeds[heldItemType] || 1.0;
        } else {
            
            speedMultiplier = 0.4; 
        }
    }
    
    
    const baseHardnessFactor = 600;
    const requiredTime = (breakProps.hardness * baseHardnessFactor) / speedMultiplier;
    const elapsedTime = performance.now() - breakStartTime;
    breakProgress = Math.min(elapsedTime / requiredTime, 1.0);

    
    if (breakProgress >= 1.0) {
        removeBlockAt(currentBreakingTarget.x, currentBreakingTarget.y, currentBreakingTarget.z);
    }
}

      

function getSlotLocation(slotIndex) {
    if (!slotIndex || typeof slotIndex !== "string") {
        
        return null;
    }

    const parts = slotIndex.split("-");
    const type = parts[0];
    let indexPrefix = ""; 
    let indexStr;

    if (parts.length === 3) { 
        indexPrefix = parts[1]; 
        indexStr = parts[2];
    } else if (parts.length === 2) { 
        indexStr = parts[1];
    } else { 
        indexStr = parts.length > 1 ? parts[parts.length - 1] : null; 
        
    }


    const index = parseInt(indexStr);

    
    if (isNaN(index) && (slotIndex === "crafting-output" || slotIndex === "craftingtable-output" || slotIndex === "furnace-output-0")) {
        if (slotIndex === "crafting-output") {
            return { array: [craftingOutput], index: 0, type: "crafting-output" };
        } else if (slotIndex === "craftingtable-output") {
            return { array: [craftingTableOutput], index: 0, type: "craftingtable-output" };
        } else if (slotIndex === "furnace-output-0") { 
             if (!activeFurnace) { console.error("getSlotLocation: furnace-output-0 clicked but no activeFurnace!"); return null; }
             
             return { array: [activeFurnace.outputItem], index: 0, type: "furnace-output", sourceObject: activeFurnace, propertyName: 'outputItem' };
        }
        
        return null;
    }

    
    if (isNaN(index) && type !== "furnace") { 
         console.error(`getSlotLocation: Could not parse index from slotIndex: '${slotIndex}' -> '${indexStr}'`);
         return null;
    }


    switch (type) {
        case "hotbar": 
            return { array: hotbar, index: index, type: type, prefix: indexPrefix };
        case "storage": 
            return { array: storage, index: index, type: type, prefix: indexPrefix };
        case "armor":
            return { array: armor, index: index, type: type }; 
        case "crafting": 
            return { array: craftingGrid, index: index, type: type };
        case "craftingtable": 
            return { array: craftingTableGrid, index: index, type: type };
        case "furnace": 
            if (!activeFurnace) {
                console.error("getSlotLocation: Furnace slot clicked but no activeFurnace!");
                return null;
            }
            if (slotIndex === `furnace-input-0`) { 
                 
                return { array: [activeFurnace.inputItem], index: 0, type: "furnace-input", sourceObject: activeFurnace, propertyName: 'inputItem' };
            } else if (slotIndex === `furnace-fuel-0`) {
                return { array: [activeFurnace.fuelItem], index: 0, type: "furnace-fuel", sourceObject: activeFurnace, propertyName: 'fuelItem' };
            }
            
            break; 
        default:
            console.error("getSlotLocation: Unknown slot type:", type, "from slotIndex:", slotIndex);
            return null;
    }
    
    return null;
}
      

function setSlotData(slotIndex, itemData) {
    const loc = getSlotLocation(slotIndex);
    if (!loc) {
        console.error("setSlotData: Could not get slot location for", slotIndex);
        return false;
    }

    
    if (loc.sourceObject && typeof loc.propertyName !== 'undefined') {
        
        const currentItem = loc.sourceObject[loc.propertyName];
        if (JSON.stringify(currentItem) === JSON.stringify(itemData)) {
            return true; 
        }
        
        loc.sourceObject[loc.propertyName] = itemData; 

        
        if (loc.type === "furnace-input" || loc.type === "furnace-fuel") {
            
            
            
        }
        
        return true;
    }

    
    if (!loc.array) {
        console.error("setSlotData: Slot location has no array for", slotIndex, loc);
        return false;
    }

    
    if (loc.type === "crafting-output") {
        craftingOutput = itemData; 
        return true;
    } else if (loc.type === "craftingtable-output") {
        craftingTableOutput = itemData;
        return true;
    }

    
    if (typeof loc.index === 'undefined' || loc.index < 0 || loc.index >= loc.array.length && !(loc.array.length === 0 && loc.index === 0) ) {
         if (loc.array.length === 1 && loc.index === 0) { 
             
         } else {
             console.error("setSlotData: Invalid index for slot", slotIndex, "Index:", loc.index, "Array length:", loc.array.length);
             return false;
         }
    }


    const currentItem = loc.array[loc.index];
    if (JSON.stringify(currentItem) === JSON.stringify(itemData)) {
        
        return true;
    }

    
    loc.array[loc.index] = itemData;

    if (loc.type === "crafting") {
        
        checkCraftingRecipe();
    } else if (loc.type === "craftingtable") {
        
        checkCraftingTableRecipe();
    }
    return true;
}
            
            function handleInventoryClick(event) {
        
        if (isDragging) {
            console.log("handleInventoryClick blocked: Right drag in progress.");
            return;
        }
        if (!isInventoryOpen && !isCraftingTableOpen) {
             console.log("handleInventoryClick blocked: No inventory open.");
             return;
        }

        const clickedSlotElement = event.target.closest(".inventory-slot");

        
        /*
        if (!clickedSlotElement) {
          
          const invScreen = document.getElementById('full-inventory-screen');
          const ctScreen = document.getElementById('crafting-table-screen');
          const isClickInsideInv = isInventoryOpen && invScreen && invScreen.contains(event.target);
          const isClickInsideCt = isCraftingTableOpen && ctScreen && ctScreen.contains(event.target);

          
          if (isClickInsideInv || isClickInsideCt) {
              console.log("Clicked outside a slot within inventory area.");
              if (itemOnCursor) {
                updateInventoryUI();
              }
          } else {
               
          }
          return; 
        }
          */


        
        const slotIndex = clickedSlotElement.dataset.slotIndex;
        if (!slotIndex) {
            console.error("Clicked element is slot-like but has no slotIndex dataset!");
            return;
        }

        
        const slotLocation = getSlotLocation(slotIndex);
        if (!slotLocation || !slotLocation.array) { 
             console.error("Could not get valid slot location for index:", slotIndex);
             return; 
        }
        

        const itemInSlot = slotLocation.array[slotLocation.index]; 
        const clickedSlotItem = itemInSlot ? { ...itemInSlot } : null; 
        const cursorMaxStack = itemOnCursor ? getItemMaxStackSize(itemOnCursor.type) : DEFAULT_MAX_STACK_SIZE;
        const slotMaxStack = clickedSlotItem ? getItemMaxStackSize(clickedSlotItem.type) : DEFAULT_MAX_STACK_SIZE;


        
        if (event.button === 2) {
            event.preventDefault(); 

            
            if (itemOnCursor) {
                
                if (slotLocation.type === "crafting-output" || slotLocation.type === "craftingtable-output" || slotLocation.type === "armor") {
                    console.log(" Cannot place single items into output/armor with right click.");
                    return;
                }

                let currentSlotItem = slotLocation.array[slotLocation.index]; 
                if (!currentSlotItem) { 
                    console.log(" Placing 1 item in empty slot.");
                    if (itemOnCursor.count >= 1) { 
                        let newItem = { type: itemOnCursor.type, count: 1 };
                        setSlotData(slotIndex, newItem); 
                        itemOnCursor.count--;
                        if (itemOnCursor.count <= 0) itemOnCursor = null;
                        updateInventoryUI();
                    }
                } else if (currentSlotItem.type === itemOnCursor.type && currentSlotItem.count < getItemMaxStackSize(currentSlotItem.type)) { 
                    console.log(" Adding 1 item to existing stack.");
                     if (itemOnCursor.count >= 1) { 
                        let updatedItem = {...currentSlotItem}; 
                        updatedItem.count++; 
                        setSlotData(slotIndex, updatedItem); 

                        itemOnCursor.count--;
                        if (itemOnCursor.count <= 0) itemOnCursor = null;
                        updateInventoryUI();
                     }
                } else {
                     console.log(" Cannot place item: Slot incompatible or full.");
                }
            }
            
            else if (clickedSlotItem) { 
                 
                 if (slotLocation.type === "crafting-output" || slotLocation.type === "craftingtable-output") {
                      console.log(" Cannot split stack from output slot.");
                    return;
                }
                
                const amountToPickUp = Math.ceil(clickedSlotItem.count / 2);
                 console.log(` Picking up ${amountToPickUp} from stack of ${clickedSlotItem.count}.`);
                itemOnCursor = { type: clickedSlotItem.type, count: amountToPickUp }; 

                
                let remainingItem = {...clickedSlotItem}; 
                remainingItem.count -= amountToPickUp;

                
                 if (remainingItem.count <= 0) {
                     setSlotData(slotIndex, null); 
                 } else {
                     setSlotData(slotIndex, remainingItem); 
                 }
                updateInventoryUI();
            } else {
                 console.log(" Right-click on empty slot with empty cursor - doing nothing.");
            }
            updateInventoryUI()
            return; 
        } 


        
        if (event.button === 0) {
            console.log("Processing left-click action.");

            
            if (slotLocation.type === "crafting-output" || slotLocation.type === "craftingtable-output") {
                 console.log(" Clicked on crafting output slot.");
                 const isTableOutput = slotLocation.type === "craftingtable-output";
                 
                 const currentOutput = isTableOutput ? craftingTableOutput : craftingOutput;
                 const outputMaxStack = currentOutput ? getItemMaxStackSize(currentOutput.type) : DEFAULT_MAX_STACK_SIZE;
                 
                 if ((!itemOnCursor || (itemOnCursor.type === currentOutput.type && itemOnCursor.count < cursorMaxStack))) {
                     const gridToCheck = isTableOutput ? craftingTableGrid : craftingGrid;
                     const gridSizeType = isTableOutput ? '3x3' : '2x2';
                     const recipe = findRecipe(gridToCheck, gridSizeType); 
                          if (recipe && recipe.output.type === currentOutput.type) { 
                           
                           const spaceOnCursor = !itemOnCursor ? outputMaxStack : cursorMaxStack - itemOnCursor.count;
                           if (currentOutput.count <= spaceOnCursor) {
                               const outputCopy = { ...currentOutput }; 

                               
                               const gridElementCount = isTableOutput ? CRAFTING_TABLE_GRID_SIZE : CRAFTING_GRID_SIZE;
                           if (consumeRecipeIngredients(recipe, gridToCheck, gridElementCount)) {
                                
                               
                              if (!itemOnCursor) {
                                   
                                   itemOnCursor = outputCopy;
                                   console.log(itemOnCursor.count)
                                   console.log("Took crafted item onto empty cursor:", JSON.stringify(itemOnCursor));
                               } else if(itemOnCursor.type === outputCopy.type) {
                                   
                                   
                                   console.log("added items to cursor")
                                   itemOnCursor.count += outputCopy.count;
                                   console.log(`Added ${outputCopy.count} to cursor. New count: ${itemOnCursor.count}`);
                               }
                               else{
                                  console.log(itemOnCursor)
                               }

                               
                               
                               if (isTableOutput) {
                                   checkCraftingTableRecipe();
                               } else {
                                   checkCraftingRecipe();
                               }
                               console.log("Cursor state before final UI update in output handler:", JSON.stringify(itemOnCursor));
                               updateInventoryUI(); 

                           } else {
                               
                               console.error("Ingredient consumption failed unexpectedly!");
                               
                                if (isTableOutput) checkCraftingTableRecipe(); else checkCraftingRecipe();
                                updateInventoryUI();
                           }
                          
                           } else {
                               console.log("Cannot take crafted item, cursor does not have enough space for the stack.");
                           }
                     } else {
                         console.log("Recipe no longer valid for output click, or output mismatch?");
                         
                     }
                 } else if (currentOutput && itemOnCursor) {
                     console.log("Cannot take crafted item, cursor full or different type.");
                 } else {
                      console.log("Clicked empty output slot or no valid recipe output.");
                 }
                 return; 
                 console.warn(itemOnCursor, currentOutput.type, outputMaxStack);
            } 

            
             console.log(" Processing standard slot left-click.");
            if (itemOnCursor) { 
                 console.log(" Cursor has item.");
                
                if (!clickedSlotItem) {
                     console.log(" Slot is empty. Placing item from cursor.");
                     
                    setSlotData(slotIndex, itemOnCursor); 
                    itemOnCursor = null; 
                }
                
                else {
                     console.log(" Slot has item.");
                    
                    if (itemOnCursor.type === clickedSlotItem.type && clickedSlotItem.count < slotMaxStack) {
                         console.log(" Items are same type & stackable.");
                        const canAdd = slotMaxStack - clickedSlotItem.count;
                        const amountToAdd = Math.min(itemOnCursor.count, canAdd);
                         console.log(` Can add ${canAdd}, trying to add ${amountToAdd}.`);

                        if (amountToAdd > 0) {
                             
                             let updatedSlotItem = { ...clickedSlotItem };
                             updatedSlotItem.count += amountToAdd;
                             setSlotData(slotIndex, updatedSlotItem); 

                             
                             itemOnCursor.count -= amountToAdd;
                             if (itemOnCursor.count <= 0) {
                                 console.log(" Cursor empty after stacking.");
                                 itemOnCursor = null;
                             }
                        } else {
                             console.log("Cannot stack further (already full or adding 0). Swapping.");
                             
                              setSlotData(slotIndex, itemOnCursor); 
                              itemOnCursor = clickedSlotItem; 
                        }
                    }
                    
                    else {
                         console.log(" Items are different types or slot full. Swapping.");
                         
                         setSlotData(slotIndex, itemOnCursor); 
                         itemOnCursor = clickedSlotItem;   
                    }
                }
            }
            
            else { 
                 console.log(" Cursor is empty.");
                if (clickedSlotItem) { 
                     console.log(" Slot has item. Picking it up.");
                    itemOnCursor = clickedSlotItem; 
                    setSlotData(slotIndex, null);    
                } else {
                }
            }
            console.log("End of left-click standard handling. Updating UI.");
            updateInventoryUI(); 
        } 
        updateInventoryUI();
      } 

            
            const recipes = [
        
        {
          input: ["log", null, null, null], 
          output: { type: "plank", count: 4 },
          size: '2x2',
          shapeless: true
        },
        { 
          input: [null, "plank", null, "plank"],
          output: { type: "stick", count: 4 },
          size: '2x2'
        },
        {
          input: ["plank", "plank", "plank", "plank"],
          output: { type: "craftingtable", count: 1 },
          size: '2x2'
        },
         

        
        { 
          input: [
              'plank', 'plank', 'plank',
              null, 'stick', null,
              null, 'stick', null
          ],
          output: { type: "wooden_pickaxe", count: 1 },
          size: '3x3'
        },
        { 
          input: [
              'plank', 'plank', null,
              'plank', 'stick', null,
              null, 'stick', null
          ],
          output: { type: "wooden_axe", count: 1 },
          size: '3x3'
        },
         { 
          input: [
              null, 'plank', 'plank',
              null, 'stick', 'plank',
              null, 'stick', null
          ],
          output: { type: "wooden_axe", count: 1 },
          size: '3x3'
        },
        { 
          input: [
              null, 'plank', null,
              null, 'stick', null,
              null, 'stick', null
          ],
          output: { type: "wooden_shovel", count: 1 },
          size: '3x3'
        },
        { 
          input: [
              null, 'plank', null,
              null, 'plank', null,
              null, 'stick', null
          ],
          output: { type: "wooden_sword", count: 1 },
          size: '3x3'
        },
        {
          input: [
            "log", null, null,
            null, null, null,
            null, null, null
        ],
          output: { type: "plank", count: 4 },
          size: '3x3',
          shapeless: true
        },
        { 
          input: [
            "plank", null, null,
            "plank", null, null,
            null, null, null
        ],
          output: { type: "stick", count: 4 },
          size: '3x3'
        },
        {
          input:[
            "plank", "plank", null,
            "plank", "plank", null,
             null, null, null
          ],
          output: { type: "craftingtable", count: 1 },
          size: '3x3'
        },
        {
          input: [
            "cobblestone, cobblestone, cobblestone",
            null, "stick", null,
            null, "stick", null
          ],
          output: { type: "stone_pickaxe", count: 1 },
          size: '3x3'
        }
      ];
      
      function findRecipe(grid, size) {
        const gridTypes = grid.map((item) => (item ? item.type : null));
        const expectedInputLength = (size === '3x3' ? 9 : 4);

        for (const recipe of recipes) {
          
          if (recipe.size !== size || recipe.input.length !== expectedInputLength) {
              continue;
          }

          let match = false;

          if (recipe.shapeless && size === '2x2') { 
              const recipeItems = recipe.input.filter(t => t !== null);
              const gridItems = gridTypes.filter(t => t !== null);
              if (recipeItems.length === gridItems.length) {
                  const sortedRecipe = [...recipeItems].sort();
                  const sortedGrid = [...gridItems].sort();
                   match = sortedRecipe.every((val, index) => val === sortedGrid[index]);
              }
          } else { 
              match = true;
              for (let i = 0; i < expectedInputLength; i++) {
                  if (recipe.input[i] !== gridTypes[i]) {
                      match = false;
                      break;
                  }
              }
          }

          if (match) {
            
            
             let hasRequiredItems = true;
             for (let i = 0; i < expectedInputLength; i++) {
                 
                 if (recipe.input[i] !== null && grid[i] === null) {
                     hasRequiredItems = false;
                     break;
                 }
                 
                 if (!recipe.shapeless && recipe.input[i] === null && grid[i] !== null) {
                     hasRequiredItems = false;
                     break;
                 }
             }
             if(hasRequiredItems) return recipe; 
          }
        }
        return null; 
      }

      
      function consumeRecipeIngredients(recipe, grid, gridSize) {
          if (!recipe) return false;
          console.warn("executed")
          
          
          let tempGrid = grid.map(item => item ? {...item} : null);
          let consumed = true;

          if (recipe.shapeless && recipe.size === '2x2') {
               const recipeItems = recipe.input.filter(t => t !== null);
               for(const recipeItemType of recipeItems) {
                   let foundAndConsumed = false;
                   for(let i = 0; i < gridSize; i++) {
                       if(tempGrid[i] && tempGrid[i].type === recipeItemType && tempGrid[i].count > 0) {
                           tempGrid[i].count--;
                           if(tempGrid[i].count <= 0) {
                               tempGrid[i] = null;
                           }
                           foundAndConsumed = true;
                           break; 
                       }
                   }
                   if (!foundAndConsumed) {
                       console.error(`Shapeless recipe: Failed to find/consume ingredient ${recipeItemType}`);
                       consumed = false;
                       break;
                   }
               }
          } else { 
              for (let i = 0; i < gridSize; i++) {
                  if (recipe.input[i] !== null) {
                      if (tempGrid[i] && tempGrid[i].type === recipe.input[i]) {
                          tempGrid[i].count--;
                          if (tempGrid[i].count <= 0) {
                              tempGrid[i] = null;
                          }
                      } else {
                          console.error(`Shaped recipe: Mismatch/missing ingredient at index ${i}. Expected ${recipe.input[i]}, got ${tempGrid[i]?.type}`);
                          consumed = false;
                          break; 
                      }
                  }
              }
          }


          
          if (consumed) {
              for(let i = 0; i < gridSize; i++) {
                  
                  const slotType = recipe.size === '3x3' ? 'craftingtable' : 'crafting';
                  setSlotData(`${slotType}-${i}`, tempGrid[i]);
              }
          } else {
              console.error("Ingredient consumption failed. Grid state not changed.");
          }

          return consumed;
      }


      
      function checkCraftingRecipe() {
        const recipe = findRecipe(craftingGrid, '2x2');
        const newOutput = recipe ? { ...recipe.output } : null;
        
        if (JSON.stringify(craftingOutput) !== JSON.stringify(newOutput)) {
          setSlotData("crafting-output", newOutput); 
          console.log("2x2 Crafting output updated to:", newOutput);
        }
      }

      
      function checkCraftingTableRecipe() {
          const recipe = findRecipe(craftingTableGrid, '3x3');
          const newOutput = recipe ? { ...recipe.output } : null;
           
          if (JSON.stringify(craftingTableOutput) !== JSON.stringify(newOutput)) {
              setSlotData("craftingtable-output", newOutput); 
              console.log("3x3 Crafting output updated to:", newOutput);
          }
      }

      
      document.addEventListener("keydown", (e) => {
        const closeInv = () => {
            let screenClosed = false;
            if (isInventoryOpen) {
                isInventoryOpen = false;
                document.getElementById("full-inventory-screen").style.display = "none";
                screenClosed = true;
            }
            if (isCraftingTableOpen) { 
                isCraftingTableOpen = false;
                document.getElementById("crafting-table-screen").style.display = "none";
                 
                 
                 
                screenClosed = true;
            }
                closeFurnaceUI(); 
                screenClosed = true;

            if (screenClosed) {
                 
                if (itemOnCursor) {
                    if (!addToInventory(itemOnCursor.type, itemOnCursor.count)) {
                    console.log("Inventory full, discarding item:", itemOnCursor);
                    
                    }
                    itemOnCursor = null;
                    updateCursorDisplay(); 
                }

                 
                 isDragging = false;
                 dragSlots = [];
                 dragItemType = null;

                
                document.body.style.cursor = "none"; 
                 renderer.domElement.requestPointerLock().catch(err => console.log("Pointer lock rejected on inventory close."));
                console.log("Inventory/Crafting closed. Pointer lock requested.");
            }
        };

        
        if (e.code === "KeyE") {
          e.preventDefault(); 
          if (isInventoryOpen || isCraftingTableOpen) { 
            closeInv();
          } else if (document.pointerLockElement === renderer.domElement) {
            
            isInventoryOpen = true;
            isCraftingTableOpen = false; 
            document.getElementById("full-inventory-screen").style.display = "flex";
            document.getElementById("crafting-table-screen").style.display = "none"; 
            document.body.style.cursor = "default";
            checkCraftingRecipe(); 
            updateInventoryUI();
            document.exitPointerLock();
          }
          return;
        }

        
        if ((isInventoryOpen || isCraftingTableOpen) && e.code === "Escape") {
          e.preventDefault();
          closeInv();
          closeFurnaceUI()
          return;
        }

        
        if (!isInventoryOpen && !isCraftingTableOpen && document.pointerLockElement === renderer.domElement) {
          if (e.code === 'KeyQ') {
            e.preventDefault(); 
            handleDropItem();
          }
          const key = e.key.toLowerCase();
          if (key in keys) keys[key] = true;
          if (e.code === "Space") keys.space = true;
          if (e.code === "ShiftLeft" || e.code === "ShiftRight") keys.shift = true;
          if (e.code === "ControlLeft" || e.code === "ControlRight") keys.control = true;

          
          if (!isNaN(parseInt(key)) && parseInt(key) >= 1 && parseInt(key) <= 9) {
            selectedHotbarSlot = parseInt(key) - 1;
            updateInventoryUI(); 
          }
        }
        if(e.key === "ctrl"){
            keys.ctrl = true;
        }
        if(e.key === "x"){
            keys.x = true;
        }
        if(keys.x && keys.ctrl){
            e.preventDefault();
            console.log("CTRL + S pressed");
            
        }
      });
      document.addEventListener("keyup", (e) => {
        if (!isInventoryOpen) {
          const k = e.key.toLowerCase();
          if (k in keys) keys[k] = false;
          if (e.code === "Space") keys.space = false;
          if (e.code === "ShiftLeft" || e.code === "ShiftRight")
            keys.shift = false;
          if(e.key === "ctrl"){
              keys.ctrl = false;
          }
          if(e.key === "s"){
              keys.s = false;
          }
        }
      });
      document.addEventListener("mousemove", (e) => {
        if (document.pointerLockElement === renderer.domElement) {
          yaw -= e.movementX * mouseSensitivity;
          pitch -= e.movementY * mouseSensitivity;
          pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        }
        if (isInventoryOpen && itemOnCursorDisplay) {
          itemOnCursorDisplay.style.left = `${e.clientX + 5}px`;
          itemOnCursorDisplay.style.top = `${e.clientY + 5}px`;
        }
      });
                  
      document.addEventListener("mousedown", (e) => {
    if (e.target === renderer.domElement) {
        if (!isInventoryOpen && !isCraftingTableOpen && document.pointerLockElement !== renderer.domElement) {
            renderer.domElement.requestPointerLock()
                .catch((err) => console.error("Pointer lock request failed:", err));
        } else if (!isInventoryOpen && !isCraftingTableOpen && document.pointerLockElement === renderer.domElement) {
            if (e.button === 0) { // Left Click
                // --- MOB ATTACK LOGIC ---
                raycaster.setFromCamera({ x: 0, y: 0 }, camera);
                const mobMeshes = Array.from(mobs.values()).map(m => m.mesh);
                const intersections = raycaster.intersectObjects(mobMeshes);

                if (intersections.length > 0 && intersections[0].distance < 4.5) { // 4.5 block reach
                    const hitMesh = intersections[0].object;
                    // Find mobId by mesh
                    let hitMobId = null;
                    for (const [id, mob] of mobs.entries()) {
                        if (mob.mesh === hitMesh) {
                            hitMobId = id;
                            break;
                        }
                    }
                    if (hitMobId) {
                        socket.emit('hitMob', hitMobId);
                        return; // Stop processing, we hit a mob
                    }
                }

                // --- BLOCK BREAKING LOGIC (if no mob was hit) ---
                isBreaking = true;
                currentBreakingTarget = null;
                breakProgress = 0;
                breakStartTime = performance.now();
            } else if (e.button === 2) { // Right Click
                e.preventDefault();
                handleBlockPlace();
            }
        }
    } else if ((isInventoryOpen && document.getElementById("full-inventory-screen").contains(e.target)) ||
        (isCraftingTableOpen && document.getElementById("crafting-table-screen").contains(e.target))) {
        e.preventDefault();
        const clickedSlotElement = e.target.closest('.inventory-slot');
        if (clickedSlotElement && itemOnCursor && (e.button === 0 || e.button === 2)) {
            const slotIndex = clickedSlotElement.dataset.slotIndex;
            if (isValidSpreadTarget(slotIndex)) {
                isDragging = true;
                dragButton = e.button;
                dragItemType = itemOnCursor.type;
                dragSlots = [slotIndex];
                return;
            }
        }
        handleInventoryClick(e);
    }
  });
      
      renderer.domElement.addEventListener("mouseup", (e) => {
        if (e.button === 0 && isBreaking) {
          isBreaking = false;
          currentBreakingTarget = null;
          breakProgress = 0;
          breakStartTime = 0;
          indicatorCube.visible = false;
          console.log("Stopped breaking.");
        }
      });
      document.addEventListener("pointerlockchange", () => {
        const isLocked = document.pointerLockElement === renderer.domElement;
        document.getElementById("crosshair").style.display = isLocked
          ? "block"
          : "none";
        
        document.getElementById("hud").style.display =
          isLocked || isInventoryOpen || isCraftingTableOpen ? "grid" : "none";

        if (!isLocked && !isInventoryOpen && !isCraftingTableOpen) { 
          indicatorCube.visible = false;
          document.body.style.cursor = "default";
           
           document.getElementById("full-inventory-screen").style.display = "none";
           document.getElementById("crafting-table-screen").style.display = "none";
           isInventoryOpen = false; 
           isCraftingTableOpen = false;
        } else if (isLocked) {
          document.body.style.cursor = "none";
        } else { 
            document.body.style.cursor = "default";
        }
      });
      document.addEventListener("pointerlockerror", (e) => {
        console.error("Pointer lock error:", e);
        document.body.style.cursor = "default";
      });
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      window.addEventListener("wheel", (event) => {
        if (
          !isInventoryOpen &&
          document.pointerLockElement === renderer.domElement
        ) {
          if (event.deltaY < 0) {
            selectedHotbarSlot =
              (selectedHotbarSlot - 1 + HOTBAR_SIZE) % HOTBAR_SIZE;
          } else if (event.deltaY > 0) {
            selectedHotbarSlot = (selectedHotbarSlot + 1) % HOTBAR_SIZE;
          }
          updateInventoryUI();
        }
      });
            

            function isValidSpreadTarget(slotIndex) {
          if (!slotIndex) return false;
          
          
          return slotIndex.startsWith('storage-') ||
                 slotIndex.startsWith('hotbar-') ||
                 slotIndex.startsWith('crafting-') || 
                 slotIndex.startsWith('craftingtable-'); 
      }
      function getCraftingRecipe(recipeIndex) {
    return recipes[recipeIndex];
}

function removeCraftingRecipe(recipeIndex) {
    
    
    
    delete recipes[recipeIndex];
    recipeIndex = null;
}

            
            document.addEventListener('mousemove', (e) => {
          
          if ((isInventoryOpen || isCraftingTableOpen) && itemOnCursorDisplay) { 
            itemOnCursorDisplay.style.left = `${e.clientX + 5}px`;
            itemOnCursorDisplay.style.top = `${e.clientY + 5}px`;
          }

          
          if (isDragging) { 
              const slotElement = e.target.closest('.inventory-slot');
              if (slotElement) {
                  const slotIndex = slotElement.dataset.slotIndex;
                  
                  if (isValidSpreadTarget(slotIndex) && dragSlots[dragSlots.length - 1] !== slotIndex) {
                      dragSlots.push(slotIndex);
                      
                  }
              }
          }

          
          if (document.pointerLockElement === renderer.domElement) {
            yaw -= e.movementX * mouseSensitivity;
            pitch -= e.movementY * mouseSensitivity;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
         }
      });
      
                     
       document.addEventListener('mouseup', (e) => {
           
           if (e.button === 0 && isBreaking) {
             isBreaking = false;
             currentBreakingTarget = null;
             breakProgress = 0;
             breakStartTime = 0;
             indicatorCube.visible = false; 
             
           }

           
           if (isDragging && e.button === dragButton) { 
               e.preventDefault(); 
               console.log(`Finishing drag initiated by button ${dragButton}. Slots:`, dragSlots);

               if (itemOnCursor && dragSlots.length > 0) {
                   const numSlots = dragSlots.length;
                   const totalItemsOnCursor = itemOnCursor.count;
                   const dragItemMaxStack = getItemMaxStackSize(dragItemType); 
                   let itemsDistributed = 0;

                   
                   if (dragButton === 0 && !dragSlots.includes('crafting-output-0') && !dragSlots.includes('craftingtable-output-0')) { 
                       console.log("Distributing evenly (Left Drag)");
                       console.warn(itemOnCursor)
                       const baseAmount = Math.floor(totalItemsOnCursor / numSlots);
                       let remainder = totalItemsOnCursor % numSlots;

                       for (const slotIndex of dragSlots) {
                           if (itemOnCursor.count <= 0) break; 

                           const amountForThisSlot = baseAmount + (remainder > 0 ? 1 : 0);
                           if (amountForThisSlot <= 0 && baseAmount <= 0) continue; 
                           
const craftingSlots = ['crafting-1', 'crafting-2', 'crafting-3', 'crafting-4', 'crafting-5', 'crafting-6', 'crafting-7', 'crafting-8', 'crafting-9'];

const craftingTableSlots = ['craftingtable-1', 'craftingtable-2', 'craftingtable-3', 'craftingtable-4', 'craftingtable-5', 'craftingtable-6', 'craftingtable-7', 'craftingtable-8', 'craftingtable-9'];



if (slotIndex === 'crafting-output') { 
    const recipe = findRecipe(craftingGrid, '2x2');
    consumeRecipeIngredients(recipe, craftingGrid, 4);
    itemOnCursor.count += recipe.output.count;
    updateInventoryUI()
    return;
}
else if (slotIndex === 'craftingtable-output') {
    const recipe = findRecipe(craftingTableGrid, '3x3');
    consumeRecipeIngredients(recipe, craftingTableGrid, 9);
    itemOnCursor.count += recipe.output.count;
    updateInventoryUI()
    return;
}

                           const slotLoc = getSlotLocation(slotIndex);
                           if (!slotLoc) continue;

                           let targetSlotItem = slotLoc.array[slotLoc.index]; 

                           
                           if (!targetSlotItem || (targetSlotItem.type === dragItemType && targetSlotItem.count < dragItemMaxStack)) {
                               let actuallyAdded = 0;
                               let spaceAvailable = dragItemMaxStack;
                               if(targetSlotItem) {
                                   spaceAvailable = dragItemMaxStack - targetSlotItem.count;
                               }

                               actuallyAdded = Math.min(amountForThisSlot, spaceAvailable);

                               if (actuallyAdded > 0) {
                                   if (!targetSlotItem) {
                                       
                                       slotLoc.array[slotLoc.index] = { type: dragItemType, count: actuallyAdded };
                                   } else {
                                       
                                       targetSlotItem.count += actuallyAdded; 
                                   }
                                   itemsDistributed += actuallyAdded;
                                   
                                   setSlotData(slotIndex, slotLoc.array[slotLoc.index]);
                                   if (remainder > 0) remainder--;
                                  
                               }

                           } else {
                               
                                
                                if (amountForThisSlot > 0 && remainder > 0) remainder--;
                           }
                       } 

                   } else if (dragButton === 2) { 
                       console.log("Distributing one per slot (Right Drag)");
                       for (const slotIndex of dragSlots) {
                           if (itemOnCursor.count <= 0) break; 

                           const slotLoc = getSlotLocation(slotIndex);
                           if (!slotLoc) continue;

                           let targetSlotItem = slotLoc.array[slotLoc.index];

                           
                           if (!targetSlotItem || (targetSlotItem.type === dragItemType && targetSlotItem.count < dragItemMaxStack)) {
                               let actuallyAdded = 0;
                               if (!targetSlotItem) {
                                   slotLoc.array[slotLoc.index] = { type: dragItemType, count: 1 };
                                   actuallyAdded = 1;
                               } else { 
                                   targetSlotItem.count++;
                                   actuallyAdded = 1;
                               }

                               if (actuallyAdded === 1) {
                                   itemsDistributed++;
                                   
                                   setSlotData(slotIndex, slotLoc.array[slotLoc.index]);
                                  
                               }
                           } else {
                               
                           }
                       } 
                   }
                   

                   
                   if (itemOnCursor) { 
                       itemOnCursor.count -= itemsDistributed;
                       if (itemOnCursor.count <= 0) {
                           itemOnCursor = null; 
                       }
                       
                   }
               } 

               
               isDragging = false;
               dragButton = -1;
               dragSlots = [];
               dragItemType = null;
               updateInventoryUI(); 
           }
            
           
           else if (isDragging && e.button !== dragButton) {
               console.log(`Drag cancelled - wrong button released (Started: ${dragButton}, Released: ${e.button})`);
               isDragging = false;
               dragButton = -1;
               dragSlots = [];
               dragItemType = null;
               
           }
       });
       
        
       document.getElementById('full-inventory-screen').addEventListener('contextmenu', e => e.preventDefault());
       document.getElementById('crafting-table-screen').addEventListener('contextmenu', e => e.preventDefault());

      
      let lastFrameTime;
      const chunkUpdateInterval = 100;
      let lastChunkUpdateTime = 0;
      let fps = 0;
      let startMeasureFps = true;
      let triggeredMeasure = false;
      let timeStart = new Date();
      let previousIsSneaking = false;
      function animate(currentTime) {
        const now = performance.now();
        if (lastFrameTime === undefined) {
          lastFrameTime = now;
        }
        const deltaTime = (now - lastFrameTime) / 1000.0; 
        lastFrameTime = now;
        const clampedDeltaTime = Math.min(deltaTime, 0.1); 
        let gravity = (currentDimension === 'space') ? SPACE_GRAVITY : OVERWORLD_GRAVITY;
        const previousCameraY = camera.position.y;

        
        updatePlayerStance()

        if (keys.shift !== previousIsSneaking) {
        if (keys.shift) { 
            
            
            const eyeLevelDifference = PLAYER_STANDING_EYE_LEVEL_OFFSET - PLAYER_SNEAKING_EYE_LEVEL_OFFSET;
            camera.position.y -= eyeLevelDifference;
            
        } else { 
            
            
            const eyeLevelDifference = PLAYER_STANDING_EYE_LEVEL_OFFSET - PLAYER_SNEAKING_EYE_LEVEL_OFFSET;
            camera.position.y += eyeLevelDifference;
            

            
            
            
            
        }
    }
    previousIsSneaking = keys.shift;


        
        if (
          !isInventoryOpen &&
          !isCraftingTableOpen && 
          document.pointerLockElement === renderer.domElement
        ) {
          
          updateCameraPosition(clampedDeltaTime);

          
          mouse.x = 0;
          mouse.y = 0;
          raycaster.setFromCamera(mouse, camera);
          const inter = findBlockIntersection(raycaster.ray);
          if (inter) {
            const bp = inter.blockPos;
            indicatorCube.position.set(bp.x + 0.5, bp.y + 0.5, bp.z + 0.5);
            indicatorCube.visible = true;
          } else {
            indicatorCube.visible = false;
          }

          
          updateBreaking(clampedDeltaTime);

        } else {
            
             if (isBreaking) {
                isBreaking = false;
                currentBreakingTarget = null;
                breakProgress = 0;
                breakStartTime = 0;
                indicatorCube.visible = false; 
             }

            
            
            playerVelocity.multiplyScalar(dampingFactor);
               
              if (playerVelocity.lengthSq() < stopThreshold * stopThreshold) {
                 playerVelocity.set(0, 0, 0);
               }
            
        }


        
        
        if (
          chunksNeedUpdate ||
          now - lastChunkUpdateTime > chunkUpdateInterval
        ) {
          /*
          for(let cx = -RENDER_DISTANCE; cx <= RENDER_DISTANCE; cx++) {
            for(let cz = -RENDER_DISTANCE; cz <= RENDER_DISTANCE; cz++) {
              const chunkX = lastPlayerChunkX + cx;
              worker2.postMessage(["updateChunks", {chunkId: -2}]);
              worker.postMessage(["updateChunks", {chunkId: -1}]);
              worker3.postMessage(["updateChunks", {chunkId: 0}]);
              worker4.postMessage(["updateChunks", {chunkId: 1}]);
              worker5.postMessage(["updateChunks", {chunkId: 2}]);
            }
          }
            */
           socket.emit("updateChunks");
          lastChunkUpdateTime = now;
        }

        if(startMeasureFps) {
          fps++
          if(!triggeredMeasure) {
          setTimeout(() => {
              startMeasureFps = false;
              
              setTimeout(() => {
                  startMeasureFps = true;
                  triggeredMeasure = false;
                  fps = 0;
              }, 1000)
          }, 1000)
        }
        triggeredMeasure = true;
        }
        if(isPlayerFrozen){
          checkIfSafeToUnfreeze()
        }
        else{
          collisionTick()
        }

        if (meshCreationQueue.length > 0) {
            // Get the oldest task from the front of the queue
            const chunkDataToProcess = meshCreationQueue.shift();
            const { chunkId, meshDataArray } = chunkDataToProcess;
            const chunk = chunks.get(chunkId);

            if (chunk) {
                disposeChunkMeshes2(chunk); // Clear any old mesh first

                if (!chunk.meshes) {
                    chunk.meshes = new Map();
                }

                meshDataArray.forEach(meshInfo => {
                    if(!meshInfo) {
                        console.warn("Skipping null or undefined meshInfo in queue processing.");
                        return;
                    }

                    const material = materialMap.get(meshInfo.materialIdentifier);
                    const geometry = faceGeometries[meshInfo.faceName];

                    if (!material && meshInfo.materialIdentifier !== "cave_air_all") {
                        console.error(`ClientQueue: Material not found for identifier: "${meshInfo.materialIdentifier}" in chunk ${chunkId}.`);
                        return;
                    }
                    if (!geometry) {
                        console.error(`ClientQueue: Geometry not found for face name: "${meshInfo.faceName}" in chunk ${chunkId}.`);
                        return;
                    }
                    if (!meshInfo.matrices || meshInfo.count <= 0) {
                         return;
                    }

                    const expectedMatrixBufferSize = meshInfo.count * 16 * 4;
                    if (!meshInfo.matrices || meshInfo.matrices.byteLength !== expectedMatrixBufferSize) {
                         console.error(`ClientQueue: Matrix ArrayBuffer size mismatch for ${meshInfo.materialIdentifier}/${meshInfo.faceName}. Skipping mesh.`);
                         return;
                    }

                    // This is the heavy part that we are now pacing
                    const mesh = new THREE.InstancedMesh(geometry, material, meshInfo.count);
                    mesh.receiveShadow = true;
                    mesh.count = meshInfo.count;
                    mesh.name = `chunk_${chunkId}_mesh_${meshInfo.faceName}_${meshInfo.materialIdentifier}`;

                    const matrices = new Float32Array(meshInfo.matrices);
                    mesh.instanceMatrix.set(matrices);
                    mesh.instanceMatrix.needsUpdate = true;

                    scene.add(mesh);
                    chunk.meshes.set(mesh.name, mesh);
                });

                chunk.state = ChunkState.Active; // Mark chunk as active after processing
            }
        }
        mobs.forEach(mob => {
            mob.mesh.lookAt(camera.position);
        });

        // Update active projectiles
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const proj = projectiles[i];
            const elapsedTime = performance.now() - proj.startTime;
            const progress = Math.min(elapsedTime / proj.duration, 1.0);

            proj.mesh.position.lerpVectors(proj.start, proj.end, progress);

            if (progress >= 1.0) {
                scene.remove(proj.mesh);
                proj.mesh.geometry.dispose();
                proj.mesh.material.dispose();
                projectiles.splice(i, 1);
            }
        }

        renderer.render(scene, camera);
        
        /*
        fps++
        if(!triggeredMeasure) {
          triggeredMeasure = true;
          timeStart = timeStart.getTime();
        }
        let currentTime2 = new Date();
        console.log(`fps: ${Math.floor(fps / (currentTime2.getTime() - timeStart) * 1000)}`);
        */
        updateDroppedItems(clampedDeltaTime);
        updateChunkVisibility()
      }

      
      for(let i = 315; i < 315; i++){
        if(world[getBlockKey(0, i, 0)] && !world[getBlockKey(0, i+1, 0)] && !world[getBlockKey(0, i+2, 0)]){
          camera.position.y = i + 1;
          console.log("player spawn height", i + 1)
          
          camera.rotation.set(Math.PI / 2, 0, 0);
          break;
        }
      }
      updateInventoryUI();
      updateHealthUI();
      updateHungerUI();
      document.getElementById("hud").style.display = "none";
      document.getElementById("crosshair").style.display = "none";
      document.getElementById("full-inventory-screen").style.display = "none"; 
      document.getElementById("crafting-table-screen").style.display = "none"; 
      document.body.style.cursor = "default";
      console.log("Requesting initial chunk load...");
      lastPlayerChunkX = Math.floor(camera.position.x / CHUNK_SIZE);
      lastPlayerChunkZ = Math.floor(camera.position.z / CHUNK_SIZE);
      chunksNeedUpdate = true;
      animate(performance.now());
      
      setInterval(() => {
        animate()
      }, 1000 / 120);
      
      const platformSize = 3;
      const platformHeight = 25;
      const platformBlock = { type: "cobblestone", count: 9 };
      const platformStartX = Math.floor(camera.position.x - platformSize / 2);
      const platformStartZ = Math.floor(camera.position.z - platformSize / 2);
      for (let x = -1; x < platformSize + 1; x++) {
        for (let z = -1; z < platformSize + 1; z++) {
          internalAddBlock(platformStartX + x, platformHeight, platformStartZ + z, platformBlock.type);
        }
      }
    </script>
  </body>
</html>
